// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapLocationEhr.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MapLocationEhr_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MapLocationEhr_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MapLocationEhr_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace MapLocationEhr {
class Coordinate;
class CoordinateDefaultTypeInternal;
extern CoordinateDefaultTypeInternal _Coordinate_default_instance_;
class DatumPoint;
class DatumPointDefaultTypeInternal;
extern DatumPointDefaultTypeInternal _DatumPoint_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class LocalMap;
class LocalMapDefaultTypeInternal;
extern LocalMapDefaultTypeInternal _LocalMap_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class RoadSection;
class RoadSectionDefaultTypeInternal;
extern RoadSectionDefaultTypeInternal _RoadSection_default_instance_;
class VehicleState;
class VehicleStateDefaultTypeInternal;
extern VehicleStateDefaultTypeInternal _VehicleState_default_instance_;
class VehicleState_MatchInfo;
class VehicleState_MatchInfoDefaultTypeInternal;
extern VehicleState_MatchInfoDefaultTypeInternal _VehicleState_MatchInfo_default_instance_;
class Waypoint;
class WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
}  // namespace MapLocationEhr
PROTOBUF_NAMESPACE_OPEN
template<> ::MapLocationEhr::Coordinate* Arena::CreateMaybeMessage<::MapLocationEhr::Coordinate>(Arena*);
template<> ::MapLocationEhr::DatumPoint* Arena::CreateMaybeMessage<::MapLocationEhr::DatumPoint>(Arena*);
template<> ::MapLocationEhr::Lane* Arena::CreateMaybeMessage<::MapLocationEhr::Lane>(Arena*);
template<> ::MapLocationEhr::Line* Arena::CreateMaybeMessage<::MapLocationEhr::Line>(Arena*);
template<> ::MapLocationEhr::LocalMap* Arena::CreateMaybeMessage<::MapLocationEhr::LocalMap>(Arena*);
template<> ::MapLocationEhr::Point* Arena::CreateMaybeMessage<::MapLocationEhr::Point>(Arena*);
template<> ::MapLocationEhr::RoadSection* Arena::CreateMaybeMessage<::MapLocationEhr::RoadSection>(Arena*);
template<> ::MapLocationEhr::VehicleState* Arena::CreateMaybeMessage<::MapLocationEhr::VehicleState>(Arena*);
template<> ::MapLocationEhr::VehicleState_MatchInfo* Arena::CreateMaybeMessage<::MapLocationEhr::VehicleState_MatchInfo>(Arena*);
template<> ::MapLocationEhr::Waypoint* Arena::CreateMaybeMessage<::MapLocationEhr::Waypoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MapLocationEhr {

enum RoadClass : int {
  Unknown = 0,
  UrbanHighway = 1,
  UrbanSealedRoad = 2,
  NationalRoad = 3,
  ProvincialRoad = 4,
  CountyRoad = 5,
  OrdinaryRoad = 6,
  NarrowRoad = 7,
  RoadClass_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoadClass_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoadClass_IsValid(int value);
constexpr RoadClass RoadClass_MIN = Unknown;
constexpr RoadClass RoadClass_MAX = NarrowRoad;
constexpr int RoadClass_ARRAYSIZE = RoadClass_MAX + 1;

const std::string& RoadClass_Name(RoadClass value);
template<typename T>
inline const std::string& RoadClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadClass_Name.");
  return RoadClass_Name(static_cast<RoadClass>(enum_t_value));
}
bool RoadClass_Parse(
    const std::string& name, RoadClass* value);
enum RoadType : int {
  NoSpecial = 0,
  Ramp = 1,
  Roundabout = 2,
  Parallel = 3,
  ServiceRoad = 4,
  MainRoad = 5,
  Square = 6,
  PedestrianZone = 7,
  Pedestrian = 8,
  RoundaboutInterior = 9,
  SlipRoad = 10,
  SpecialTrafficFigure = 11,
  Boundary = 12,
  RoadType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoadType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoadType_IsValid(int value);
constexpr RoadType RoadType_MIN = NoSpecial;
constexpr RoadType RoadType_MAX = Boundary;
constexpr int RoadType_ARRAYSIZE = RoadType_MAX + 1;

const std::string& RoadType_Name(RoadType value);
template<typename T>
inline const std::string& RoadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadType_Name.");
  return RoadType_Name(static_cast<RoadType>(enum_t_value));
}
bool RoadType_Parse(
    const std::string& name, RoadType* value);
enum RoadAttribute : int {
  ControlAccess = 0,
  UTurn = 1,
  Parking = 2,
  Elevated = 3,
  Underpass = 4,
  UnderConstruction = 5,
  Motorway = 6,
  ServiceArea = 7,
  Toll = 8,
  ComplexIntersection = 9,
  PluralJunction = 10,
  Bridge = 24,
  Tunnel = 25,
  RoadAttribute_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RoadAttribute_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RoadAttribute_IsValid(int value);
constexpr RoadAttribute RoadAttribute_MIN = ControlAccess;
constexpr RoadAttribute RoadAttribute_MAX = Tunnel;
constexpr int RoadAttribute_ARRAYSIZE = RoadAttribute_MAX + 1;

const std::string& RoadAttribute_Name(RoadAttribute value);
template<typename T>
inline const std::string& RoadAttribute_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoadAttribute>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoadAttribute_Name.");
  return RoadAttribute_Name(static_cast<RoadAttribute>(enum_t_value));
}
bool RoadAttribute_Parse(
    const std::string& name, RoadAttribute* value);
enum ZLevelType : int {
  Invalid = 0,
  Overground = 1,
  ConnectOverground = 2,
  Underground = 3,
  ConnectUnderground = 4,
  ZLevelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ZLevelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ZLevelType_IsValid(int value);
constexpr ZLevelType ZLevelType_MIN = Invalid;
constexpr ZLevelType ZLevelType_MAX = ConnectUnderground;
constexpr int ZLevelType_ARRAYSIZE = ZLevelType_MAX + 1;

const std::string& ZLevelType_Name(ZLevelType value);
template<typename T>
inline const std::string& ZLevelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ZLevelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ZLevelType_Name.");
  return ZLevelType_Name(static_cast<ZLevelType>(enum_t_value));
}
bool ZLevelType_Parse(
    const std::string& name, ZLevelType* value);
// ===================================================================

class Coordinate :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.Coordinate) */ {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);
  Coordinate(Coordinate&& from) noexcept
    : Coordinate() {
    *this = ::std::move(from);
  }

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coordinate& operator=(Coordinate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Coordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coordinate* internal_default_instance() {
    return reinterpret_cast<const Coordinate*>(
               &_Coordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Coordinate& a, Coordinate& b) {
    a.Swap(&b);
  }
  inline void Swap(Coordinate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Coordinate* New() const final {
    return CreateMaybeMessage<Coordinate>(nullptr);
  }

  Coordinate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Coordinate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Coordinate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.Coordinate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMXFieldNumber = 1,
    kMYFieldNumber = 2,
    kMZFieldNumber = 3,
  };
  // double m_x = 1;
  void clear_m_x();
  double m_x() const;
  void set_m_x(double value);

  // double m_y = 2;
  void clear_m_y();
  double m_y() const;
  void set_m_y(double value);

  // double m_z = 3;
  void clear_m_z();
  double m_z() const;
  void set_m_z(double value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.Coordinate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  double m_x_;
  double m_y_;
  double m_z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class Point :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(nullptr);
  }

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.Point";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMXFieldNumber = 1,
    kMYFieldNumber = 2,
    kMZFieldNumber = 3,
  };
  // double m_x = 1;
  void clear_m_x();
  double m_x() const;
  void set_m_x(double value);

  // double m_y = 2;
  void clear_m_y();
  double m_y() const;
  void set_m_y(double value);

  // double m_z = 3;
  void clear_m_z();
  double m_z() const;
  void set_m_z(double value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.Point)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  double m_x_;
  double m_y_;
  double m_z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class DatumPoint :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.DatumPoint) */ {
 public:
  DatumPoint();
  virtual ~DatumPoint();

  DatumPoint(const DatumPoint& from);
  DatumPoint(DatumPoint&& from) noexcept
    : DatumPoint() {
    *this = ::std::move(from);
  }

  inline DatumPoint& operator=(const DatumPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatumPoint& operator=(DatumPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DatumPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatumPoint* internal_default_instance() {
    return reinterpret_cast<const DatumPoint*>(
               &_DatumPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DatumPoint& a, DatumPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(DatumPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DatumPoint* New() const final {
    return CreateMaybeMessage<DatumPoint>(nullptr);
  }

  DatumPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DatumPoint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DatumPoint& from);
  void MergeFrom(const DatumPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DatumPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.DatumPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPointFieldNumber = 2,
    kMDatumTimestampFieldNumber = 1,
  };
  // .MapLocationEhr.Coordinate m_point = 2;
  bool has_m_point() const;
  void clear_m_point();
  const ::MapLocationEhr::Coordinate& m_point() const;
  ::MapLocationEhr::Coordinate* release_m_point();
  ::MapLocationEhr::Coordinate* mutable_m_point();
  void set_allocated_m_point(::MapLocationEhr::Coordinate* m_point);

  // uint64 m_datumTimestamp = 1;
  void clear_m_datumtimestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_datumtimestamp() const;
  void set_m_datumtimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.DatumPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::MapLocationEhr::Coordinate* m_point_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_datumtimestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class VehicleState_MatchInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.VehicleState.MatchInfo) */ {
 public:
  VehicleState_MatchInfo();
  virtual ~VehicleState_MatchInfo();

  VehicleState_MatchInfo(const VehicleState_MatchInfo& from);
  VehicleState_MatchInfo(VehicleState_MatchInfo&& from) noexcept
    : VehicleState_MatchInfo() {
    *this = ::std::move(from);
  }

  inline VehicleState_MatchInfo& operator=(const VehicleState_MatchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleState_MatchInfo& operator=(VehicleState_MatchInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VehicleState_MatchInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleState_MatchInfo* internal_default_instance() {
    return reinterpret_cast<const VehicleState_MatchInfo*>(
               &_VehicleState_MatchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VehicleState_MatchInfo& a, VehicleState_MatchInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleState_MatchInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleState_MatchInfo* New() const final {
    return CreateMaybeMessage<VehicleState_MatchInfo>(nullptr);
  }

  VehicleState_MatchInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleState_MatchInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VehicleState_MatchInfo& from);
  void MergeFrom(const VehicleState_MatchInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleState_MatchInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.VehicleState.MatchInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMKeyFieldNumber = 1,
    kMLaneIndexFieldNumber = 2,
  };
  // uint64 m_key = 1;
  void clear_m_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key() const;
  void set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 m_laneIndex = 2;
  void clear_m_laneindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_laneindex() const;
  void set_m_laneindex(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.VehicleState.MatchInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_laneindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class VehicleState :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.VehicleState) */ {
 public:
  VehicleState();
  virtual ~VehicleState();

  VehicleState(const VehicleState& from);
  VehicleState(VehicleState&& from) noexcept
    : VehicleState() {
    *this = ::std::move(from);
  }

  inline VehicleState& operator=(const VehicleState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleState& operator=(VehicleState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const VehicleState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleState* internal_default_instance() {
    return reinterpret_cast<const VehicleState*>(
               &_VehicleState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VehicleState& a, VehicleState& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleState* New() const final {
    return CreateMaybeMessage<VehicleState>(nullptr);
  }

  VehicleState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const VehicleState& from);
  void MergeFrom(const VehicleState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.VehicleState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VehicleState_MatchInfo MatchInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kMMatchesFieldNumber = 7,
    kMPointFieldNumber = 4,
    kMRelativeVehicleFieldNumber = 5,
    kMTimestampFieldNumber = 1,
    kMDatumTimestampFieldNumber = 2,
    kMLastTimestampFieldNumber = 3,
    kMConfidenceFieldNumber = 6,
    kMHeadingFieldNumber = 8,
  };
  // repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
  int m_matches_size() const;
  void clear_m_matches();
  ::MapLocationEhr::VehicleState_MatchInfo* mutable_m_matches(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::VehicleState_MatchInfo >*
      mutable_m_matches();
  const ::MapLocationEhr::VehicleState_MatchInfo& m_matches(int index) const;
  ::MapLocationEhr::VehicleState_MatchInfo* add_m_matches();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::VehicleState_MatchInfo >&
      m_matches() const;

  // .MapLocationEhr.Coordinate m_point = 4;
  bool has_m_point() const;
  void clear_m_point();
  const ::MapLocationEhr::Coordinate& m_point() const;
  ::MapLocationEhr::Coordinate* release_m_point();
  ::MapLocationEhr::Coordinate* mutable_m_point();
  void set_allocated_m_point(::MapLocationEhr::Coordinate* m_point);

  // .MapLocationEhr.Coordinate m_relativeVehicle = 5;
  bool has_m_relativevehicle() const;
  void clear_m_relativevehicle();
  const ::MapLocationEhr::Coordinate& m_relativevehicle() const;
  ::MapLocationEhr::Coordinate* release_m_relativevehicle();
  ::MapLocationEhr::Coordinate* mutable_m_relativevehicle();
  void set_allocated_m_relativevehicle(::MapLocationEhr::Coordinate* m_relativevehicle);

  // uint64 m_timestamp = 1;
  void clear_m_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_timestamp() const;
  void set_m_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 m_datumTimestamp = 2;
  void clear_m_datumtimestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_datumtimestamp() const;
  void set_m_datumtimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 m_lastTimestamp = 3;
  void clear_m_lasttimestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lasttimestamp() const;
  void set_m_lasttimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 m_confidence = 6;
  void clear_m_confidence();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_confidence() const;
  void set_m_confidence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float m_heading = 8;
  void clear_m_heading();
  float m_heading() const;
  void set_m_heading(float value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.VehicleState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::VehicleState_MatchInfo > m_matches_;
  ::MapLocationEhr::Coordinate* m_point_;
  ::MapLocationEhr::Coordinate* m_relativevehicle_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_datumtimestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lasttimestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_confidence_;
  float m_heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class Waypoint :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.Waypoint) */ {
 public:
  Waypoint();
  virtual ~Waypoint();

  Waypoint(const Waypoint& from);
  Waypoint(Waypoint&& from) noexcept
    : Waypoint() {
    *this = ::std::move(from);
  }

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Waypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
               &_Waypoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Waypoint& a, Waypoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Waypoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Waypoint* New() const final {
    return CreateMaybeMessage<Waypoint>(nullptr);
  }

  Waypoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Waypoint>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Waypoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.Waypoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMCoordinateFieldNumber = 1,
    kMHeadingFieldNumber = 2,
    kMCurvatureFieldNumber = 3,
    kMSlopeFieldNumber = 4,
    kMCrossSlopeFieldNumber = 5,
    kMWidthFieldNumber = 6,
  };
  // .MapLocationEhr.Coordinate m_coordinate = 1;
  bool has_m_coordinate() const;
  void clear_m_coordinate();
  const ::MapLocationEhr::Coordinate& m_coordinate() const;
  ::MapLocationEhr::Coordinate* release_m_coordinate();
  ::MapLocationEhr::Coordinate* mutable_m_coordinate();
  void set_allocated_m_coordinate(::MapLocationEhr::Coordinate* m_coordinate);

  // int32 m_heading = 2;
  void clear_m_heading();
  ::PROTOBUF_NAMESPACE_ID::int32 m_heading() const;
  void set_m_heading(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 m_curvature = 3;
  void clear_m_curvature();
  ::PROTOBUF_NAMESPACE_ID::int32 m_curvature() const;
  void set_m_curvature(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 m_slope = 4;
  void clear_m_slope();
  ::PROTOBUF_NAMESPACE_ID::int32 m_slope() const;
  void set_m_slope(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 m_crossSlope = 5;
  void clear_m_crossslope();
  ::PROTOBUF_NAMESPACE_ID::int32 m_crossslope() const;
  void set_m_crossslope(::PROTOBUF_NAMESPACE_ID::int32 value);

  // uint32 m_width = 6;
  void clear_m_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_width() const;
  void set_m_width(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.Waypoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::MapLocationEhr::Coordinate* m_coordinate_;
  ::PROTOBUF_NAMESPACE_ID::int32 m_heading_;
  ::PROTOBUF_NAMESPACE_ID::int32 m_curvature_;
  ::PROTOBUF_NAMESPACE_ID::int32 m_slope_;
  ::PROTOBUF_NAMESPACE_ID::int32 m_crossslope_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_width_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class Lane :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }
  inline void Swap(Lane* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(nullptr);
  }

  Lane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lane* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.Lane";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMWaypointsFieldNumber = 4,
    kMKeyFieldNumber = 1,
    kMLaneIndexFieldNumber = 2,
    kMLengthFieldNumber = 3,
  };
  // repeated .MapLocationEhr.Waypoint m_waypoints = 4;
  int m_waypoints_size() const;
  void clear_m_waypoints();
  ::MapLocationEhr::Waypoint* mutable_m_waypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Waypoint >*
      mutable_m_waypoints();
  const ::MapLocationEhr::Waypoint& m_waypoints(int index) const;
  ::MapLocationEhr::Waypoint* add_m_waypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Waypoint >&
      m_waypoints() const;

  // uint64 m_key = 1;
  void clear_m_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key() const;
  void set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 m_laneIndex = 2;
  void clear_m_laneindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_laneindex() const;
  void set_m_laneindex(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 m_length = 3;
  void clear_m_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_length() const;
  void set_m_length(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.Lane)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Waypoint > m_waypoints_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_laneindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class Line :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(nullptr);
  }

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Line* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.Line";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMPointsFieldNumber = 4,
    kMLineIDFieldNumber = 1,
    kMLaneLineIndexFieldNumber = 2,
    kMElementSequenceFieldNumber = 3,
  };
  // repeated .MapLocationEhr.Point m_Points = 4;
  int m_points_size() const;
  void clear_m_points();
  ::MapLocationEhr::Point* mutable_m_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Point >*
      mutable_m_points();
  const ::MapLocationEhr::Point& m_points(int index) const;
  ::MapLocationEhr::Point* add_m_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Point >&
      m_points() const;

  // uint64 m_LineID = 1;
  void clear_m_lineid();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lineid() const;
  void set_m_lineid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 m_LaneLineIndex = 2;
  void clear_m_lanelineindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_lanelineindex() const;
  void set_m_lanelineindex(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 m_ElementSequence = 3;
  void clear_m_elementsequence();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_elementsequence() const;
  void set_m_elementsequence(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.Line)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Point > m_points_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lineid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_lanelineindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_elementsequence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class RoadSection :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.RoadSection) */ {
 public:
  RoadSection();
  virtual ~RoadSection();

  RoadSection(const RoadSection& from);
  RoadSection(RoadSection&& from) noexcept
    : RoadSection() {
    *this = ::std::move(from);
  }

  inline RoadSection& operator=(const RoadSection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoadSection& operator=(RoadSection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RoadSection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSection* internal_default_instance() {
    return reinterpret_cast<const RoadSection*>(
               &_RoadSection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoadSection& a, RoadSection& b) {
    a.Swap(&b);
  }
  inline void Swap(RoadSection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoadSection* New() const final {
    return CreateMaybeMessage<RoadSection>(nullptr);
  }

  RoadSection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoadSection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RoadSection& from);
  void MergeFrom(const RoadSection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoadSection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.RoadSection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAttributesFieldNumber = 4,
    kMLanesFieldNumber = 5,
    kMKeyFieldNumber = 1,
    kMRoadClassFieldNumber = 2,
    kMRoadTypeFieldNumber = 3,
  };
  // repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
  int m_attributes_size() const;
  void clear_m_attributes();
  ::MapLocationEhr::RoadAttribute m_attributes(int index) const;
  void set_m_attributes(int index, ::MapLocationEhr::RoadAttribute value);
  void add_m_attributes(::MapLocationEhr::RoadAttribute value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& m_attributes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_m_attributes();

  // repeated .MapLocationEhr.Lane m_lanes = 5;
  int m_lanes_size() const;
  void clear_m_lanes();
  ::MapLocationEhr::Lane* mutable_m_lanes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Lane >*
      mutable_m_lanes();
  const ::MapLocationEhr::Lane& m_lanes(int index) const;
  ::MapLocationEhr::Lane* add_m_lanes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Lane >&
      m_lanes() const;

  // uint64 m_key = 1;
  void clear_m_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key() const;
  void set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .MapLocationEhr.RoadClass m_roadClass = 2;
  void clear_m_roadclass();
  ::MapLocationEhr::RoadClass m_roadclass() const;
  void set_m_roadclass(::MapLocationEhr::RoadClass value);

  // .MapLocationEhr.RoadType m_roadType = 3;
  void clear_m_roadtype();
  ::MapLocationEhr::RoadType m_roadtype() const;
  void set_m_roadtype(::MapLocationEhr::RoadType value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.RoadSection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> m_attributes_;
  mutable std::atomic<int> _m_attributes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Lane > m_lanes_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_key_;
  int m_roadclass_;
  int m_roadtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// -------------------------------------------------------------------

class LocalMap :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MapLocationEhr.LocalMap) */ {
 public:
  LocalMap();
  virtual ~LocalMap();

  LocalMap(const LocalMap& from);
  LocalMap(LocalMap&& from) noexcept
    : LocalMap() {
    *this = ::std::move(from);
  }

  inline LocalMap& operator=(const LocalMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalMap& operator=(LocalMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LocalMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalMap* internal_default_instance() {
    return reinterpret_cast<const LocalMap*>(
               &_LocalMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LocalMap& a, LocalMap& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalMap* New() const final {
    return CreateMaybeMessage<LocalMap>(nullptr);
  }

  LocalMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LocalMap& from);
  void MergeFrom(const LocalMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LocalMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MapLocationEhr.LocalMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMRoadSectionsFieldNumber = 9,
    kMLineMapFieldNumber = 10,
    kMMapCenterFieldNumber = 4,
    kMDatumPointFieldNumber = 8,
    kMTimestampFieldNumber = 1,
    kMAgeFieldNumber = 2,
    kMCounterFieldNumber = 3,
    kMMapRangeFieldNumber = 5,
    kMLastTimestampFieldNumber = 7,
    kMHeadingFieldNumber = 6,
  };
  // repeated .MapLocationEhr.RoadSection m_roadSections = 9;
  int m_roadsections_size() const;
  void clear_m_roadsections();
  ::MapLocationEhr::RoadSection* mutable_m_roadsections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::RoadSection >*
      mutable_m_roadsections();
  const ::MapLocationEhr::RoadSection& m_roadsections(int index) const;
  ::MapLocationEhr::RoadSection* add_m_roadsections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::RoadSection >&
      m_roadsections() const;

  // repeated .MapLocationEhr.Line m_LineMap = 10;
  int m_linemap_size() const;
  void clear_m_linemap();
  ::MapLocationEhr::Line* mutable_m_linemap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Line >*
      mutable_m_linemap();
  const ::MapLocationEhr::Line& m_linemap(int index) const;
  ::MapLocationEhr::Line* add_m_linemap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Line >&
      m_linemap() const;

  // .MapLocationEhr.Coordinate m_mapCenter = 4;
  bool has_m_mapcenter() const;
  void clear_m_mapcenter();
  const ::MapLocationEhr::Coordinate& m_mapcenter() const;
  ::MapLocationEhr::Coordinate* release_m_mapcenter();
  ::MapLocationEhr::Coordinate* mutable_m_mapcenter();
  void set_allocated_m_mapcenter(::MapLocationEhr::Coordinate* m_mapcenter);

  // .MapLocationEhr.DatumPoint m_datumPoint = 8;
  bool has_m_datumpoint() const;
  void clear_m_datumpoint();
  const ::MapLocationEhr::DatumPoint& m_datumpoint() const;
  ::MapLocationEhr::DatumPoint* release_m_datumpoint();
  ::MapLocationEhr::DatumPoint* mutable_m_datumpoint();
  void set_allocated_m_datumpoint(::MapLocationEhr::DatumPoint* m_datumpoint);

  // uint64 m_timestamp = 1;
  void clear_m_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_timestamp() const;
  void set_m_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 m_age = 2;
  void clear_m_age();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_age() const;
  void set_m_age(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint32 m_counter = 3;
  void clear_m_counter();
  ::PROTOBUF_NAMESPACE_ID::uint32 m_counter() const;
  void set_m_counter(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // float m_mapRange = 5;
  void clear_m_maprange();
  float m_maprange() const;
  void set_m_maprange(float value);

  // uint64 m_lastTimestamp = 7;
  void clear_m_lasttimestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lasttimestamp() const;
  void set_m_lasttimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // float m_heading = 6;
  void clear_m_heading();
  float m_heading() const;
  void set_m_heading(float value);

  // @@protoc_insertion_point(class_scope:MapLocationEhr.LocalMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::RoadSection > m_roadsections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Line > m_linemap_;
  ::MapLocationEhr::Coordinate* m_mapcenter_;
  ::MapLocationEhr::DatumPoint* m_datumpoint_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_age_;
  ::PROTOBUF_NAMESPACE_ID::uint32 m_counter_;
  float m_maprange_;
  ::PROTOBUF_NAMESPACE_ID::uint64 m_lasttimestamp_;
  float m_heading_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MapLocationEhr_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Coordinate

// double m_x = 1;
inline void Coordinate::clear_m_x() {
  m_x_ = 0;
}
inline double Coordinate::m_x() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Coordinate.m_x)
  return m_x_;
}
inline void Coordinate::set_m_x(double value) {
  
  m_x_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Coordinate.m_x)
}

// double m_y = 2;
inline void Coordinate::clear_m_y() {
  m_y_ = 0;
}
inline double Coordinate::m_y() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Coordinate.m_y)
  return m_y_;
}
inline void Coordinate::set_m_y(double value) {
  
  m_y_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Coordinate.m_y)
}

// double m_z = 3;
inline void Coordinate::clear_m_z() {
  m_z_ = 0;
}
inline double Coordinate::m_z() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Coordinate.m_z)
  return m_z_;
}
inline void Coordinate::set_m_z(double value) {
  
  m_z_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Coordinate.m_z)
}

// -------------------------------------------------------------------

// Point

// double m_x = 1;
inline void Point::clear_m_x() {
  m_x_ = 0;
}
inline double Point::m_x() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Point.m_x)
  return m_x_;
}
inline void Point::set_m_x(double value) {
  
  m_x_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Point.m_x)
}

// double m_y = 2;
inline void Point::clear_m_y() {
  m_y_ = 0;
}
inline double Point::m_y() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Point.m_y)
  return m_y_;
}
inline void Point::set_m_y(double value) {
  
  m_y_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Point.m_y)
}

// double m_z = 3;
inline void Point::clear_m_z() {
  m_z_ = 0;
}
inline double Point::m_z() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Point.m_z)
  return m_z_;
}
inline void Point::set_m_z(double value) {
  
  m_z_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Point.m_z)
}

// -------------------------------------------------------------------

// DatumPoint

// uint64 m_datumTimestamp = 1;
inline void DatumPoint::clear_m_datumtimestamp() {
  m_datumtimestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DatumPoint::m_datumtimestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.DatumPoint.m_datumTimestamp)
  return m_datumtimestamp_;
}
inline void DatumPoint::set_m_datumtimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_datumtimestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.DatumPoint.m_datumTimestamp)
}

// .MapLocationEhr.Coordinate m_point = 2;
inline bool DatumPoint::has_m_point() const {
  return this != internal_default_instance() && m_point_ != nullptr;
}
inline void DatumPoint::clear_m_point() {
  if (GetArenaNoVirtual() == nullptr && m_point_ != nullptr) {
    delete m_point_;
  }
  m_point_ = nullptr;
}
inline const ::MapLocationEhr::Coordinate& DatumPoint::m_point() const {
  const ::MapLocationEhr::Coordinate* p = m_point_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.DatumPoint.m_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::Coordinate*>(
      &::MapLocationEhr::_Coordinate_default_instance_);
}
inline ::MapLocationEhr::Coordinate* DatumPoint::release_m_point() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.DatumPoint.m_point)
  
  ::MapLocationEhr::Coordinate* temp = m_point_;
  m_point_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::Coordinate* DatumPoint::mutable_m_point() {
  
  if (m_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::Coordinate>(GetArenaNoVirtual());
    m_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.DatumPoint.m_point)
  return m_point_;
}
inline void DatumPoint::set_allocated_m_point(::MapLocationEhr::Coordinate* m_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_point_;
  }
  if (m_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_point, submessage_arena);
    }
    
  } else {
    
  }
  m_point_ = m_point;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.DatumPoint.m_point)
}

// -------------------------------------------------------------------

// VehicleState_MatchInfo

// uint64 m_key = 1;
inline void VehicleState_MatchInfo::clear_m_key() {
  m_key_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VehicleState_MatchInfo::m_key() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.MatchInfo.m_key)
  return m_key_;
}
inline void VehicleState_MatchInfo::set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_key_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.MatchInfo.m_key)
}

// uint32 m_laneIndex = 2;
inline void VehicleState_MatchInfo::clear_m_laneindex() {
  m_laneindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VehicleState_MatchInfo::m_laneindex() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.MatchInfo.m_laneIndex)
  return m_laneindex_;
}
inline void VehicleState_MatchInfo::set_m_laneindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_laneindex_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.MatchInfo.m_laneIndex)
}

// -------------------------------------------------------------------

// VehicleState

// uint64 m_timestamp = 1;
inline void VehicleState::clear_m_timestamp() {
  m_timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VehicleState::m_timestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_timestamp)
  return m_timestamp_;
}
inline void VehicleState::set_m_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_timestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.m_timestamp)
}

// uint64 m_datumTimestamp = 2;
inline void VehicleState::clear_m_datumtimestamp() {
  m_datumtimestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VehicleState::m_datumtimestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_datumTimestamp)
  return m_datumtimestamp_;
}
inline void VehicleState::set_m_datumtimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_datumtimestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.m_datumTimestamp)
}

// uint64 m_lastTimestamp = 3;
inline void VehicleState::clear_m_lasttimestamp() {
  m_lasttimestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 VehicleState::m_lasttimestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_lastTimestamp)
  return m_lasttimestamp_;
}
inline void VehicleState::set_m_lasttimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_lasttimestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.m_lastTimestamp)
}

// .MapLocationEhr.Coordinate m_point = 4;
inline bool VehicleState::has_m_point() const {
  return this != internal_default_instance() && m_point_ != nullptr;
}
inline void VehicleState::clear_m_point() {
  if (GetArenaNoVirtual() == nullptr && m_point_ != nullptr) {
    delete m_point_;
  }
  m_point_ = nullptr;
}
inline const ::MapLocationEhr::Coordinate& VehicleState::m_point() const {
  const ::MapLocationEhr::Coordinate* p = m_point_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::Coordinate*>(
      &::MapLocationEhr::_Coordinate_default_instance_);
}
inline ::MapLocationEhr::Coordinate* VehicleState::release_m_point() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.VehicleState.m_point)
  
  ::MapLocationEhr::Coordinate* temp = m_point_;
  m_point_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::Coordinate* VehicleState::mutable_m_point() {
  
  if (m_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::Coordinate>(GetArenaNoVirtual());
    m_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.VehicleState.m_point)
  return m_point_;
}
inline void VehicleState::set_allocated_m_point(::MapLocationEhr::Coordinate* m_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_point_;
  }
  if (m_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_point, submessage_arena);
    }
    
  } else {
    
  }
  m_point_ = m_point;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.VehicleState.m_point)
}

// .MapLocationEhr.Coordinate m_relativeVehicle = 5;
inline bool VehicleState::has_m_relativevehicle() const {
  return this != internal_default_instance() && m_relativevehicle_ != nullptr;
}
inline void VehicleState::clear_m_relativevehicle() {
  if (GetArenaNoVirtual() == nullptr && m_relativevehicle_ != nullptr) {
    delete m_relativevehicle_;
  }
  m_relativevehicle_ = nullptr;
}
inline const ::MapLocationEhr::Coordinate& VehicleState::m_relativevehicle() const {
  const ::MapLocationEhr::Coordinate* p = m_relativevehicle_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_relativeVehicle)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::Coordinate*>(
      &::MapLocationEhr::_Coordinate_default_instance_);
}
inline ::MapLocationEhr::Coordinate* VehicleState::release_m_relativevehicle() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.VehicleState.m_relativeVehicle)
  
  ::MapLocationEhr::Coordinate* temp = m_relativevehicle_;
  m_relativevehicle_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::Coordinate* VehicleState::mutable_m_relativevehicle() {
  
  if (m_relativevehicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::Coordinate>(GetArenaNoVirtual());
    m_relativevehicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.VehicleState.m_relativeVehicle)
  return m_relativevehicle_;
}
inline void VehicleState::set_allocated_m_relativevehicle(::MapLocationEhr::Coordinate* m_relativevehicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_relativevehicle_;
  }
  if (m_relativevehicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_relativevehicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_relativevehicle, submessage_arena);
    }
    
  } else {
    
  }
  m_relativevehicle_ = m_relativevehicle;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.VehicleState.m_relativeVehicle)
}

// uint32 m_confidence = 6;
inline void VehicleState::clear_m_confidence() {
  m_confidence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VehicleState::m_confidence() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_confidence)
  return m_confidence_;
}
inline void VehicleState::set_m_confidence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_confidence_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.m_confidence)
}

// repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
inline int VehicleState::m_matches_size() const {
  return m_matches_.size();
}
inline void VehicleState::clear_m_matches() {
  m_matches_.Clear();
}
inline ::MapLocationEhr::VehicleState_MatchInfo* VehicleState::mutable_m_matches(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.VehicleState.m_matches)
  return m_matches_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::VehicleState_MatchInfo >*
VehicleState::mutable_m_matches() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.VehicleState.m_matches)
  return &m_matches_;
}
inline const ::MapLocationEhr::VehicleState_MatchInfo& VehicleState::m_matches(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_matches)
  return m_matches_.Get(index);
}
inline ::MapLocationEhr::VehicleState_MatchInfo* VehicleState::add_m_matches() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.VehicleState.m_matches)
  return m_matches_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::VehicleState_MatchInfo >&
VehicleState::m_matches() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.VehicleState.m_matches)
  return m_matches_;
}

// float m_heading = 8;
inline void VehicleState::clear_m_heading() {
  m_heading_ = 0;
}
inline float VehicleState::m_heading() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.VehicleState.m_heading)
  return m_heading_;
}
inline void VehicleState::set_m_heading(float value) {
  
  m_heading_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.VehicleState.m_heading)
}

// -------------------------------------------------------------------

// Waypoint

// .MapLocationEhr.Coordinate m_coordinate = 1;
inline bool Waypoint::has_m_coordinate() const {
  return this != internal_default_instance() && m_coordinate_ != nullptr;
}
inline void Waypoint::clear_m_coordinate() {
  if (GetArenaNoVirtual() == nullptr && m_coordinate_ != nullptr) {
    delete m_coordinate_;
  }
  m_coordinate_ = nullptr;
}
inline const ::MapLocationEhr::Coordinate& Waypoint::m_coordinate() const {
  const ::MapLocationEhr::Coordinate* p = m_coordinate_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_coordinate)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::Coordinate*>(
      &::MapLocationEhr::_Coordinate_default_instance_);
}
inline ::MapLocationEhr::Coordinate* Waypoint::release_m_coordinate() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.Waypoint.m_coordinate)
  
  ::MapLocationEhr::Coordinate* temp = m_coordinate_;
  m_coordinate_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::Coordinate* Waypoint::mutable_m_coordinate() {
  
  if (m_coordinate_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::Coordinate>(GetArenaNoVirtual());
    m_coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.Waypoint.m_coordinate)
  return m_coordinate_;
}
inline void Waypoint::set_allocated_m_coordinate(::MapLocationEhr::Coordinate* m_coordinate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_coordinate_;
  }
  if (m_coordinate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_coordinate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_coordinate, submessage_arena);
    }
    
  } else {
    
  }
  m_coordinate_ = m_coordinate;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.Waypoint.m_coordinate)
}

// int32 m_heading = 2;
inline void Waypoint::clear_m_heading() {
  m_heading_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Waypoint::m_heading() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_heading)
  return m_heading_;
}
inline void Waypoint::set_m_heading(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  m_heading_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Waypoint.m_heading)
}

// int32 m_curvature = 3;
inline void Waypoint::clear_m_curvature() {
  m_curvature_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Waypoint::m_curvature() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_curvature)
  return m_curvature_;
}
inline void Waypoint::set_m_curvature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  m_curvature_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Waypoint.m_curvature)
}

// int32 m_slope = 4;
inline void Waypoint::clear_m_slope() {
  m_slope_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Waypoint::m_slope() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_slope)
  return m_slope_;
}
inline void Waypoint::set_m_slope(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  m_slope_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Waypoint.m_slope)
}

// int32 m_crossSlope = 5;
inline void Waypoint::clear_m_crossslope() {
  m_crossslope_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Waypoint::m_crossslope() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_crossSlope)
  return m_crossslope_;
}
inline void Waypoint::set_m_crossslope(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  m_crossslope_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Waypoint.m_crossSlope)
}

// uint32 m_width = 6;
inline void Waypoint::clear_m_width() {
  m_width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Waypoint::m_width() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Waypoint.m_width)
  return m_width_;
}
inline void Waypoint::set_m_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_width_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Waypoint.m_width)
}

// -------------------------------------------------------------------

// Lane

// uint64 m_key = 1;
inline void Lane::clear_m_key() {
  m_key_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lane::m_key() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Lane.m_key)
  return m_key_;
}
inline void Lane::set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_key_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Lane.m_key)
}

// uint32 m_laneIndex = 2;
inline void Lane::clear_m_laneindex() {
  m_laneindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lane::m_laneindex() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Lane.m_laneIndex)
  return m_laneindex_;
}
inline void Lane::set_m_laneindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_laneindex_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Lane.m_laneIndex)
}

// uint32 m_length = 3;
inline void Lane::clear_m_length() {
  m_length_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Lane::m_length() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Lane.m_length)
  return m_length_;
}
inline void Lane::set_m_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_length_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Lane.m_length)
}

// repeated .MapLocationEhr.Waypoint m_waypoints = 4;
inline int Lane::m_waypoints_size() const {
  return m_waypoints_.size();
}
inline void Lane::clear_m_waypoints() {
  m_waypoints_.Clear();
}
inline ::MapLocationEhr::Waypoint* Lane::mutable_m_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.Lane.m_waypoints)
  return m_waypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Waypoint >*
Lane::mutable_m_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.Lane.m_waypoints)
  return &m_waypoints_;
}
inline const ::MapLocationEhr::Waypoint& Lane::m_waypoints(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Lane.m_waypoints)
  return m_waypoints_.Get(index);
}
inline ::MapLocationEhr::Waypoint* Lane::add_m_waypoints() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.Lane.m_waypoints)
  return m_waypoints_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Waypoint >&
Lane::m_waypoints() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.Lane.m_waypoints)
  return m_waypoints_;
}

// -------------------------------------------------------------------

// Line

// uint64 m_LineID = 1;
inline void Line::clear_m_lineid() {
  m_lineid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Line::m_lineid() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Line.m_LineID)
  return m_lineid_;
}
inline void Line::set_m_lineid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_lineid_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Line.m_LineID)
}

// uint32 m_LaneLineIndex = 2;
inline void Line::clear_m_lanelineindex() {
  m_lanelineindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Line::m_lanelineindex() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Line.m_LaneLineIndex)
  return m_lanelineindex_;
}
inline void Line::set_m_lanelineindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_lanelineindex_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Line.m_LaneLineIndex)
}

// uint32 m_ElementSequence = 3;
inline void Line::clear_m_elementsequence() {
  m_elementsequence_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Line::m_elementsequence() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Line.m_ElementSequence)
  return m_elementsequence_;
}
inline void Line::set_m_elementsequence(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_elementsequence_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.Line.m_ElementSequence)
}

// repeated .MapLocationEhr.Point m_Points = 4;
inline int Line::m_points_size() const {
  return m_points_.size();
}
inline void Line::clear_m_points() {
  m_points_.Clear();
}
inline ::MapLocationEhr::Point* Line::mutable_m_points(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.Line.m_Points)
  return m_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Point >*
Line::mutable_m_points() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.Line.m_Points)
  return &m_points_;
}
inline const ::MapLocationEhr::Point& Line::m_points(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.Line.m_Points)
  return m_points_.Get(index);
}
inline ::MapLocationEhr::Point* Line::add_m_points() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.Line.m_Points)
  return m_points_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Point >&
Line::m_points() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.Line.m_Points)
  return m_points_;
}

// -------------------------------------------------------------------

// RoadSection

// uint64 m_key = 1;
inline void RoadSection::clear_m_key() {
  m_key_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RoadSection::m_key() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.RoadSection.m_key)
  return m_key_;
}
inline void RoadSection::set_m_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_key_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.RoadSection.m_key)
}

// .MapLocationEhr.RoadClass m_roadClass = 2;
inline void RoadSection::clear_m_roadclass() {
  m_roadclass_ = 0;
}
inline ::MapLocationEhr::RoadClass RoadSection::m_roadclass() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.RoadSection.m_roadClass)
  return static_cast< ::MapLocationEhr::RoadClass >(m_roadclass_);
}
inline void RoadSection::set_m_roadclass(::MapLocationEhr::RoadClass value) {
  
  m_roadclass_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.RoadSection.m_roadClass)
}

// .MapLocationEhr.RoadType m_roadType = 3;
inline void RoadSection::clear_m_roadtype() {
  m_roadtype_ = 0;
}
inline ::MapLocationEhr::RoadType RoadSection::m_roadtype() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.RoadSection.m_roadType)
  return static_cast< ::MapLocationEhr::RoadType >(m_roadtype_);
}
inline void RoadSection::set_m_roadtype(::MapLocationEhr::RoadType value) {
  
  m_roadtype_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.RoadSection.m_roadType)
}

// repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
inline int RoadSection::m_attributes_size() const {
  return m_attributes_.size();
}
inline void RoadSection::clear_m_attributes() {
  m_attributes_.Clear();
}
inline ::MapLocationEhr::RoadAttribute RoadSection::m_attributes(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.RoadSection.m_attributes)
  return static_cast< ::MapLocationEhr::RoadAttribute >(m_attributes_.Get(index));
}
inline void RoadSection::set_m_attributes(int index, ::MapLocationEhr::RoadAttribute value) {
  m_attributes_.Set(index, value);
  // @@protoc_insertion_point(field_set:MapLocationEhr.RoadSection.m_attributes)
}
inline void RoadSection::add_m_attributes(::MapLocationEhr::RoadAttribute value) {
  m_attributes_.Add(value);
  // @@protoc_insertion_point(field_add:MapLocationEhr.RoadSection.m_attributes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
RoadSection::m_attributes() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.RoadSection.m_attributes)
  return m_attributes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
RoadSection::mutable_m_attributes() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.RoadSection.m_attributes)
  return &m_attributes_;
}

// repeated .MapLocationEhr.Lane m_lanes = 5;
inline int RoadSection::m_lanes_size() const {
  return m_lanes_.size();
}
inline void RoadSection::clear_m_lanes() {
  m_lanes_.Clear();
}
inline ::MapLocationEhr::Lane* RoadSection::mutable_m_lanes(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.RoadSection.m_lanes)
  return m_lanes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Lane >*
RoadSection::mutable_m_lanes() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.RoadSection.m_lanes)
  return &m_lanes_;
}
inline const ::MapLocationEhr::Lane& RoadSection::m_lanes(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.RoadSection.m_lanes)
  return m_lanes_.Get(index);
}
inline ::MapLocationEhr::Lane* RoadSection::add_m_lanes() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.RoadSection.m_lanes)
  return m_lanes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Lane >&
RoadSection::m_lanes() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.RoadSection.m_lanes)
  return m_lanes_;
}

// -------------------------------------------------------------------

// LocalMap

// uint64 m_timestamp = 1;
inline void LocalMap::clear_m_timestamp() {
  m_timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocalMap::m_timestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_timestamp)
  return m_timestamp_;
}
inline void LocalMap::set_m_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_timestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_timestamp)
}

// uint64 m_age = 2;
inline void LocalMap::clear_m_age() {
  m_age_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocalMap::m_age() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_age)
  return m_age_;
}
inline void LocalMap::set_m_age(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_age_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_age)
}

// uint32 m_counter = 3;
inline void LocalMap::clear_m_counter() {
  m_counter_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LocalMap::m_counter() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_counter)
  return m_counter_;
}
inline void LocalMap::set_m_counter(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  m_counter_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_counter)
}

// .MapLocationEhr.Coordinate m_mapCenter = 4;
inline bool LocalMap::has_m_mapcenter() const {
  return this != internal_default_instance() && m_mapcenter_ != nullptr;
}
inline void LocalMap::clear_m_mapcenter() {
  if (GetArenaNoVirtual() == nullptr && m_mapcenter_ != nullptr) {
    delete m_mapcenter_;
  }
  m_mapcenter_ = nullptr;
}
inline const ::MapLocationEhr::Coordinate& LocalMap::m_mapcenter() const {
  const ::MapLocationEhr::Coordinate* p = m_mapcenter_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_mapCenter)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::Coordinate*>(
      &::MapLocationEhr::_Coordinate_default_instance_);
}
inline ::MapLocationEhr::Coordinate* LocalMap::release_m_mapcenter() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.LocalMap.m_mapCenter)
  
  ::MapLocationEhr::Coordinate* temp = m_mapcenter_;
  m_mapcenter_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::Coordinate* LocalMap::mutable_m_mapcenter() {
  
  if (m_mapcenter_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::Coordinate>(GetArenaNoVirtual());
    m_mapcenter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.LocalMap.m_mapCenter)
  return m_mapcenter_;
}
inline void LocalMap::set_allocated_m_mapcenter(::MapLocationEhr::Coordinate* m_mapcenter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_mapcenter_;
  }
  if (m_mapcenter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_mapcenter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_mapcenter, submessage_arena);
    }
    
  } else {
    
  }
  m_mapcenter_ = m_mapcenter;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.LocalMap.m_mapCenter)
}

// float m_mapRange = 5;
inline void LocalMap::clear_m_maprange() {
  m_maprange_ = 0;
}
inline float LocalMap::m_maprange() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_mapRange)
  return m_maprange_;
}
inline void LocalMap::set_m_maprange(float value) {
  
  m_maprange_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_mapRange)
}

// float m_heading = 6;
inline void LocalMap::clear_m_heading() {
  m_heading_ = 0;
}
inline float LocalMap::m_heading() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_heading)
  return m_heading_;
}
inline void LocalMap::set_m_heading(float value) {
  
  m_heading_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_heading)
}

// uint64 m_lastTimestamp = 7;
inline void LocalMap::clear_m_lasttimestamp() {
  m_lasttimestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LocalMap::m_lasttimestamp() const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_lastTimestamp)
  return m_lasttimestamp_;
}
inline void LocalMap::set_m_lasttimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  m_lasttimestamp_ = value;
  // @@protoc_insertion_point(field_set:MapLocationEhr.LocalMap.m_lastTimestamp)
}

// .MapLocationEhr.DatumPoint m_datumPoint = 8;
inline bool LocalMap::has_m_datumpoint() const {
  return this != internal_default_instance() && m_datumpoint_ != nullptr;
}
inline void LocalMap::clear_m_datumpoint() {
  if (GetArenaNoVirtual() == nullptr && m_datumpoint_ != nullptr) {
    delete m_datumpoint_;
  }
  m_datumpoint_ = nullptr;
}
inline const ::MapLocationEhr::DatumPoint& LocalMap::m_datumpoint() const {
  const ::MapLocationEhr::DatumPoint* p = m_datumpoint_;
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_datumPoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::MapLocationEhr::DatumPoint*>(
      &::MapLocationEhr::_DatumPoint_default_instance_);
}
inline ::MapLocationEhr::DatumPoint* LocalMap::release_m_datumpoint() {
  // @@protoc_insertion_point(field_release:MapLocationEhr.LocalMap.m_datumPoint)
  
  ::MapLocationEhr::DatumPoint* temp = m_datumpoint_;
  m_datumpoint_ = nullptr;
  return temp;
}
inline ::MapLocationEhr::DatumPoint* LocalMap::mutable_m_datumpoint() {
  
  if (m_datumpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::MapLocationEhr::DatumPoint>(GetArenaNoVirtual());
    m_datumpoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.LocalMap.m_datumPoint)
  return m_datumpoint_;
}
inline void LocalMap::set_allocated_m_datumpoint(::MapLocationEhr::DatumPoint* m_datumpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete m_datumpoint_;
  }
  if (m_datumpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      m_datumpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_datumpoint, submessage_arena);
    }
    
  } else {
    
  }
  m_datumpoint_ = m_datumpoint;
  // @@protoc_insertion_point(field_set_allocated:MapLocationEhr.LocalMap.m_datumPoint)
}

// repeated .MapLocationEhr.RoadSection m_roadSections = 9;
inline int LocalMap::m_roadsections_size() const {
  return m_roadsections_.size();
}
inline void LocalMap::clear_m_roadsections() {
  m_roadsections_.Clear();
}
inline ::MapLocationEhr::RoadSection* LocalMap::mutable_m_roadsections(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.LocalMap.m_roadSections)
  return m_roadsections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::RoadSection >*
LocalMap::mutable_m_roadsections() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.LocalMap.m_roadSections)
  return &m_roadsections_;
}
inline const ::MapLocationEhr::RoadSection& LocalMap::m_roadsections(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_roadSections)
  return m_roadsections_.Get(index);
}
inline ::MapLocationEhr::RoadSection* LocalMap::add_m_roadsections() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.LocalMap.m_roadSections)
  return m_roadsections_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::RoadSection >&
LocalMap::m_roadsections() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.LocalMap.m_roadSections)
  return m_roadsections_;
}

// repeated .MapLocationEhr.Line m_LineMap = 10;
inline int LocalMap::m_linemap_size() const {
  return m_linemap_.size();
}
inline void LocalMap::clear_m_linemap() {
  m_linemap_.Clear();
}
inline ::MapLocationEhr::Line* LocalMap::mutable_m_linemap(int index) {
  // @@protoc_insertion_point(field_mutable:MapLocationEhr.LocalMap.m_LineMap)
  return m_linemap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Line >*
LocalMap::mutable_m_linemap() {
  // @@protoc_insertion_point(field_mutable_list:MapLocationEhr.LocalMap.m_LineMap)
  return &m_linemap_;
}
inline const ::MapLocationEhr::Line& LocalMap::m_linemap(int index) const {
  // @@protoc_insertion_point(field_get:MapLocationEhr.LocalMap.m_LineMap)
  return m_linemap_.Get(index);
}
inline ::MapLocationEhr::Line* LocalMap::add_m_linemap() {
  // @@protoc_insertion_point(field_add:MapLocationEhr.LocalMap.m_LineMap)
  return m_linemap_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::MapLocationEhr::Line >&
LocalMap::m_linemap() const {
  // @@protoc_insertion_point(field_list:MapLocationEhr.LocalMap.m_LineMap)
  return m_linemap_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MapLocationEhr

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MapLocationEhr::RoadClass> : ::std::true_type {};
template <> struct is_proto_enum< ::MapLocationEhr::RoadType> : ::std::true_type {};
template <> struct is_proto_enum< ::MapLocationEhr::RoadAttribute> : ::std::true_type {};
template <> struct is_proto_enum< ::MapLocationEhr::ZLevelType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MapLocationEhr_2eproto
