// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapLocationEhr.proto

#include "MapLocationEhr.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Coordinate_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DatumPoint_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Lane_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Line_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RoadSection_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_MapLocationEhr_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Waypoint_MapLocationEhr_2eproto;
namespace MapLocationEhr {
class CoordinateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Coordinate> _instance;
} _Coordinate_default_instance_;
class PointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Point> _instance;
} _Point_default_instance_;
class DatumPointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DatumPoint> _instance;
} _DatumPoint_default_instance_;
class VehicleState_MatchInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VehicleState_MatchInfo> _instance;
} _VehicleState_MatchInfo_default_instance_;
class VehicleStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VehicleState> _instance;
} _VehicleState_default_instance_;
class WaypointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Waypoint> _instance;
} _Waypoint_default_instance_;
class LaneDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Lane> _instance;
} _Lane_default_instance_;
class LineDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Line> _instance;
} _Line_default_instance_;
class RoadSectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RoadSection> _instance;
} _RoadSection_default_instance_;
class LocalMapDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LocalMap> _instance;
} _LocalMap_default_instance_;
}  // namespace MapLocationEhr
static void InitDefaultsscc_info_Coordinate_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_Coordinate_default_instance_;
    new (ptr) ::MapLocationEhr::Coordinate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::Coordinate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Coordinate_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Coordinate_MapLocationEhr_2eproto}, {}};

static void InitDefaultsscc_info_DatumPoint_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_DatumPoint_default_instance_;
    new (ptr) ::MapLocationEhr::DatumPoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::DatumPoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_DatumPoint_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_DatumPoint_MapLocationEhr_2eproto}, {
      &scc_info_Coordinate_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_Lane_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_Lane_default_instance_;
    new (ptr) ::MapLocationEhr::Lane();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::Lane::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Lane_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Lane_MapLocationEhr_2eproto}, {
      &scc_info_Waypoint_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_Line_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_Line_default_instance_;
    new (ptr) ::MapLocationEhr::Line();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::Line::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Line_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Line_MapLocationEhr_2eproto}, {
      &scc_info_Point_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_LocalMap_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_LocalMap_default_instance_;
    new (ptr) ::MapLocationEhr::LocalMap();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::LocalMap::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_LocalMap_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_LocalMap_MapLocationEhr_2eproto}, {
      &scc_info_Coordinate_MapLocationEhr_2eproto.base,
      &scc_info_DatumPoint_MapLocationEhr_2eproto.base,
      &scc_info_RoadSection_MapLocationEhr_2eproto.base,
      &scc_info_Line_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_Point_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_Point_default_instance_;
    new (ptr) ::MapLocationEhr::Point();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::Point::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Point_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_Point_MapLocationEhr_2eproto}, {}};

static void InitDefaultsscc_info_RoadSection_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_RoadSection_default_instance_;
    new (ptr) ::MapLocationEhr::RoadSection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::RoadSection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RoadSection_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RoadSection_MapLocationEhr_2eproto}, {
      &scc_info_Lane_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_VehicleState_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_VehicleState_default_instance_;
    new (ptr) ::MapLocationEhr::VehicleState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::VehicleState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_VehicleState_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_VehicleState_MapLocationEhr_2eproto}, {
      &scc_info_Coordinate_MapLocationEhr_2eproto.base,
      &scc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto.base,}};

static void InitDefaultsscc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_VehicleState_MatchInfo_default_instance_;
    new (ptr) ::MapLocationEhr::VehicleState_MatchInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::VehicleState_MatchInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto}, {}};

static void InitDefaultsscc_info_Waypoint_MapLocationEhr_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::MapLocationEhr::_Waypoint_default_instance_;
    new (ptr) ::MapLocationEhr::Waypoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::MapLocationEhr::Waypoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Waypoint_MapLocationEhr_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Waypoint_MapLocationEhr_2eproto}, {
      &scc_info_Coordinate_MapLocationEhr_2eproto.base,}};

namespace MapLocationEhr {
bool RoadClass_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoadClass_strings[8] = {};

static const char RoadClass_names[] =
  "CountyRoad"
  "NarrowRoad"
  "NationalRoad"
  "OrdinaryRoad"
  "ProvincialRoad"
  "Unknown"
  "UrbanHighway"
  "UrbanSealedRoad";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoadClass_entries[] = {
  { {RoadClass_names + 0, 10}, 5 },
  { {RoadClass_names + 10, 10}, 7 },
  { {RoadClass_names + 20, 12}, 3 },
  { {RoadClass_names + 32, 12}, 6 },
  { {RoadClass_names + 44, 14}, 4 },
  { {RoadClass_names + 58, 7}, 0 },
  { {RoadClass_names + 65, 12}, 1 },
  { {RoadClass_names + 77, 15}, 2 },
};

static const int RoadClass_entries_by_number[] = {
  5, // 0 -> Unknown
  6, // 1 -> UrbanHighway
  7, // 2 -> UrbanSealedRoad
  2, // 3 -> NationalRoad
  4, // 4 -> ProvincialRoad
  0, // 5 -> CountyRoad
  3, // 6 -> OrdinaryRoad
  1, // 7 -> NarrowRoad
};

const std::string& RoadClass_Name(
    RoadClass value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoadClass_entries,
          RoadClass_entries_by_number,
          8, RoadClass_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoadClass_entries,
      RoadClass_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoadClass_strings[idx].get();
}
bool RoadClass_Parse(
    const std::string& name, RoadClass* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoadClass_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<RoadClass>(int_value);
  }
  return success;
}
bool RoadType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoadType_strings[13] = {};

static const char RoadType_names[] =
  "Boundary"
  "MainRoad"
  "NoSpecial"
  "Parallel"
  "Pedestrian"
  "PedestrianZone"
  "Ramp"
  "Roundabout"
  "RoundaboutInterior"
  "ServiceRoad"
  "SlipRoad"
  "SpecialTrafficFigure"
  "Square";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoadType_entries[] = {
  { {RoadType_names + 0, 8}, 12 },
  { {RoadType_names + 8, 8}, 5 },
  { {RoadType_names + 16, 9}, 0 },
  { {RoadType_names + 25, 8}, 3 },
  { {RoadType_names + 33, 10}, 8 },
  { {RoadType_names + 43, 14}, 7 },
  { {RoadType_names + 57, 4}, 1 },
  { {RoadType_names + 61, 10}, 2 },
  { {RoadType_names + 71, 18}, 9 },
  { {RoadType_names + 89, 11}, 4 },
  { {RoadType_names + 100, 8}, 10 },
  { {RoadType_names + 108, 20}, 11 },
  { {RoadType_names + 128, 6}, 6 },
};

static const int RoadType_entries_by_number[] = {
  2, // 0 -> NoSpecial
  6, // 1 -> Ramp
  7, // 2 -> Roundabout
  3, // 3 -> Parallel
  9, // 4 -> ServiceRoad
  1, // 5 -> MainRoad
  12, // 6 -> Square
  5, // 7 -> PedestrianZone
  4, // 8 -> Pedestrian
  8, // 9 -> RoundaboutInterior
  10, // 10 -> SlipRoad
  11, // 11 -> SpecialTrafficFigure
  0, // 12 -> Boundary
};

const std::string& RoadType_Name(
    RoadType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoadType_entries,
          RoadType_entries_by_number,
          13, RoadType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoadType_entries,
      RoadType_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoadType_strings[idx].get();
}
bool RoadType_Parse(
    const std::string& name, RoadType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoadType_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<RoadType>(int_value);
  }
  return success;
}
bool RoadAttribute_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoadAttribute_strings[13] = {};

static const char RoadAttribute_names[] =
  "Bridge"
  "ComplexIntersection"
  "ControlAccess"
  "Elevated"
  "Motorway"
  "Parking"
  "PluralJunction"
  "ServiceArea"
  "Toll"
  "Tunnel"
  "UTurn"
  "UnderConstruction"
  "Underpass";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoadAttribute_entries[] = {
  { {RoadAttribute_names + 0, 6}, 24 },
  { {RoadAttribute_names + 6, 19}, 9 },
  { {RoadAttribute_names + 25, 13}, 0 },
  { {RoadAttribute_names + 38, 8}, 3 },
  { {RoadAttribute_names + 46, 8}, 6 },
  { {RoadAttribute_names + 54, 7}, 2 },
  { {RoadAttribute_names + 61, 14}, 10 },
  { {RoadAttribute_names + 75, 11}, 7 },
  { {RoadAttribute_names + 86, 4}, 8 },
  { {RoadAttribute_names + 90, 6}, 25 },
  { {RoadAttribute_names + 96, 5}, 1 },
  { {RoadAttribute_names + 101, 17}, 5 },
  { {RoadAttribute_names + 118, 9}, 4 },
};

static const int RoadAttribute_entries_by_number[] = {
  2, // 0 -> ControlAccess
  10, // 1 -> UTurn
  5, // 2 -> Parking
  3, // 3 -> Elevated
  12, // 4 -> Underpass
  11, // 5 -> UnderConstruction
  4, // 6 -> Motorway
  7, // 7 -> ServiceArea
  8, // 8 -> Toll
  1, // 9 -> ComplexIntersection
  6, // 10 -> PluralJunction
  0, // 24 -> Bridge
  9, // 25 -> Tunnel
};

const std::string& RoadAttribute_Name(
    RoadAttribute value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RoadAttribute_entries,
          RoadAttribute_entries_by_number,
          13, RoadAttribute_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RoadAttribute_entries,
      RoadAttribute_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RoadAttribute_strings[idx].get();
}
bool RoadAttribute_Parse(
    const std::string& name, RoadAttribute* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RoadAttribute_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<RoadAttribute>(int_value);
  }
  return success;
}
bool ZLevelType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ZLevelType_strings[5] = {};

static const char ZLevelType_names[] =
  "ConnectOverground"
  "ConnectUnderground"
  "Invalid"
  "Overground"
  "Underground";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ZLevelType_entries[] = {
  { {ZLevelType_names + 0, 17}, 2 },
  { {ZLevelType_names + 17, 18}, 4 },
  { {ZLevelType_names + 35, 7}, 0 },
  { {ZLevelType_names + 42, 10}, 1 },
  { {ZLevelType_names + 52, 11}, 3 },
};

static const int ZLevelType_entries_by_number[] = {
  2, // 0 -> Invalid
  3, // 1 -> Overground
  0, // 2 -> ConnectOverground
  4, // 3 -> Underground
  1, // 4 -> ConnectUnderground
};

const std::string& ZLevelType_Name(
    ZLevelType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ZLevelType_entries,
          ZLevelType_entries_by_number,
          5, ZLevelType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ZLevelType_entries,
      ZLevelType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ZLevelType_strings[idx].get();
}
bool ZLevelType_Parse(
    const std::string& name, ZLevelType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ZLevelType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ZLevelType>(int_value);
  }
  return success;
}

// ===================================================================

void Coordinate::InitAsDefaultInstance() {
}
class Coordinate::_Internal {
 public:
};

Coordinate::Coordinate()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.Coordinate)
}
Coordinate::Coordinate(const Coordinate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_x_, &from.m_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_z_) -
    reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.Coordinate)
}

void Coordinate::SharedCtor() {
  ::memset(&m_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_z_) -
      reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
}

Coordinate::~Coordinate() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.Coordinate)
  SharedDtor();
}

void Coordinate::SharedDtor() {
}

void Coordinate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Coordinate& Coordinate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Coordinate_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void Coordinate::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.Coordinate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&m_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_z_) -
      reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Coordinate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // double m_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          m_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double m_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          m_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double m_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          m_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Coordinate::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.Coordinate)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double m_x = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (9 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double m_y = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double m_z = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (25 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.Coordinate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.Coordinate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Coordinate::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.Coordinate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double m_x = 1;
  if (!(this->m_x() <= 0 && this->m_x() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(1, this->m_x(), output);
  }

  // double m_y = 2;
  if (!(this->m_y() <= 0 && this->m_y() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(2, this->m_y(), output);
  }

  // double m_z = 3;
  if (!(this->m_z() <= 0 && this->m_z() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(3, this->m_z(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.Coordinate)
}

size_t Coordinate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.Coordinate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double m_x = 1;
  if (!(this->m_x() <= 0 && this->m_x() >= 0)) {
    total_size += 1 + 8;
  }

  // double m_y = 2;
  if (!(this->m_y() <= 0 && this->m_y() >= 0)) {
    total_size += 1 + 8;
  }

  // double m_z = 3;
  if (!(this->m_z() <= 0 && this->m_z() >= 0)) {
    total_size += 1 + 8;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Coordinate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Coordinate*>(
      &from));
}

void Coordinate::MergeFrom(const Coordinate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.Coordinate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.m_x() <= 0 && from.m_x() >= 0)) {
    set_m_x(from.m_x());
  }
  if (!(from.m_y() <= 0 && from.m_y() >= 0)) {
    set_m_y(from.m_y());
  }
  if (!(from.m_z() <= 0 && from.m_z() >= 0)) {
    set_m_z(from.m_z());
  }
}

void Coordinate::CopyFrom(const Coordinate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.Coordinate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Coordinate::IsInitialized() const {
  return true;
}

void Coordinate::InternalSwap(Coordinate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(m_x_, other->m_x_);
  swap(m_y_, other->m_y_);
  swap(m_z_, other->m_z_);
}

std::string Coordinate::GetTypeName() const {
  return "MapLocationEhr.Coordinate";
}


// ===================================================================

void Point::InitAsDefaultInstance() {
}
class Point::_Internal {
 public:
};

Point::Point()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.Point)
}
Point::Point(const Point& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_x_, &from.m_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_z_) -
    reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.Point)
}

void Point::SharedCtor() {
  ::memset(&m_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_z_) -
      reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.Point)
  SharedDtor();
}

void Point::SharedDtor() {
}

void Point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Point& Point::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Point_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&m_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_z_) -
      reinterpret_cast<char*>(&m_x_)) + sizeof(m_z_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Point::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // double m_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          m_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double m_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          m_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double m_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          m_z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Point::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.Point)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // double m_x = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (9 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double m_y = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (17 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // double m_z = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (25 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   double, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &m_z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.Point)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Point::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.Point)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double m_x = 1;
  if (!(this->m_x() <= 0 && this->m_x() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(1, this->m_x(), output);
  }

  // double m_y = 2;
  if (!(this->m_y() <= 0 && this->m_y() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(2, this->m_y(), output);
  }

  // double m_z = 3;
  if (!(this->m_z() <= 0 && this->m_z() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDouble(3, this->m_z(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.Point)
}

size_t Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.Point)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double m_x = 1;
  if (!(this->m_x() <= 0 && this->m_x() >= 0)) {
    total_size += 1 + 8;
  }

  // double m_y = 2;
  if (!(this->m_y() <= 0 && this->m_y() >= 0)) {
    total_size += 1 + 8;
  }

  // double m_z = 3;
  if (!(this->m_z() <= 0 && this->m_z() >= 0)) {
    total_size += 1 + 8;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Point::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Point*>(
      &from));
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.Point)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.m_x() <= 0 && from.m_x() >= 0)) {
    set_m_x(from.m_x());
  }
  if (!(from.m_y() <= 0 && from.m_y() >= 0)) {
    set_m_y(from.m_y());
  }
  if (!(from.m_z() <= 0 && from.m_z() >= 0)) {
    set_m_z(from.m_z());
  }
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {
  return true;
}

void Point::InternalSwap(Point* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(m_x_, other->m_x_);
  swap(m_y_, other->m_y_);
  swap(m_z_, other->m_z_);
}

std::string Point::GetTypeName() const {
  return "MapLocationEhr.Point";
}


// ===================================================================

void DatumPoint::InitAsDefaultInstance() {
  ::MapLocationEhr::_DatumPoint_default_instance_._instance.get_mutable()->m_point_ = const_cast< ::MapLocationEhr::Coordinate*>(
      ::MapLocationEhr::Coordinate::internal_default_instance());
}
class DatumPoint::_Internal {
 public:
  static const ::MapLocationEhr::Coordinate& m_point(const DatumPoint* msg);
};

const ::MapLocationEhr::Coordinate&
DatumPoint::_Internal::m_point(const DatumPoint* msg) {
  return *msg->m_point_;
}
DatumPoint::DatumPoint()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.DatumPoint)
}
DatumPoint::DatumPoint(const DatumPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_m_point()) {
    m_point_ = new ::MapLocationEhr::Coordinate(*from.m_point_);
  } else {
    m_point_ = nullptr;
  }
  m_datumtimestamp_ = from.m_datumtimestamp_;
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.DatumPoint)
}

void DatumPoint::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_DatumPoint_MapLocationEhr_2eproto.base);
  ::memset(&m_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_datumtimestamp_) -
      reinterpret_cast<char*>(&m_point_)) + sizeof(m_datumtimestamp_));
}

DatumPoint::~DatumPoint() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.DatumPoint)
  SharedDtor();
}

void DatumPoint::SharedDtor() {
  if (this != internal_default_instance()) delete m_point_;
}

void DatumPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DatumPoint& DatumPoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_DatumPoint_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void DatumPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.DatumPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && m_point_ != nullptr) {
    delete m_point_;
  }
  m_point_ = nullptr;
  m_datumtimestamp_ = PROTOBUF_ULONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DatumPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_datumTimestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_datumtimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.Coordinate m_point = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_m_point(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DatumPoint::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.DatumPoint)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_datumTimestamp = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_datumtimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.Coordinate m_point = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.DatumPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.DatumPoint)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DatumPoint::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.DatumPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_datumTimestamp = 1;
  if (this->m_datumtimestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_datumtimestamp(), output);
  }

  // .MapLocationEhr.Coordinate m_point = 2;
  if (this->has_m_point()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      2, _Internal::m_point(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.DatumPoint)
}

size_t DatumPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.DatumPoint)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .MapLocationEhr.Coordinate m_point = 2;
  if (this->has_m_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_point_);
  }

  // uint64 m_datumTimestamp = 1;
  if (this->m_datumtimestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_datumtimestamp());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DatumPoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DatumPoint*>(
      &from));
}

void DatumPoint::MergeFrom(const DatumPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.DatumPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_m_point()) {
    mutable_m_point()->::MapLocationEhr::Coordinate::MergeFrom(from.m_point());
  }
  if (from.m_datumtimestamp() != 0) {
    set_m_datumtimestamp(from.m_datumtimestamp());
  }
}

void DatumPoint::CopyFrom(const DatumPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.DatumPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatumPoint::IsInitialized() const {
  return true;
}

void DatumPoint::InternalSwap(DatumPoint* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(m_point_, other->m_point_);
  swap(m_datumtimestamp_, other->m_datumtimestamp_);
}

std::string DatumPoint::GetTypeName() const {
  return "MapLocationEhr.DatumPoint";
}


// ===================================================================

void VehicleState_MatchInfo::InitAsDefaultInstance() {
}
class VehicleState_MatchInfo::_Internal {
 public:
};

VehicleState_MatchInfo::VehicleState_MatchInfo()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.VehicleState.MatchInfo)
}
VehicleState_MatchInfo::VehicleState_MatchInfo(const VehicleState_MatchInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_key_, &from.m_key_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_laneindex_) -
    reinterpret_cast<char*>(&m_key_)) + sizeof(m_laneindex_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.VehicleState.MatchInfo)
}

void VehicleState_MatchInfo::SharedCtor() {
  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_laneindex_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_laneindex_));
}

VehicleState_MatchInfo::~VehicleState_MatchInfo() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.VehicleState.MatchInfo)
  SharedDtor();
}

void VehicleState_MatchInfo::SharedDtor() {
}

void VehicleState_MatchInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VehicleState_MatchInfo& VehicleState_MatchInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VehicleState_MatchInfo_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void VehicleState_MatchInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.VehicleState.MatchInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_laneindex_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_laneindex_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VehicleState_MatchInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_laneIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_laneindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VehicleState_MatchInfo::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.VehicleState.MatchInfo)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_key = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_key_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_laneIndex = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_laneindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.VehicleState.MatchInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.VehicleState.MatchInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VehicleState_MatchInfo::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.VehicleState.MatchInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_key(), output);
  }

  // uint32 m_laneIndex = 2;
  if (this->m_laneindex() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->m_laneindex(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.VehicleState.MatchInfo)
}

size_t VehicleState_MatchInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.VehicleState.MatchInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_key());
  }

  // uint32 m_laneIndex = 2;
  if (this->m_laneindex() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_laneindex());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VehicleState_MatchInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VehicleState_MatchInfo*>(
      &from));
}

void VehicleState_MatchInfo::MergeFrom(const VehicleState_MatchInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.VehicleState.MatchInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.m_key() != 0) {
    set_m_key(from.m_key());
  }
  if (from.m_laneindex() != 0) {
    set_m_laneindex(from.m_laneindex());
  }
}

void VehicleState_MatchInfo::CopyFrom(const VehicleState_MatchInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.VehicleState.MatchInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleState_MatchInfo::IsInitialized() const {
  return true;
}

void VehicleState_MatchInfo::InternalSwap(VehicleState_MatchInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(m_key_, other->m_key_);
  swap(m_laneindex_, other->m_laneindex_);
}

std::string VehicleState_MatchInfo::GetTypeName() const {
  return "MapLocationEhr.VehicleState.MatchInfo";
}


// ===================================================================

void VehicleState::InitAsDefaultInstance() {
  ::MapLocationEhr::_VehicleState_default_instance_._instance.get_mutable()->m_point_ = const_cast< ::MapLocationEhr::Coordinate*>(
      ::MapLocationEhr::Coordinate::internal_default_instance());
  ::MapLocationEhr::_VehicleState_default_instance_._instance.get_mutable()->m_relativevehicle_ = const_cast< ::MapLocationEhr::Coordinate*>(
      ::MapLocationEhr::Coordinate::internal_default_instance());
}
class VehicleState::_Internal {
 public:
  static const ::MapLocationEhr::Coordinate& m_point(const VehicleState* msg);
  static const ::MapLocationEhr::Coordinate& m_relativevehicle(const VehicleState* msg);
};

const ::MapLocationEhr::Coordinate&
VehicleState::_Internal::m_point(const VehicleState* msg) {
  return *msg->m_point_;
}
const ::MapLocationEhr::Coordinate&
VehicleState::_Internal::m_relativevehicle(const VehicleState* msg) {
  return *msg->m_relativevehicle_;
}
VehicleState::VehicleState()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.VehicleState)
}
VehicleState::VehicleState(const VehicleState& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      m_matches_(from.m_matches_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_m_point()) {
    m_point_ = new ::MapLocationEhr::Coordinate(*from.m_point_);
  } else {
    m_point_ = nullptr;
  }
  if (from.has_m_relativevehicle()) {
    m_relativevehicle_ = new ::MapLocationEhr::Coordinate(*from.m_relativevehicle_);
  } else {
    m_relativevehicle_ = nullptr;
  }
  ::memcpy(&m_timestamp_, &from.m_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_heading_) -
    reinterpret_cast<char*>(&m_timestamp_)) + sizeof(m_heading_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.VehicleState)
}

void VehicleState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_VehicleState_MapLocationEhr_2eproto.base);
  ::memset(&m_point_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_heading_) -
      reinterpret_cast<char*>(&m_point_)) + sizeof(m_heading_));
}

VehicleState::~VehicleState() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.VehicleState)
  SharedDtor();
}

void VehicleState::SharedDtor() {
  if (this != internal_default_instance()) delete m_point_;
  if (this != internal_default_instance()) delete m_relativevehicle_;
}

void VehicleState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VehicleState& VehicleState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_VehicleState_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void VehicleState::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.VehicleState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  m_matches_.Clear();
  if (GetArenaNoVirtual() == nullptr && m_point_ != nullptr) {
    delete m_point_;
  }
  m_point_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && m_relativevehicle_ != nullptr) {
    delete m_relativevehicle_;
  }
  m_relativevehicle_ = nullptr;
  ::memset(&m_timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_heading_) -
      reinterpret_cast<char*>(&m_timestamp_)) + sizeof(m_heading_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VehicleState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 m_datumTimestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_datumtimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 m_lastTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          m_lasttimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.Coordinate m_point = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_m_point(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.Coordinate m_relativeVehicle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_m_relativevehicle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_confidence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          m_confidence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_matches(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 58);
        } else goto handle_unusual;
        continue;
      // float m_heading = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          m_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VehicleState::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.VehicleState)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_timestamp = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 m_datumTimestamp = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_datumtimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 m_lastTimestamp = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_lasttimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.Coordinate m_point = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_point()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.Coordinate m_relativeVehicle = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_relativevehicle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_confidence = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_confidence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_matches()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float m_heading = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (69 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.VehicleState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.VehicleState)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VehicleState::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.VehicleState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_timestamp = 1;
  if (this->m_timestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_timestamp(), output);
  }

  // uint64 m_datumTimestamp = 2;
  if (this->m_datumtimestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->m_datumtimestamp(), output);
  }

  // uint64 m_lastTimestamp = 3;
  if (this->m_lasttimestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->m_lasttimestamp(), output);
  }

  // .MapLocationEhr.Coordinate m_point = 4;
  if (this->has_m_point()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::m_point(this), output);
  }

  // .MapLocationEhr.Coordinate m_relativeVehicle = 5;
  if (this->has_m_relativevehicle()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5, _Internal::m_relativevehicle(this), output);
  }

  // uint32 m_confidence = 6;
  if (this->m_confidence() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->m_confidence(), output);
  }

  // repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_matches_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      7,
      this->m_matches(static_cast<int>(i)),
      output);
  }

  // float m_heading = 8;
  if (!(this->m_heading() <= 0 && this->m_heading() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(8, this->m_heading(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.VehicleState)
}

size_t VehicleState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.VehicleState)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MapLocationEhr.VehicleState.MatchInfo m_matches = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->m_matches_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_matches(static_cast<int>(i)));
    }
  }

  // .MapLocationEhr.Coordinate m_point = 4;
  if (this->has_m_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_point_);
  }

  // .MapLocationEhr.Coordinate m_relativeVehicle = 5;
  if (this->has_m_relativevehicle()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_relativevehicle_);
  }

  // uint64 m_timestamp = 1;
  if (this->m_timestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_timestamp());
  }

  // uint64 m_datumTimestamp = 2;
  if (this->m_datumtimestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_datumtimestamp());
  }

  // uint64 m_lastTimestamp = 3;
  if (this->m_lasttimestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_lasttimestamp());
  }

  // uint32 m_confidence = 6;
  if (this->m_confidence() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_confidence());
  }

  // float m_heading = 8;
  if (!(this->m_heading() <= 0 && this->m_heading() >= 0)) {
    total_size += 1 + 4;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VehicleState::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const VehicleState*>(
      &from));
}

void VehicleState::MergeFrom(const VehicleState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.VehicleState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  m_matches_.MergeFrom(from.m_matches_);
  if (from.has_m_point()) {
    mutable_m_point()->::MapLocationEhr::Coordinate::MergeFrom(from.m_point());
  }
  if (from.has_m_relativevehicle()) {
    mutable_m_relativevehicle()->::MapLocationEhr::Coordinate::MergeFrom(from.m_relativevehicle());
  }
  if (from.m_timestamp() != 0) {
    set_m_timestamp(from.m_timestamp());
  }
  if (from.m_datumtimestamp() != 0) {
    set_m_datumtimestamp(from.m_datumtimestamp());
  }
  if (from.m_lasttimestamp() != 0) {
    set_m_lasttimestamp(from.m_lasttimestamp());
  }
  if (from.m_confidence() != 0) {
    set_m_confidence(from.m_confidence());
  }
  if (!(from.m_heading() <= 0 && from.m_heading() >= 0)) {
    set_m_heading(from.m_heading());
  }
}

void VehicleState::CopyFrom(const VehicleState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.VehicleState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleState::IsInitialized() const {
  return true;
}

void VehicleState::InternalSwap(VehicleState* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&m_matches_)->InternalSwap(CastToBase(&other->m_matches_));
  swap(m_point_, other->m_point_);
  swap(m_relativevehicle_, other->m_relativevehicle_);
  swap(m_timestamp_, other->m_timestamp_);
  swap(m_datumtimestamp_, other->m_datumtimestamp_);
  swap(m_lasttimestamp_, other->m_lasttimestamp_);
  swap(m_confidence_, other->m_confidence_);
  swap(m_heading_, other->m_heading_);
}

std::string VehicleState::GetTypeName() const {
  return "MapLocationEhr.VehicleState";
}


// ===================================================================

void Waypoint::InitAsDefaultInstance() {
  ::MapLocationEhr::_Waypoint_default_instance_._instance.get_mutable()->m_coordinate_ = const_cast< ::MapLocationEhr::Coordinate*>(
      ::MapLocationEhr::Coordinate::internal_default_instance());
}
class Waypoint::_Internal {
 public:
  static const ::MapLocationEhr::Coordinate& m_coordinate(const Waypoint* msg);
};

const ::MapLocationEhr::Coordinate&
Waypoint::_Internal::m_coordinate(const Waypoint* msg) {
  return *msg->m_coordinate_;
}
Waypoint::Waypoint()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.Waypoint)
}
Waypoint::Waypoint(const Waypoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_m_coordinate()) {
    m_coordinate_ = new ::MapLocationEhr::Coordinate(*from.m_coordinate_);
  } else {
    m_coordinate_ = nullptr;
  }
  ::memcpy(&m_heading_, &from.m_heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_width_) -
    reinterpret_cast<char*>(&m_heading_)) + sizeof(m_width_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.Waypoint)
}

void Waypoint::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Waypoint_MapLocationEhr_2eproto.base);
  ::memset(&m_coordinate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_width_) -
      reinterpret_cast<char*>(&m_coordinate_)) + sizeof(m_width_));
}

Waypoint::~Waypoint() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.Waypoint)
  SharedDtor();
}

void Waypoint::SharedDtor() {
  if (this != internal_default_instance()) delete m_coordinate_;
}

void Waypoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Waypoint& Waypoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Waypoint_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void Waypoint::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.Waypoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && m_coordinate_ != nullptr) {
    delete m_coordinate_;
  }
  m_coordinate_ = nullptr;
  ::memset(&m_heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_width_) -
      reinterpret_cast<char*>(&m_heading_)) + sizeof(m_width_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Waypoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .MapLocationEhr.Coordinate m_coordinate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_m_coordinate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 m_heading = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 m_curvature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          m_curvature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 m_slope = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          m_slope_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 m_crossSlope = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          m_crossslope_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          m_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Waypoint::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.Waypoint)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .MapLocationEhr.Coordinate m_coordinate = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_coordinate()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 m_heading = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &m_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 m_curvature = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &m_curvature_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 m_slope = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &m_slope_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 m_crossSlope = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::int32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32>(
                 input, &m_crossslope_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_width = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_width_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.Waypoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.Waypoint)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Waypoint::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.Waypoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .MapLocationEhr.Coordinate m_coordinate = 1;
  if (this->has_m_coordinate()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      1, _Internal::m_coordinate(this), output);
  }

  // int32 m_heading = 2;
  if (this->m_heading() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(2, this->m_heading(), output);
  }

  // int32 m_curvature = 3;
  if (this->m_curvature() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(3, this->m_curvature(), output);
  }

  // int32 m_slope = 4;
  if (this->m_slope() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(4, this->m_slope(), output);
  }

  // int32 m_crossSlope = 5;
  if (this->m_crossslope() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32(5, this->m_crossslope(), output);
  }

  // uint32 m_width = 6;
  if (this->m_width() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(6, this->m_width(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.Waypoint)
}

size_t Waypoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.Waypoint)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .MapLocationEhr.Coordinate m_coordinate = 1;
  if (this->has_m_coordinate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_coordinate_);
  }

  // int32 m_heading = 2;
  if (this->m_heading() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->m_heading());
  }

  // int32 m_curvature = 3;
  if (this->m_curvature() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->m_curvature());
  }

  // int32 m_slope = 4;
  if (this->m_slope() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->m_slope());
  }

  // int32 m_crossSlope = 5;
  if (this->m_crossslope() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->m_crossslope());
  }

  // uint32 m_width = 6;
  if (this->m_width() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_width());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Waypoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Waypoint*>(
      &from));
}

void Waypoint::MergeFrom(const Waypoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.Waypoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_m_coordinate()) {
    mutable_m_coordinate()->::MapLocationEhr::Coordinate::MergeFrom(from.m_coordinate());
  }
  if (from.m_heading() != 0) {
    set_m_heading(from.m_heading());
  }
  if (from.m_curvature() != 0) {
    set_m_curvature(from.m_curvature());
  }
  if (from.m_slope() != 0) {
    set_m_slope(from.m_slope());
  }
  if (from.m_crossslope() != 0) {
    set_m_crossslope(from.m_crossslope());
  }
  if (from.m_width() != 0) {
    set_m_width(from.m_width());
  }
}

void Waypoint::CopyFrom(const Waypoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.Waypoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Waypoint::IsInitialized() const {
  return true;
}

void Waypoint::InternalSwap(Waypoint* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(m_coordinate_, other->m_coordinate_);
  swap(m_heading_, other->m_heading_);
  swap(m_curvature_, other->m_curvature_);
  swap(m_slope_, other->m_slope_);
  swap(m_crossslope_, other->m_crossslope_);
  swap(m_width_, other->m_width_);
}

std::string Waypoint::GetTypeName() const {
  return "MapLocationEhr.Waypoint";
}


// ===================================================================

void Lane::InitAsDefaultInstance() {
}
class Lane::_Internal {
 public:
};

Lane::Lane()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.Lane)
}
Lane::Lane(const Lane& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      m_waypoints_(from.m_waypoints_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_key_, &from.m_key_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_length_) -
    reinterpret_cast<char*>(&m_key_)) + sizeof(m_length_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.Lane)
}

void Lane::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Lane_MapLocationEhr_2eproto.base);
  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_length_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_length_));
}

Lane::~Lane() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.Lane)
  SharedDtor();
}

void Lane::SharedDtor() {
}

void Lane::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Lane& Lane::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Lane_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void Lane::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.Lane)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  m_waypoints_.Clear();
  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_length_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_length_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Lane::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_laneIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_laneindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          m_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.Waypoint m_waypoints = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_waypoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Lane::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.Lane)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_key = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_key_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_laneIndex = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_laneindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_length = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.Waypoint m_waypoints = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_waypoints()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.Lane)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.Lane)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Lane::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.Lane)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_key(), output);
  }

  // uint32 m_laneIndex = 2;
  if (this->m_laneindex() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->m_laneindex(), output);
  }

  // uint32 m_length = 3;
  if (this->m_length() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->m_length(), output);
  }

  // repeated .MapLocationEhr.Waypoint m_waypoints = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_waypoints_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->m_waypoints(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.Lane)
}

size_t Lane::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.Lane)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MapLocationEhr.Waypoint m_waypoints = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->m_waypoints_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_waypoints(static_cast<int>(i)));
    }
  }

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_key());
  }

  // uint32 m_laneIndex = 2;
  if (this->m_laneindex() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_laneindex());
  }

  // uint32 m_length = 3;
  if (this->m_length() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_length());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Lane::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Lane*>(
      &from));
}

void Lane::MergeFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.Lane)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  m_waypoints_.MergeFrom(from.m_waypoints_);
  if (from.m_key() != 0) {
    set_m_key(from.m_key());
  }
  if (from.m_laneindex() != 0) {
    set_m_laneindex(from.m_laneindex());
  }
  if (from.m_length() != 0) {
    set_m_length(from.m_length());
  }
}

void Lane::CopyFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.Lane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane::IsInitialized() const {
  return true;
}

void Lane::InternalSwap(Lane* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&m_waypoints_)->InternalSwap(CastToBase(&other->m_waypoints_));
  swap(m_key_, other->m_key_);
  swap(m_laneindex_, other->m_laneindex_);
  swap(m_length_, other->m_length_);
}

std::string Lane::GetTypeName() const {
  return "MapLocationEhr.Lane";
}


// ===================================================================

void Line::InitAsDefaultInstance() {
}
class Line::_Internal {
 public:
};

Line::Line()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.Line)
}
Line::Line(const Line& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      m_points_(from.m_points_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_lineid_, &from.m_lineid_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_elementsequence_) -
    reinterpret_cast<char*>(&m_lineid_)) + sizeof(m_elementsequence_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.Line)
}

void Line::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Line_MapLocationEhr_2eproto.base);
  ::memset(&m_lineid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_elementsequence_) -
      reinterpret_cast<char*>(&m_lineid_)) + sizeof(m_elementsequence_));
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.Line)
  SharedDtor();
}

void Line::SharedDtor() {
}

void Line::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Line& Line::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Line_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void Line::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.Line)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  m_points_.Clear();
  ::memset(&m_lineid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_elementsequence_) -
      reinterpret_cast<char*>(&m_lineid_)) + sizeof(m_elementsequence_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Line::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_LineID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_lineid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_LaneLineIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_lanelineindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_ElementSequence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          m_elementsequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.Point m_Points = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Line::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.Line)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_LineID = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_lineid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_LaneLineIndex = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_lanelineindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_ElementSequence = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_elementsequence_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.Point m_Points = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_points()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.Line)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.Line)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Line::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.Line)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_LineID = 1;
  if (this->m_lineid() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_lineid(), output);
  }

  // uint32 m_LaneLineIndex = 2;
  if (this->m_lanelineindex() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->m_lanelineindex(), output);
  }

  // uint32 m_ElementSequence = 3;
  if (this->m_elementsequence() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->m_elementsequence(), output);
  }

  // repeated .MapLocationEhr.Point m_Points = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_points_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4,
      this->m_points(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.Line)
}

size_t Line::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.Line)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MapLocationEhr.Point m_Points = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->m_points_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_points(static_cast<int>(i)));
    }
  }

  // uint64 m_LineID = 1;
  if (this->m_lineid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_lineid());
  }

  // uint32 m_LaneLineIndex = 2;
  if (this->m_lanelineindex() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_lanelineindex());
  }

  // uint32 m_ElementSequence = 3;
  if (this->m_elementsequence() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_elementsequence());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Line::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const Line*>(
      &from));
}

void Line::MergeFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.Line)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  m_points_.MergeFrom(from.m_points_);
  if (from.m_lineid() != 0) {
    set_m_lineid(from.m_lineid());
  }
  if (from.m_lanelineindex() != 0) {
    set_m_lanelineindex(from.m_lanelineindex());
  }
  if (from.m_elementsequence() != 0) {
    set_m_elementsequence(from.m_elementsequence());
  }
}

void Line::CopyFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.Line)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  return true;
}

void Line::InternalSwap(Line* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&m_points_)->InternalSwap(CastToBase(&other->m_points_));
  swap(m_lineid_, other->m_lineid_);
  swap(m_lanelineindex_, other->m_lanelineindex_);
  swap(m_elementsequence_, other->m_elementsequence_);
}

std::string Line::GetTypeName() const {
  return "MapLocationEhr.Line";
}


// ===================================================================

void RoadSection::InitAsDefaultInstance() {
}
class RoadSection::_Internal {
 public:
};

RoadSection::RoadSection()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.RoadSection)
}
RoadSection::RoadSection(const RoadSection& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      m_attributes_(from.m_attributes_),
      m_lanes_(from.m_lanes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&m_key_, &from.m_key_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_roadtype_) -
    reinterpret_cast<char*>(&m_key_)) + sizeof(m_roadtype_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.RoadSection)
}

void RoadSection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RoadSection_MapLocationEhr_2eproto.base);
  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_roadtype_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_roadtype_));
}

RoadSection::~RoadSection() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.RoadSection)
  SharedDtor();
}

void RoadSection::SharedDtor() {
}

void RoadSection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RoadSection& RoadSection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RoadSection_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void RoadSection::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.RoadSection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  m_attributes_.Clear();
  m_lanes_.Clear();
  ::memset(&m_key_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_roadtype_) -
      reinterpret_cast<char*>(&m_key_)) + sizeof(m_roadtype_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RoadSection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.RoadClass m_roadClass = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          set_m_roadclass(static_cast<::MapLocationEhr::RoadClass>(val));
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.RoadType m_roadType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          set_m_roadtype(static_cast<::MapLocationEhr::RoadType>(val));
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_m_attributes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          add_m_attributes(static_cast<::MapLocationEhr::RoadAttribute>(val));
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.Lane m_lanes = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_lanes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 42);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RoadSection::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.RoadSection)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_key = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_key_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.RoadClass m_roadClass = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_m_roadclass(static_cast< ::MapLocationEhr::RoadClass >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.RoadType m_roadType = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_m_roadtype(static_cast< ::MapLocationEhr::RoadType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          ::PROTOBUF_NAMESPACE_ID::uint32 length;
          DO_(input->ReadVarint32(&length));
          ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream::Limit limit = input->PushLimit(static_cast<int>(length));
          while (input->BytesUntilLimit() > 0) {
            int value = 0;
            DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
            add_m_attributes(static_cast< ::MapLocationEhr::RoadAttribute >(value));
          }
          input->PopLimit(limit);
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          add_m_attributes(static_cast< ::MapLocationEhr::RoadAttribute >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.Lane m_lanes = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_lanes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.RoadSection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.RoadSection)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RoadSection::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.RoadSection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_key(), output);
  }

  // .MapLocationEhr.RoadClass m_roadClass = 2;
  if (this->m_roadclass() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->m_roadclass(), output);
  }

  // .MapLocationEhr.RoadType m_roadType = 3;
  if (this->m_roadtype() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->m_roadtype(), output);
  }

  // repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
  if (this->m_attributes_size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteTag(
      4,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      output);
    output->WriteVarint32(_m_attributes_cached_byte_size_.load(
        std::memory_order_relaxed));
  }
  for (int i = 0, n = this->m_attributes_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumNoTag(
      this->m_attributes(i), output);
  }

  // repeated .MapLocationEhr.Lane m_lanes = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_lanes_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      5,
      this->m_lanes(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.RoadSection)
}

size_t RoadSection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.RoadSection)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MapLocationEhr.RoadAttribute m_attributes = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->m_attributes_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->m_attributes(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _m_attributes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .MapLocationEhr.Lane m_lanes = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->m_lanes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_lanes(static_cast<int>(i)));
    }
  }

  // uint64 m_key = 1;
  if (this->m_key() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_key());
  }

  // .MapLocationEhr.RoadClass m_roadClass = 2;
  if (this->m_roadclass() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->m_roadclass());
  }

  // .MapLocationEhr.RoadType m_roadType = 3;
  if (this->m_roadtype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->m_roadtype());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RoadSection::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RoadSection*>(
      &from));
}

void RoadSection::MergeFrom(const RoadSection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.RoadSection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  m_attributes_.MergeFrom(from.m_attributes_);
  m_lanes_.MergeFrom(from.m_lanes_);
  if (from.m_key() != 0) {
    set_m_key(from.m_key());
  }
  if (from.m_roadclass() != 0) {
    set_m_roadclass(from.m_roadclass());
  }
  if (from.m_roadtype() != 0) {
    set_m_roadtype(from.m_roadtype());
  }
}

void RoadSection::CopyFrom(const RoadSection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.RoadSection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoadSection::IsInitialized() const {
  return true;
}

void RoadSection::InternalSwap(RoadSection* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  m_attributes_.InternalSwap(&other->m_attributes_);
  CastToBase(&m_lanes_)->InternalSwap(CastToBase(&other->m_lanes_));
  swap(m_key_, other->m_key_);
  swap(m_roadclass_, other->m_roadclass_);
  swap(m_roadtype_, other->m_roadtype_);
}

std::string RoadSection::GetTypeName() const {
  return "MapLocationEhr.RoadSection";
}


// ===================================================================

void LocalMap::InitAsDefaultInstance() {
  ::MapLocationEhr::_LocalMap_default_instance_._instance.get_mutable()->m_mapcenter_ = const_cast< ::MapLocationEhr::Coordinate*>(
      ::MapLocationEhr::Coordinate::internal_default_instance());
  ::MapLocationEhr::_LocalMap_default_instance_._instance.get_mutable()->m_datumpoint_ = const_cast< ::MapLocationEhr::DatumPoint*>(
      ::MapLocationEhr::DatumPoint::internal_default_instance());
}
class LocalMap::_Internal {
 public:
  static const ::MapLocationEhr::Coordinate& m_mapcenter(const LocalMap* msg);
  static const ::MapLocationEhr::DatumPoint& m_datumpoint(const LocalMap* msg);
};

const ::MapLocationEhr::Coordinate&
LocalMap::_Internal::m_mapcenter(const LocalMap* msg) {
  return *msg->m_mapcenter_;
}
const ::MapLocationEhr::DatumPoint&
LocalMap::_Internal::m_datumpoint(const LocalMap* msg) {
  return *msg->m_datumpoint_;
}
LocalMap::LocalMap()
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapLocationEhr.LocalMap)
}
LocalMap::LocalMap(const LocalMap& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _internal_metadata_(nullptr),
      m_roadsections_(from.m_roadsections_),
      m_linemap_(from.m_linemap_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_m_mapcenter()) {
    m_mapcenter_ = new ::MapLocationEhr::Coordinate(*from.m_mapcenter_);
  } else {
    m_mapcenter_ = nullptr;
  }
  if (from.has_m_datumpoint()) {
    m_datumpoint_ = new ::MapLocationEhr::DatumPoint(*from.m_datumpoint_);
  } else {
    m_datumpoint_ = nullptr;
  }
  ::memcpy(&m_timestamp_, &from.m_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&m_heading_) -
    reinterpret_cast<char*>(&m_timestamp_)) + sizeof(m_heading_));
  // @@protoc_insertion_point(copy_constructor:MapLocationEhr.LocalMap)
}

void LocalMap::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LocalMap_MapLocationEhr_2eproto.base);
  ::memset(&m_mapcenter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_heading_) -
      reinterpret_cast<char*>(&m_mapcenter_)) + sizeof(m_heading_));
}

LocalMap::~LocalMap() {
  // @@protoc_insertion_point(destructor:MapLocationEhr.LocalMap)
  SharedDtor();
}

void LocalMap::SharedDtor() {
  if (this != internal_default_instance()) delete m_mapcenter_;
  if (this != internal_default_instance()) delete m_datumpoint_;
}

void LocalMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LocalMap& LocalMap::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LocalMap_MapLocationEhr_2eproto.base);
  return *internal_default_instance();
}


void LocalMap::Clear() {
// @@protoc_insertion_point(message_clear_start:MapLocationEhr.LocalMap)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  m_roadsections_.Clear();
  m_linemap_.Clear();
  if (GetArenaNoVirtual() == nullptr && m_mapcenter_ != nullptr) {
    delete m_mapcenter_;
  }
  m_mapcenter_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && m_datumpoint_ != nullptr) {
    delete m_datumpoint_;
  }
  m_datumpoint_ = nullptr;
  ::memset(&m_timestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&m_heading_) -
      reinterpret_cast<char*>(&m_timestamp_)) + sizeof(m_heading_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LocalMap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint64 m_timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          m_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 m_age = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          m_age_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 m_counter = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          m_counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.Coordinate m_mapCenter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_m_mapcenter(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float m_mapRange = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          m_maprange_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float m_heading = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          m_heading_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // uint64 m_lastTimestamp = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          m_lasttimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .MapLocationEhr.DatumPoint m_datumPoint = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_m_datumpoint(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.RoadSection m_roadSections = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_roadsections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 74);
        } else goto handle_unusual;
        continue;
      // repeated .MapLocationEhr.Line m_LineMap = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_m_linemap(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 82);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LocalMap::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  ::PROTOBUF_NAMESPACE_ID::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:MapLocationEhr.LocalMap)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint64 m_timestamp = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 m_age = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_age_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 m_counter = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.Coordinate m_mapCenter = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_mapcenter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float m_mapRange = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (45 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_maprange_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float m_heading = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (53 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint64 m_lastTimestamp = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (56 & 0xFF)) {

          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &m_lasttimestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .MapLocationEhr.DatumPoint m_datumPoint = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_m_datumpoint()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.RoadSection m_roadSections = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_roadsections()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .MapLocationEhr.Line m_LineMap = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_m_linemap()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapLocationEhr.LocalMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapLocationEhr.LocalMap)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LocalMap::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapLocationEhr.LocalMap)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 m_timestamp = 1;
  if (this->m_timestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->m_timestamp(), output);
  }

  // uint64 m_age = 2;
  if (this->m_age() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->m_age(), output);
  }

  // uint32 m_counter = 3;
  if (this->m_counter() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->m_counter(), output);
  }

  // .MapLocationEhr.Coordinate m_mapCenter = 4;
  if (this->has_m_mapcenter()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      4, _Internal::m_mapcenter(this), output);
  }

  // float m_mapRange = 5;
  if (!(this->m_maprange() <= 0 && this->m_maprange() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(5, this->m_maprange(), output);
  }

  // float m_heading = 6;
  if (!(this->m_heading() <= 0 && this->m_heading() >= 0)) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(6, this->m_heading(), output);
  }

  // uint64 m_lastTimestamp = 7;
  if (this->m_lasttimestamp() != 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(7, this->m_lasttimestamp(), output);
  }

  // .MapLocationEhr.DatumPoint m_datumPoint = 8;
  if (this->has_m_datumpoint()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      8, _Internal::m_datumpoint(this), output);
  }

  // repeated .MapLocationEhr.RoadSection m_roadSections = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_roadsections_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      9,
      this->m_roadsections(static_cast<int>(i)),
      output);
  }

  // repeated .MapLocationEhr.Line m_LineMap = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->m_linemap_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessage(
      10,
      this->m_linemap(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:MapLocationEhr.LocalMap)
}

size_t LocalMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:MapLocationEhr.LocalMap)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .MapLocationEhr.RoadSection m_roadSections = 9;
  {
    unsigned int count = static_cast<unsigned int>(this->m_roadsections_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_roadsections(static_cast<int>(i)));
    }
  }

  // repeated .MapLocationEhr.Line m_LineMap = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->m_linemap_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->m_linemap(static_cast<int>(i)));
    }
  }

  // .MapLocationEhr.Coordinate m_mapCenter = 4;
  if (this->has_m_mapcenter()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_mapcenter_);
  }

  // .MapLocationEhr.DatumPoint m_datumPoint = 8;
  if (this->has_m_datumpoint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *m_datumpoint_);
  }

  // uint64 m_timestamp = 1;
  if (this->m_timestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_timestamp());
  }

  // uint64 m_age = 2;
  if (this->m_age() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_age());
  }

  // uint32 m_counter = 3;
  if (this->m_counter() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->m_counter());
  }

  // float m_mapRange = 5;
  if (!(this->m_maprange() <= 0 && this->m_maprange() >= 0)) {
    total_size += 1 + 4;
  }

  // uint64 m_lastTimestamp = 7;
  if (this->m_lasttimestamp() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->m_lasttimestamp());
  }

  // float m_heading = 6;
  if (!(this->m_heading() <= 0 && this->m_heading() >= 0)) {
    total_size += 1 + 4;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocalMap::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LocalMap*>(
      &from));
}

void LocalMap::MergeFrom(const LocalMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapLocationEhr.LocalMap)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  m_roadsections_.MergeFrom(from.m_roadsections_);
  m_linemap_.MergeFrom(from.m_linemap_);
  if (from.has_m_mapcenter()) {
    mutable_m_mapcenter()->::MapLocationEhr::Coordinate::MergeFrom(from.m_mapcenter());
  }
  if (from.has_m_datumpoint()) {
    mutable_m_datumpoint()->::MapLocationEhr::DatumPoint::MergeFrom(from.m_datumpoint());
  }
  if (from.m_timestamp() != 0) {
    set_m_timestamp(from.m_timestamp());
  }
  if (from.m_age() != 0) {
    set_m_age(from.m_age());
  }
  if (from.m_counter() != 0) {
    set_m_counter(from.m_counter());
  }
  if (!(from.m_maprange() <= 0 && from.m_maprange() >= 0)) {
    set_m_maprange(from.m_maprange());
  }
  if (from.m_lasttimestamp() != 0) {
    set_m_lasttimestamp(from.m_lasttimestamp());
  }
  if (!(from.m_heading() <= 0 && from.m_heading() >= 0)) {
    set_m_heading(from.m_heading());
  }
}

void LocalMap::CopyFrom(const LocalMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapLocationEhr.LocalMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalMap::IsInitialized() const {
  return true;
}

void LocalMap::InternalSwap(LocalMap* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&m_roadsections_)->InternalSwap(CastToBase(&other->m_roadsections_));
  CastToBase(&m_linemap_)->InternalSwap(CastToBase(&other->m_linemap_));
  swap(m_mapcenter_, other->m_mapcenter_);
  swap(m_datumpoint_, other->m_datumpoint_);
  swap(m_timestamp_, other->m_timestamp_);
  swap(m_age_, other->m_age_);
  swap(m_counter_, other->m_counter_);
  swap(m_maprange_, other->m_maprange_);
  swap(m_lasttimestamp_, other->m_lasttimestamp_);
  swap(m_heading_, other->m_heading_);
}

std::string LocalMap::GetTypeName() const {
  return "MapLocationEhr.LocalMap";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace MapLocationEhr
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::MapLocationEhr::Coordinate* Arena::CreateMaybeMessage< ::MapLocationEhr::Coordinate >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::Coordinate >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::Point* Arena::CreateMaybeMessage< ::MapLocationEhr::Point >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::Point >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::DatumPoint* Arena::CreateMaybeMessage< ::MapLocationEhr::DatumPoint >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::DatumPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::VehicleState_MatchInfo* Arena::CreateMaybeMessage< ::MapLocationEhr::VehicleState_MatchInfo >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::VehicleState_MatchInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::VehicleState* Arena::CreateMaybeMessage< ::MapLocationEhr::VehicleState >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::VehicleState >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::Waypoint* Arena::CreateMaybeMessage< ::MapLocationEhr::Waypoint >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::Waypoint >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::Lane* Arena::CreateMaybeMessage< ::MapLocationEhr::Lane >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::Lane >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::Line* Arena::CreateMaybeMessage< ::MapLocationEhr::Line >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::Line >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::RoadSection* Arena::CreateMaybeMessage< ::MapLocationEhr::RoadSection >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::RoadSection >(arena);
}
template<> PROTOBUF_NOINLINE ::MapLocationEhr::LocalMap* Arena::CreateMaybeMessage< ::MapLocationEhr::LocalMap >(Arena* arena) {
  return Arena::CreateInternal< ::MapLocationEhr::LocalMap >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
