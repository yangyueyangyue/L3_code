/** @copyright Copyright (c) 2018-2021 Kotei Technology Co., Ltd.
 ******************************************************************************
 * @file       lateral_control_pid.c
 * @brief      横向控制算法(PID)
 * @details    实现横向控制算法(PID)
 *
 * @author     pengc
 * @date       2021.07.28
 * @version    v1.0
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 *
 ******************************************************************************/

/******************************************************************************/
/* 头文件                                                                      */
/******************************************************************************/
#include "lateral_control_pid_c.h"

#include "utils/log_c.h"
#include "utils/com_utils_c.h"
#include "utils/com_clock_c.h"
#include "utils/linear_interpolation_c.h"
#include "utils/com_filter_c.h"
#include "math/math_utils_c.h"
#include "math/fft_c.h"
#include "vehicle_model_c.h"


/******************************************************************************/
/* 宏定义                                                                      */
/******************************************************************************/
#define ENABLE_LAT_CTL_PID_TRACE (0)


// hunting_suppress
#define HUNTING_SUPPRESS_MODE_I  (1)
#define HUNTING_SUPPRESS_MODE_II (2)
#define HUNTING_SUPPRESS_MODE HUNTING_SUPPRESS_MODE_I

// 反馈增量限制
#define LAT_FEED_BACK_CHG_LIMIT_MODE_I  (1)
#define LAT_FEED_BACK_CHG_LIMIT_MODE_II (2)
#define LAT_FEED_BACK_CHG_LIMIT_MODE LAT_FEED_BACK_CHG_LIMIT_MODE_I


/******************************************************************************/
/* 类型定义                                                                    */
/******************************************************************************/

/*
 * @struct LatCtlPoint2d_t
 * @brief 二维点
 */
typedef struct _LatCtlPoint2d_t LatCtlPoint2d_t;
struct _LatCtlPoint2d_t {
  // 坐标x
  Float32_t x;
  // 坐标y
  Float32_t y;
};

/*
 * @struct LatCtlPos_t
 * @brief 位姿
 */
typedef struct _LatCtlPos_t LatCtlPos_t;
struct _LatCtlPos_t {
  // 坐标x
  Float32_t x;
  // 坐标y
  Float32_t y;
  // 航向角, Range: (-pi, pi rad)
  Float32_t heading;
  // 车速(m/s)
  Float32_t v;
  // 加速度(m/s^2)
  Float32_t a;
  // 角速度(rad/s)
  Float32_t yaw_rate;
  // 角速度变化速率(rad/s^2)
  Float32_t yaw_rate_chg_rate;
};


/******************************************************************************/
/* 全局及静态变量                                                               */
/******************************************************************************/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          轨迹前馈 (Begin)                                            */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
// 通过速度修正预瞄距离(Key table & t-gap table[current, near, far])
static const Float32_t s_key_tab_crt_lead_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F/3.6F,  10.0F/3.6F,  20.0F/3.6F,  30.0F/3.6F,  40.0F/3.6F,
   50.0F/3.6F,  60.0F/3.6F,  70.0F/3.6F,  80.0F/3.6F,  90.0F/3.6F,
  100.0F/3.6F, 110.0F/3.6F, 120.0F/3.6F, 130.0F/3.6F, 140.0F/3.6F,
  150.0F/3.6F, 160.0F/3.6F, 170.0F/3.6F, 180.0F/3.6F, 190.0F/3.6F,
  200.0F/3.6F, 210.0F/3.6F, 220.0F/3.6F, 230.0F/3.6F, 240.0F/3.6F
};
// T-Gap
static const Float32_t s_tgap_tab_crt_lead_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  2.00F, 2.00F, 2.00F, 2.00F, 2.00F,
  2.00F, 2.00F, 2.00F, 1.80F, 1.70F,
  1.60F, 1.60F, 1.60F, 1.60F, 1.50F,
  1.20F, 1.20F, 1.20F, 1.20F, 1.20F,
  1.20F, 1.20F, 1.20F, 1.20F, 1.20F
};
// Near T-Gap
static const Float32_t s_near_tgap_tab_crt_lead_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.5F, 1.5F, 1.5F, 1.5F, 1.5F,
  1.5F, 1.5F, 1.5F, 1.5F, 1.4F,
  1.3F, 1.2F, 1.1F, 1.1F, 1.1F,
  1.1F, 1.1F, 1.1F, 1.1F, 1.1F,
  1.1F, 1.1F, 1.1F, 1.1F, 1.1F
};
// Far T-Gap
static const Float32_t s_far_tgap_tab_crt_lead_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  2.5F, 2.5F, 2.5F, 2.5F, 2.5F,
  2.5F, 2.5F, 2.5F, 2.5F, 2.3F,
  2.2F, 2.2F, 2.0F, 1.7F, 1.7F,
  1.7F, 1.7F, 1.7F, 1.7F, 1.7F,
  1.7F, 1.7F, 1.7F, 1.7F, 1.7F
};

// 通过曲率修正预瞄距离(Key table & t-gap table[current, near, far])
static const Float32_t s_key_tab_crt_lead_by_curvature[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.0000F, 0.0010F, 0.0020F, 0.0030F, 0.0040F,
  0.0050F, 0.0060F, 0.0070F, 0.0080F, 0.0090F,
  0.0100F, 0.0120F, 0.0140F, 0.0160F, 0.0180F,
  0.0200F, 0.0300F, 0.0400F, 0.0500F, 0.0600F,
  0.0800F, 0.1000F, 0.1500F, 0.2000F, 0.3000F
};
// Gain
static const Float32_t s_gain_tab_crt_lead_by_curvature[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.000F, 1.000F, 0.860F, 0.855F, 0.845F,
  0.840F, 0.820F, 0.800F, 0.750F, 0.740F,
  0.735F, 0.730F, 0.725F, 0.720F, 0.715F,
  0.710F, 0.705F, 0.700F, 0.650F, 0.600F,
  0.550F, 0.500F, 0.500F, 0.500F, 0.500F
};
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          轨迹前馈 (End)                                              */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          横向误差补偿 (Begin)                                         */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
// 通过速度修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
static const Float32_t s_key_tab_crt_lat_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F/3.6F,  10.0F/3.6F,  20.0F/3.6F,  30.0F/3.6F,  40.0F/3.6F,
   50.0F/3.6F,  60.0F/3.6F,  70.0F/3.6F,  80.0F/3.6F,  90.0F/3.6F,
  100.0F/3.6F, 110.0F/3.6F, 120.0F/3.6F, 130.0F/3.6F, 140.0F/3.6F,
  150.0F/3.6F, 160.0F/3.6F, 170.0F/3.6F, 180.0F/3.6F, 190.0F/3.6F,
  200.0F/3.6F, 210.0F/3.6F, 220.0F/3.6F, 230.0F/3.6F, 240.0F/3.6F
};
// P
static const Float32_t s_p_tab_crt_lat_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  2.000F, 2.000F, 2.000F, 2.000F, 1.500F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  0.900F, 0.850F, 0.600F, 0.500F, 0.500F,
  0.500F, 0.500F, 0.500F, 0.500F, 0.500F,
  0.500F, 0.500F, 0.500F, 0.500F, 0.500F
};
// I
static const Float32_t s_i_tab_crt_lat_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
// D
static const Float32_t s_d_tab_crt_lat_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  2.000F, 2.000F, 2.000F, 2.000F, 1.500F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  0.890F, 0.880F, 0.870F, 0.860F, 0.860F,
  0.860F, 0.860F, 0.860F, 0.860F, 0.860F,
  0.860F, 0.860F, 0.860F, 0.860F, 0.860F
};

// 通过重量修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
static const Float32_t s_key_tab_crt_lat_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
      0.0F, 10000.0F, 12000.0F, 14000.0F, 16000.0F,
  18000.0F, 20000.0F, 22000.0F, 24000.0F, 26000.0F,
  28000.0F, 30000.0F, 32000.0F, 34000.0F, 36000.0F,
  38000.0F, 40000.0F, 42000.0F, 44000.0F, 46000.0F,
  48000.0F, 50000.0F, 52000.0F, 56000.0F, 60000.0F
};
// P
static const Float32_t s_p_tab_crt_lat_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.200F, 0.200F, 0.240F, 0.280F, 0.320F,
  0.360F, 0.400F, 0.440F, 0.480F, 0.520F,
  0.560F, 0.600F, 0.640F, 0.680F, 0.720F,
  0.760F, 0.800F, 0.840F, 0.880F, 0.920F,
  0.960F, 1.000F, 1.000F, 1.000F, 1.000F
};
// I
static const Float32_t s_i_tab_crt_lat_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
// D
static const Float32_t s_d_tab_crt_lat_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.350F, 0.350F, 0.350F, 0.330F, 0.335F,
  0.340F, 0.400F, 0.440F, 0.480F, 0.520F,
  0.560F, 0.600F, 0.640F, 0.680F, 0.720F,
  0.760F, 0.800F, 0.840F, 0.880F, 0.920F,
  0.960F, 1.000F, 1.000F, 1.000F, 1.000F
};

// 横向误差补偿Fuzzy Table
// 误差等级表(误差左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_lat_err_level[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1] = {
/*        0            1           2           3           4               */
/*   0          1           2           3           4           5          */
/* 负大8   ][   负大7   ][   负大6  ][   负大5   ][   负大4   ][   负大3       */
         -1.30,      -1.10,      -0.90,      -0.75,      -0.60,      
/*        5            6           7           8           9               */
/*   5          6           7           8           9           10         */
/* 负大3   ][   负大2   ][   负大1  ][    负大   ][    负中   ][   负小        */
         -0.50,      -0.40,      -0.30,      -0.20,      -0.10,      
/*        10           11         12                                       */
/*  10         11           12          13                                 */
/* 负小    ][   负零    ][   正零   ][   正小                                 */
         -0.05,       0.0,       +0.05,
/*        13           14         15          16          17               */
/*  13         14           15          16          17          18         */
/* 正小    ][   正中    ][   正大   ][   正大1   ][   正大2   ][   正大3       */
         +0.10,      +0.20,      +0.30,      +0.40,      +0.50,        
/*        18           19         20          21          22                */
/*  18         19           20          21          22          23          */
/* 正大3   ][   正大4   ][   正大5  ][   正大6   ][   正大7   ][   正大8        */
         +0.60,      +0.75,      +0.90,      +1.10,      +1.30,   
};

// 误差变化速度(误差变化速度左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_lat_err_spd_level[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1] = {
/*        0            1           2           3           4               */
/*   0          1           2           3           4           5          */
/* 负大8   ][   负大7   ][   负大6  ][   负大5   ][   负大4   ][   负大3       */
         -1.30,      -1.10,      -0.90,      -0.75,      -0.60,      
/*        5            6           7           8           9               */
/*   5          6           7           8           9           10         */
/* 负大3   ][   负大2   ][   负大1  ][    负大   ][    负中   ][   负小        */
         -0.50,      -0.40,      -0.30,      -0.20,      -0.10,      
/*        10           11         12                                       */
/*  10         11           12          13                                 */
/* 负小    ][   负零    ][   正零   ][   正小                                 */
         -0.05,       0.0,       +0.05,
/*        13           14         15          16          17               */
/*  13         14           15          16          17          18         */
/* 正小    ][   正中    ][   正大   ][   正大1   ][   正大2   ][   正大3       */
         +0.10,      +0.20,      +0.30,      +0.40,      +0.50,        
/*        18           19         20          21          22                */
/*  18         19           20          21          22          23          */
/* 正大3   ][   正大4   ][   正大5  ][   正大6   ][   正大7   ][   正大8        */
         +0.60,      +0.75,      +0.90,      +1.10,      +1.30,   
};

// 横向误差补偿系数表
// P - lat_err
static const Float32_t s_p_gain_tab_lat_err_feed[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE] = {
  /*                      0        1        2        3        4          5        6        7        8        9       10        11         12       13      14       15       16       17        18         19       20       21       22      23      */
  /*   向右移动  */ /*速度 : 负大8   负大7    负大6     负大5     负大4      负大3     负大2     负大1    负中      负中      负小     负零        正零      正小     正中      正中      正大1     正大2    正大3       正大4    正大5     正大6     正大7    正大8    */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大7 NB  1 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大6 NB  2 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大5 NB  3 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大4 NB  4 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,

  /* 偏差 负大3 NB  5 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.160,  -0.200,  -0.105,  -0.100,    -0.100,  -0.100,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大2 NB  6 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.160,  -0.230,  -0.150,  -0.150,    -0.150,  -0.120,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大1 NB  7 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.180,  -0.230,  -0.200,  -0.200,    -0.200,  -0.150,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负大  NM  8 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.180,  -0.200,  -0.200,  -0.200,    -0.200,  -0.042,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负中  NS  9 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.080,  -0.076,  -0.200,  -0.200,    -0.200,  -0.038,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负小  NS 10 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.036,  -0.032,  -0.200,  -0.200,    -0.200,  -0.023,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 负零  NZ 11 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.036,  -0.032,  -0.026,  -0.026,    -0.023,  -0.023,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,

  /* 偏差 正零  PZ 12 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.023,  -0.023,    -0.026,  -0.026,  -0.032,  -0.036,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正小  PS 13 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.023,  -0.200,    -0.200,  -0.200,  -0.032,  -0.036,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正中  PS 14 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.038,  -0.200,    -0.200,  -0.200,  -0.076,  -0.080,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大  PM 15 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.042,  -0.200,    -0.300,  -0.300,  -0.200,  -0.180,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大1 PB 16 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.150,  -0.200,    -0.200,  -0.200,  -0.230,  -0.180,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大2 PB 17 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.120,  -0.150,    -0.150,  -0.150,  -0.230,  -0.160,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大3 PB 18 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.100,  -0.100,    -0.100,  -0.105,  -0.200,  -0.160,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,

  /* 偏差 正大4 PB 19 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大5 PB 20 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大6 PB 21 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大7 PB 22 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
  /* 偏差 正大8 PB 23 */ -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,
};

// I - lat_err
#if 0
static const Float32_t s_i_gain_tab_lat_err_feed[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE] = {
  /*                       0         1        2         3         4           5         6          7        8         9         10       11          12         13        14        15        16       17        18           19        20        21        22        23      */
  /*   向右移动  */ /*速度 : 负大8    负大7     负大6      负大5     负大4        负大3      负大2      负大1      负大      负小       负小      负零         正零       正小       正中       正大      正大1     正大2      正大3        正大4      正大5     正大6      正大7      正大8     */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大7 NB  1 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大6 NB  2 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大5 NB  3 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大4 NB  4 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 负大3 NB  5 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0010,  -0.0024,  -0.0024,  -0.0024,    -0.0010,  -0.0010,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大2 NB  6 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0030,  -0.0040,  -0.0040,  -0.0040,    -0.0020,  -0.0010,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大1 NB  7 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0040,  -0.0050,  -0.0050,    -0.0020,  -0.0015,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大  NM  8 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0040,  -0.0070,  -0.0070,    -0.0040,  -0.0030,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负中  NS  9 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0060,  -0.0070,  -0.0070,    -0.0040,  -0.0030,  +0.0020,  +0.0040,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负小  NS 10 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0060,  -0.0080,  -0.0075,  -0.0060,    -0.0010,  +0.0015,  +0.0040,  +0.0050,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负零  NZ 11 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0060,  -0.0085,  -0.0075,  -0.0060,    +0.0000,  +0.0080,  +0.0090,  +0.0090,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 正零  PZ 12 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0090,  +0.0090,  +0.0080,  +0.0000,    -0.0060,  -0.0075,  -0.0085,  -0.0060,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正小  PS 13 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0050,  +0.0040,  +0.0015,  -0.0010,    -0.0060,  -0.0075,  -0.0080,  -0.0060,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正中  PS 14 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0040,  +0.0020,  -0.0030,  -0.0040,    -0.0070,  -0.0070,  -0.0060,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大  PM 15 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0030,  -0.0040,    -0.0070,  -0.0070,  -0.0040,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大1 PB 16 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0015,  -0.0020,    -0.0050,  -0.0050,  -0.0040,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大2 PB 17 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0010,  -0.0020,    -0.0040,  -0.0040,  -0.0040,  -0.0030,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大3 PB 18 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0010,  -0.0010,    -0.0024,  -0.0024,  -0.0024,  -0.0010,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 正大4 PB 19 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大5 PB 20 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大6 PB 21 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大7 PB 22 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大8 PB 23 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
};
#else
static const Float32_t s_i_gain_tab_lat_err_feed[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE] = {
  /*                       0         1        2         3         4           5         6          7        8         9         10       11          12         13        14        15        16       17        18           19        20        21        22        23      */
  /*   向右移动  */ /*速度 : 负大8    负大7     负大6      负大5     负大4        负大3      负大2      负大1      负大      负小       负小      负零         正零       正小       正中       正大      正大1     正大2      正大3        正大4      正大5     正大6      正大7      正大8     */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大7 NB  1 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大6 NB  2 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大5 NB  3 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大4 NB  4 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 负大3 NB  5 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0010,  -0.0024,  -0.0024,  -0.0024,    -0.0010,  -0.0010,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大2 NB  6 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0030,  -0.0040,  -0.0040,  -0.0040,    -0.0020,  -0.0010,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大1 NB  7 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0040,  -0.0050,  -0.0050,    -0.0020,  -0.0015,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负大  NM  8 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0040,  -0.0070,  -0.0070,    -0.0040,  -0.0030,  -0.0005,  -0.0005,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负中  NS  9 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0040,  -0.0060,  -0.0070,  -0.0070,    -0.0040,  -0.0030,  +0.0020,  +0.0040,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负小  NS 10 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0060,  -0.0080,  -0.0075,  -0.0060,    -0.0010,  +0.0015,  +0.0040,  +0.0050,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
  /* 偏差 负零  NZ 11 */ -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0060,  -0.0085,  -0.0075,  -0.0060,    +0.0000,  +0.0080,  +0.0090,  +0.0090,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 正零  PZ 12 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0090,  +0.0090,  +0.0080,  +0.0000,    -0.0060,  -0.0075,  -0.0085,  -0.0060,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正小  PS 13 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0050,  +0.0040,  +0.0015,  -0.0010,    -0.0060,  -0.0075,  -0.0080,  -0.0060,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正中  PS 14 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  +0.0040,  +0.0020,  -0.0030,  -0.0040,    -0.0070,  -0.0070,  -0.0060,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大  PM 15 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0030,  -0.0040,    -0.0070,  -0.0070,  -0.0040,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大1 PB 16 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0015,  -0.0020,    -0.0050,  -0.0050,  -0.0040,  -0.0040,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大2 PB 17 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0010,  -0.0020,    -0.0040,  -0.0040,  -0.0040,  -0.0030,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大3 PB 18 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0005,  -0.0005,  -0.0010,  -0.0010,    -0.0024,  -0.0024,  -0.0024,  -0.0010,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
                                                                                                                                                                                                                                                                           
  /* 偏差 正大4 PB 19 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大5 PB 20 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大6 PB 21 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大7 PB 22 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
  /* 偏差 正大8 PB 23 */ +0.0000,  +0.0000,  +0.0000,  +0.0000,  +0.0000,    +0.0000,  +0.0000,  +0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,
};
#endif

// D - lat_err
static const Float32_t s_d_gain_tab_lat_err_feed[LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE] = {
  /*                       0        1       2       3        4           5        6       7        8         9        10       11         12       13      14       15       16       17       18         19        20      21       22       23     */
  /*   向右移动  */ /*速度 : 负大8   负大7    负大6     负大5     负大4      负大3     负大2     负大1     负大     负中      负小      负零       正零       正小     正中     正大      正大1     正大2    正大3       正大4     正大5     正大6    正大7     正大8   */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大7 NB  1 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大6 NB  2 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大5 NB  3 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大4 NB  4 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
                                                                                                                                                                                                                                                   
  /* 偏差 负大3 NB  5 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大2 NB  6 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.250,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大1 NB  7 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.380,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负大  NM  8 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.350,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负中  NS  9 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.350,  -0.400,  -0.000,    -0.000,  -0.000,  -0.000,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负小  NS 10 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.350,  -0.000,  -0.000,    -0.000,  -0.000,  -0.000,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 负零  NZ 11 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.350,  -0.000,  -0.000,    -0.000,  -0.000,  -0.350,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
                                                                                                                                                                                                                                                   
  /* 偏差 正零  PZ 12 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.350,  -0.000,  -0.000,    -0.000,  -0.000,  -0.350,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正小  PS 13 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.000,  -0.000,  -0.000,    -0.000,  -0.000,  -0.350,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正中  PS 14 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.350,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大  PM 15 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.200,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.350,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大1 PB 16 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.200,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.200,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大2 PB 17 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.150,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大3 PB 18 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
                                                                                                                                                                                                                                                  
  /* 偏差 正大4 PB 19 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.150,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大5 PB 20 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.100,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大6 PB 21 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大7 PB 22 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
  /* 偏差 正大8 PB 23 */ -0.100,  -0.100,  -0.100,  -0.100,  -0.000,    -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,  -0.000,    -0.000,  -0.400,  -0.380,  -0.250,  -0.200,  -0.150,  -0.150,    -0.100,  -0.100,  -0.100,  -0.100,  -0.100,
};


/// 不同横向距离上，横向误差变化率的限制值
static const Float32_t s_key_tab_lmt_lat_err_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.10F,  0.20F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.90F,
  1.00F,  1.10F,  1.20F,  1.30F,  1.40F,
  1.50F,  1.60F,  1.70F,  1.80F,  1.90F,
  2.00F,  2.10F,  2.20F,  2.30F,  2.40F
};
// 增益表
static const Float32_t s_gain_tab_lmt_lat_err_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
};
// 接近的速度
static const Float32_t s_base_val_tab_lmt_lat_err_spd_close[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.30F,  0.30F,  0.30F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.80F,
  0.80F,  0.80F,  0.80F,  0.80F,  0.80F,
  0.80F,  0.80F,  0.80F,  0.80F,  0.80F,
  0.80F,  0.80F,  0.80F,  0.80F,  0.80F,
};
// 远离的速度
static const Float32_t s_base_val_tab_lmt_lat_err_spd_far_away[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
  0.30F,  0.30F,  0.30F,  0.30F,  0.30F,
};
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          横向误差补偿 (End)                                           */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          横向误差变化率补偿 (Begin)                                    */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/* k001 pengc 2023-11-07 (begin) */
/// 不同横向距离上，横向误差变化率的目标值
// Key
static const Float32_t s_key_tab_tar_lat_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.10F,  0.20F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.90F,
  1.00F,  1.10F,  1.20F,  1.30F,  1.40F,
  1.50F,  1.60F,  1.70F,  1.80F,  1.90F,
  2.00F,  2.10F,  2.20F,  2.30F,  2.40F
};
// 横向误差变化率的目标值
static const Float32_t s_exp_tab_tar_lat_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.05F,  0.10F,  0.12F,  0.15F,
  0.20F,  0.25F,  0.30F,  0.35F,  0.40F,
  0.45F,  0.45F,  0.45F,  0.45F,  0.45F,
  0.45F,  0.45F,  0.45F,  0.45F,  0.45F,
  0.45F,  0.45F,  0.45F,  0.45F,  0.45F,
};
// 横向误差变化率的目标值的 standard deviation
static const Float32_t s_dev_tab_tar_lat_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.01F,  0.02F,  0.02F,  0.02F,  0.04F,
  0.05F,  0.05F,  0.05F,  0.05F,  0.05F,
  0.05F,  0.05F,  0.05F,  0.05F,  0.05F,
  0.05F,  0.05F,  0.05F,  0.05F,  0.05F,
  0.05F,  0.05F,  0.05F,  0.05F,  0.05F,
};


// 横向误差速率补偿Fuzzy Table
// 误差速率等级表(误差左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_lat_spd_err_level[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1] = {
/*        0            1           2           3           4               */
/*   0          1           2           3           4           5          */
/* 负大8   ][   负大7   ][   负大6  ][   负大5   ][   负大4   ][   负大3       */
         -1.30,      -1.10,      -0.90,      -0.75,      -0.60,      
/*        5            6           7           8           9               */
/*   5          6           7           8           9           10         */
/* 负大3   ][   负大2   ][   负大1  ][    负大   ][    负中   ][   负小        */
         -0.50,      -0.40,      -0.30,      -0.20,      -0.10,      
/*        10           11         12                                       */
/*  10         11           12          13                                 */
/* 负小    ][   负零    ][   正零   ][   正小                                 */
         -0.05,       0.0,       +0.05,
/*        13           14         15          16          17               */
/*  13         14           15          16          17          18         */
/* 正小    ][   正中    ][   正大   ][   正大1   ][   正大2   ][   正大3       */
         +0.10,      +0.20,      +0.30,      +0.40,      +0.50,        
/*        18           19         20          21          22                */
/*  18         19           20          21          22          23          */
/* 正大3   ][   正大4   ][   正大5  ][   正大6   ][   正大7   ][   正大8        */
         +0.60,      +0.75,      +0.90,      +1.10,      +1.30,   
};

// 误差速率变化率等级表(误差变化速度左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_lat_acc_level[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1] = {
/*        0            1           2           3           4               */
/*   0          1           2           3           4           5          */
/* 负大8   ][   负大7   ][   负大6  ][   负大5   ][   负大4   ][   负大3       */
         -1.30,      -1.10,      -0.90,      -0.75,      -0.60,      
/*        5            6           7           8           9               */
/*   5          6           7           8           9           10         */
/* 负大3   ][   负大2   ][   负大1  ][    负大   ][    负中   ][   负小        */
         -0.50,      -0.40,      -0.30,      -0.20,      -0.10,      
/*        10           11         12                                       */
/*  10         11           12          13                                 */
/* 负小    ][   负零    ][   正零   ][   正小                                 */
         -0.05,       0.0,       +0.05,
/*        13           14         15          16          17               */
/*  13         14           15          16          17          18         */
/* 正小    ][   正中    ][   正大   ][   正大1   ][   正大2   ][   正大3       */
         +0.10,      +0.20,      +0.30,      +0.40,      +0.50,        
/*        18           19         20          21          22                */
/*  18         19           20          21          22          23          */
/* 正大3   ][   正大4   ][   正大5  ][   正大6   ][   正大7   ][   正大8        */
         +0.60,      +0.75,      +0.90,      +1.10,      +1.30,     
};

// 横向误差速率补偿系数表
// P - lat_spd
#if 0
static const Float32_t s_p_gain_tab_lat_spd_feed[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE] = {
  /*                       0        1        2        3        4           5        6       7        8        9        10       11         12       13       14       15       16       17       18         19       20       21       22       23 */
  /*   向右移动  */ /*速度: 负大8    负大7     负大6    负大5     负大4        负大3    负大2    负大1     负大      负中     负小      负零        正零      正小     正中      正大     正大1     正大2     正大3       正大4     正大5    正大6     正大7     正大8 */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大7 NB  1 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大6 NB  2 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大5 NB  3 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大4 NB  4 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
                                                                                                                                                                                                                                                    
  /* 偏差 负大3 NB  5 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大2 NB  6 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.300,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大1 NB  7 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.400,  +0.400,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.380,  +0.380,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,
  /* 偏差 负大  NM  8 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.350,  +0.380,  +0.400,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.400,  +0.400,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,
  /* 偏差 负中  NS  9 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.250,     +0.300,  +0.300,  +0.300,  +0.350,  +0.400,  +0.450,  +0.450,    +0.450,  +0.500,  +0.500,  +0.500,  +0.500,  +0.450,  +0.450,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,
  /* 偏差 负小  NS 10 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.500,  +0.500,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
  /* 偏差 负零  NZ 11 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.500,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
                                                                                                                                                                                                                                                    
  /* 偏差 正零  PZ 12 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.500,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正小  PS 13 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.500,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正中  PS 14 */ +0.550,  +0.550,  +0.550,  +0.550,  +0.550,     +0.450,  +0.450,  +0.500,  +0.500,  +0.500,  +0.500,  +0.450,    +0.450,  +0.450,  +0.400,  +0.350,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大  PM 15 */ +0.450,  +0.450,  +0.450,  +0.450,  +0.450,     +0.400,  +0.400,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.400,  +0.380,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大1 PB 16 */ +0.400,  +0.400,  +0.400,  +0.400,  +0.400,     +0.380,  +0.380,  +0.400,  +0.400,  +0.400,  +0.400,  +0.380,    +0.400,  +0.400,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大2 PB 17 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大3 PB 18 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
                                                                                                                                                                                                                                                    
  /* 偏差 正大4 PB 19 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大5 PB 20 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大6 PB 21 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大7 PB 22 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大8 PB 23 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
};
#endif
#if 0
static const Float32_t s_p_gain_tab_lat_spd_feed[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE] = {
  /*                       0        1        2        3        4           5        6       7        8        9        10       11         12       13       14       15       16       17       18         19       20       21       22       23 */
  /*   向右移动  */ /*速度: 负大8    负大7     负大6    负大5     负大4        负大3    负大2    负大1     负大      负中     负小      负零        正零      正小     正中      正大     正大1     正大2     正大3       正大4     正大5    正大6     正大7     正大8 */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大7 NB  1 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大6 NB  2 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大5 NB  3 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大4 NB  4 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
                                                                                                                                                                                                                                                    
  /* 偏差 负大3 NB  5 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.350,  +0.350,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大2 NB  6 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.300,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.350,  +0.350,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大1 NB  7 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.350,  +0.350,  +0.400,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,
  /* 偏差 负大  NM  8 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.350,  +0.380,  +0.400,  +0.500,    +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,
  /* 偏差 负中  NS  9 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.250,     +0.300,  +0.300,  +0.300,  +0.350,  +0.400,  +0.450,  +0.500,    +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,
  /* 偏差 负小  NS 10 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.500,  +0.500,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
  /* 偏差 负零  NZ 11 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.500,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
                                                                                                                                                                                                                                                    
  /* 偏差 正零  PZ 12 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.500,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正小  PS 13 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.500,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正中  PS 14 */ +0.550,  +0.550,  +0.550,  +0.550,  +0.550,     +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.450,  +0.450,  +0.400,  +0.350,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大  PM 15 */ +0.450,  +0.450,  +0.450,  +0.450,  +0.450,     +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.450,  +0.400,  +0.380,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大1 PB 16 */ +0.400,  +0.400,  +0.400,  +0.400,  +0.400,     +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.400,  +0.400,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大2 PB 17 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,    +0.350,  +0.350,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大3 PB 18 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,  +0.400,    +0.350,  +0.350,  +0.350,  +0.350,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
                                                                                                                                                                                                                                                    
  /* 偏差 正大4 PB 19 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大5 PB 20 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大6 PB 21 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大7 PB 22 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大8 PB 23 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
};
#endif
static const Float32_t s_p_gain_tab_lat_spd_feed[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE] = {
  /*                       0        1        2        3        4           5        6       7        8        9        10       11         12       13       14       15       16       17       18         19       20       21       22       23 */
  /*   向右移动  */ /*速度: 负大8    负大7     负大6    负大5     负大4        负大3    负大2    负大1     负大      负中     负小      负零        正零      正小     正中      正大     正大1     正大2     正大3       正大4     正大5    正大6     正大7     正大8 */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大7 NB  1 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大6 NB  2 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.200,  +0.200,  +0.250,  +0.250,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大5 NB  3 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大4 NB  4 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.400,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.350,  +0.350,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
                                                                                                                                                                                                                                                    
  /* 偏差 负大3 NB  5 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.200,     +0.300,  +0.300,  +0.300,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大2 NB  6 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.300,     +0.300,  +0.300,  +0.300,  +0.400,  +0.400,  +0.450,  +0.450,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.350,  +0.350,  +0.350,  +0.350,  +0.350,
  /* 偏差 负大1 NB  7 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.400,  +0.400,  +0.450,  +0.450,    +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.400,  +0.400,  +0.400,  +0.400,  +0.400,
  /* 偏差 负大  NM  8 */ +0.300,  +0.300,  +0.300,  +0.300,  +0.350,     +0.300,  +0.300,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.450,  +0.450,  +0.450,  +0.450,  +0.450,
  /* 偏差 负中  NS  9 */ +0.200,  +0.200,  +0.200,  +0.200,  +0.250,     +0.300,  +0.300,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,
  /* 偏差 负小  NS 10 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
  /* 偏差 负零  NZ 11 */ +0.150,  +0.150,  +0.150,  +0.150,  +0.150,     +0.200,  +0.200,  +0.300,  +0.400,  +0.450,  +0.500,  +0.500,    +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.600,  +0.600,  +0.600,  +0.600,  +0.600,
                                                                                                                                                                                                                                                    
  /* 偏差 正零  PZ 12 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正小  PS 13 */ +0.600,  +0.600,  +0.600,  +0.600,  +0.600,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.200,  +0.200,    +0.150,  +0.150,  +0.150,  +0.150,  +0.150,
  /* 偏差 正中  PS 14 */ +0.550,  +0.550,  +0.550,  +0.550,  +0.550,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大  PM 15 */ +0.450,  +0.450,  +0.450,  +0.450,  +0.450,     +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,  +0.550,    +0.500,  +0.500,  +0.450,  +0.400,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大1 PB 16 */ +0.400,  +0.400,  +0.400,  +0.400,  +0.400,     +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,  +0.500,    +0.450,  +0.450,  +0.400,  +0.400,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大2 PB 17 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.300,  +0.300,  +0.300,    +0.300,  +0.300,  +0.300,  +0.300,  +0.300,
  /* 偏差 正大3 PB 18 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.300,  +0.300,  +0.300,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
                                                                                                                                                                                                                                                    
  /* 偏差 正大4 PB 19 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大5 PB 20 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.400,  +0.400,  +0.300,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大6 PB 21 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大7 PB 22 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
  /* 偏差 正大8 PB 23 */ +0.350,  +0.350,  +0.350,  +0.350,  +0.350,     +0.350,  +0.350,  +0.450,  +0.450,  +0.450,  +0.450,  +0.450,    +0.450,  +0.450,  +0.400,  +0.250,  +0.250,  +0.200,  +0.200,    +0.200,  +0.200,  +0.200,  +0.200,  +0.200,
};

// I - lat_spd
static const Float32_t s_i_gain_tab_lat_spd_feed[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE] = {
  /*                       0        1        2        3        4          5         6         7        8         9         10        11          12        13        14        15        16        17        18         19       20       21       22       23 */
  /*   向右移动  */ /*速度: 负大8    负大7     负大6     负大5     负大4      负大3      负大2     负大1      负大       负中      负小       负零         正零       正小      正中       正大       正大1     正大2      正大3       正大4    正大5     正大6     正大7    正大8 */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,     0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大7 NB  1 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,     0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大6 NB  2 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,     0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大5 NB  3 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,     0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大4 NB  4 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0060,   0.0060,   0.0060,     0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
                                                                                                                                                                                                                                                                
  /* 偏差 负大3 NB  5 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0060,   0.0060,   0.0060,     0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0070,   0.0070,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大2 NB  6 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0060,   0.0060,   0.0070,     0.0070,   0.0080,   0.0070,   0.0070,   0.0070,   0.0070,   0.0080,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大1 NB  7 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0050,   0.0070,     0.0070,   0.0080,   0.0080,   0.0080,   0.0070,   0.0070,   0.0080,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负大  NM  8 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0040,   0.0070,     0.0070,   0.0085,   0.0100,   0.0100,   0.0100,   0.0090,   0.0090,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负中  NS  9 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0030,   0.0060,     0.0080,   0.0085,   0.0100,   0.0100,   0.0100,   0.0100,   0.0110,    0.0050,  0.0050,  0.0050,  0.0050,  0.0050,
  /* 偏差 负小  NS 10 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0020,   0.0050,     0.0080,   0.0080,   0.0100,   0.0100,   0.0100,   0.0100,   0.0100,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 负零  NZ 11 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,     0.0000,   0.0080,   0.0080,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
                                                                                                                                                                                                                                                                 
  /* 偏差 正零  PZ 12 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0000,   0.0000,   0.0000,   0.0000,   0.0080,   0.0080,   0.0000,     0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正小  PS 13 */  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,    0.0100,   0.0100,   0.0100,   0.0100,   0.0100,   0.0080,   0.0080,     0.0050,   0.0020,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正中  PS 14 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0100,   0.0100,   0.0100,   0.0100,   0.0100,   0.0085,   0.0080,     0.0060,   0.0030,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大  PM 15 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0090,   0.0090,   0.0100,   0.0100,   0.0100,   0.0085,   0.0070,     0.0070,   0.0040,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大1 PB 16 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0080,   0.0070,   0.0070,   0.0080,   0.0080,   0.0080,   0.0070,     0.0070,   0.0050,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大2 PB 17 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0080,   0.0070,   0.0070,   0.0070,   0.0070,   0.0080,   0.0070,     0.0070,   0.0060,   0.0060,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大3 PB 18 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0070,   0.0070,   0.0070,   0.0060,   0.0060,   0.0060,   0.0060,     0.0060,   0.0060,   0.0060,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
                                                                                                                                                                                                                                                                 
  /* 偏差 正大4 PB 19 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,     0.0060,   0.0060,   0.0060,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大5 PB 20 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,   0.0060,     0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大6 PB 21 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,     0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大7 PB 22 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,     0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
  /* 偏差 正大8 PB 23 */  0.0050,  0.0050,  0.0050,  0.0050,  0.0050,    0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,   0.0050,     0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,   0.0000,    0.0000,  0.0000,  0.0000,  0.0000,  0.0000,
};

// D - lat_spd
static const Float32_t s_d_gain_tab_lat_spd_feed[LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE] = {
  /*                       0        1        2        3        4          5         6         7        8         9         10        11          12        13        14        15        16        17        18         19       20       21       22       23 */
  /*   向右移动  */ /*速度: 负大8    负大7     负大6     负大5     负大4      负大3      负大2     负大1      负大       负中      负小       负零         正零       正小      正中       正大       正大1     正大2      正大3       正大4    正大5     正大6     正大7    正大8 */ /* 向左移动 */
  /* 偏差 负大8 NB  0 */ -0.0050, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大7 NB  1 */ -0.0050, -0.0050, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大6 NB  2 */ -0.0050, -0.0050, -0.0050, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大5 NB  3 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大4 NB  4 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
                                                                                                                                                                                                                                                                
  /* 偏差 负大3 NB  5 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大2 NB  6 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大1 NB  7 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0090,  -0.0050,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负大  NM  8 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0080,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0050,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,
  /* 偏差 负中  NS  9 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0000,    -0.0000,  -0.0000,  -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0050,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 负小  NS 10 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0080,  -0.0080,    -0.0070,  -0.0070,  -0.0080,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 负零  NZ 11 */ -0.0060, -0.0060, -0.0060, -0.0060, -0.0060,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0080,  -0.0080,    -0.0070,  -0.0070,  -0.0080,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0060, -0.0060, -0.0060, -0.0060, -0.0060,
                                                                                                                                                                                                                                                                 
  /* 偏差 正零  PZ 12 */ -0.0060, -0.0060, -0.0060, -0.0060, -0.0060,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0080,  -0.0070,  -0.0070,    -0.0080,  -0.0080,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0060, -0.0060, -0.0060, -0.0060, -0.0060,
  /* 偏差 正小  PS 13 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0080,  -0.0070,  -0.0070,    -0.0080,  -0.0080,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正中  PS 14 */ -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,   -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0000,  -0.0000,    -0.0000,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大  PM 15 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0050,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0080,  -0.0090,  -0.0090,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大1 PB 16 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0050,  -0.0090,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大2 PB 17 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0090,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大3 PB 18 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0090,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
                                                                                                                                                                                                                                                                 
  /* 偏差 正大4 PB 19 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0050, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大5 PB 20 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0050, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大6 PB 21 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0050, -0.0050, -0.0050,
  /* 偏差 正大7 PB 22 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0050, -0.0050,
  /* 偏差 正大8 PB 23 */ -0.0000, -0.0000, -0.0000, -0.0000, -0.0000,   -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,    -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,  -0.0000,   -0.0000, -0.0000, -0.0000, -0.0000, -0.0050,
};
/* k001 pengc 2023-11-07 (end) */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          横向误差变化率补偿 (End)                                      */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          航向角误差补偿 (Begin)                                       */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/* k001 pengc 2023-12-01 (begin) */
// 通过速度修正角度误差的目标值
// Key
static const Float32_t s_key_tab_crt_yaw_err_exp_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F/3.6F,  10.0F/3.6F,  20.0F/3.6F,  30.0F/3.6F,  40.0F/3.6F,
   50.0F/3.6F,  60.0F/3.6F,  70.0F/3.6F,  80.0F/3.6F,  90.0F/3.6F,
  100.0F/3.6F, 110.0F/3.6F, 120.0F/3.6F, 130.0F/3.6F, 140.0F/3.6F,
  150.0F/3.6F, 160.0F/3.6F, 170.0F/3.6F, 180.0F/3.6F, 190.0F/3.6F,
  200.0F/3.6F, 210.0F/3.6F, 220.0F/3.6F, 230.0F/3.6F, 240.0F/3.6F
};
// raito
static const Float32_t s_ratio_tab_crt_yaw_err_exp_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.500F, 1.500F, 1.500F, 1.500F, 1.400F,
  1.300F, 1.200F, 1.100F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
/// 不同横向距离上，角度误差的目标值
// Key
static const Float32_t s_key_tab_tar_yaw_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.10F,  0.20F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.90F,
  1.00F,  1.10F,  1.20F,  1.30F,  1.40F,
  1.50F,  1.60F,  1.70F,  1.80F,  1.90F,
  2.00F,  2.10F,  2.20F,  2.30F,  2.40F
};
// 角度误差的目标值, expected
static const Float32_t s_exp_tab_tar_yaw_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F*0.017453293F,  0.05F*0.017453293F,  0.10F*0.017453293F,  0.15F*0.017453293F,  0.20F*0.017453293F,
  0.25F*0.017453293F,  0.30F*0.017453293F,  0.35F*0.017453293F,  0.40F*0.017453293F,  0.50F*0.017453293F,
  0.60F*0.017453293F,  0.70F*0.017453293F,  0.80F*0.017453293F,  0.90F*0.017453293F,  1.00F*0.017453293F,
  1.10F*0.017453293F,  1.20F*0.017453293F,  1.30F*0.017453293F,  1.40F*0.017453293F,  1.50F*0.017453293F,
  1.60F*0.017453293F,  1.70F*0.017453293F,  1.80F*0.017453293F,  2.00F*0.017453293F,  2.00F*0.017453293F,
};
// 角度误差的目标值, standard deviation
static const Float32_t s_dev_tab_tar_yaw_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,
  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,
  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,  0.50F*0.017453293F,
  0.60F*0.017453293F,  0.80F*0.017453293F,  0.90F*0.017453293F,  1.00F*0.017453293F,  1.50F*0.017453293F,
  2.00F*0.017453293F,  2.00F*0.017453293F,  2.00F*0.017453293F,  2.00F*0.017453293F,  2.00F*0.017453293F,
};

/* k001 pengc 2023-12-01 (end) */
// 航向角误差补偿Fuzzy Table
// 误差等级表(误差左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_yaw_err_level[LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1] = {
/*        0          1           2          3          4          5           6          */
/*  0          1           2          3          4           5          6          7     */
/* 负大   ][   负中   ][   负小   ][   负零   ][   正零   ][   正小   ][   正中   ][   正大    */
  -3.00*0.017453293F,  -2.00*0.017453293F,  -1.00*0.017453293F,  0.00*0.017453293F,  1.00*0.017453293F,  2.00*0.017453293F,  3.00*0.017453293F
};

// 航向角误差变化速度(误差变化速度左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_yaw_err_spd_level[LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1] = {
/*        0          1           2          3          4          5           6          */
/*  0          1           2          3          4           5          6          7     */
/* 负大   ][   负中   ][   负小   ][   负零   ][   正零   ][   正小   ][   正中   ][   正大    */
  -3.00*0.017453293F,  -2.00*0.017453293F,  -1.00*0.017453293F,  0.00*0.017453293F,  1.00*0.017453293F,  2.00*0.017453293F,  3.00*0.017453293F
};

// 航向角误差补偿系数表
// P
static const Float32_t s_p_gain_tab_yaw_err_feed[LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE] = {
  /*                      0        1        2        3          4        5         6        7     */
  /*   向右移动  */ /*速度: 负大     负中      负小     负零        正零      正小      正中      正大   */ /* 向左移动 */
  /* 偏差 负大  NB  0 */ -1.000,  -1.000,  -1.000,  -1.000,    -1.000,  -1.000,  -1.000,  -1.000,
  /* 偏差 负中  NM  1 */ -2.000,  -2.000,  -2.000,  -2.000,    -2.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 负小  NS  2 */ -2.000,  -2.000,  -3.000,  -3.000,    -4.000,  -4.000,  -4.000,  -4.000,
  /* 偏差 负零  NZ  3 */ -3.000,  -3.000,  -4.000,  -4.000,    -4.000,  -4.000,  -4.000,  -4.000,

  /* 偏差 正零  PZ  4 */ -4.000,  -4.000,  -4.000,  -4.000,    -4.000,  -4.000,  -3.000,  -3.000,
  /* 偏差 正小  PS  5 */ -4.000,  -4.000,  -4.000,  -4.000,    -3.000,  -3.000,  -2.000,  -2.000,
  /* 偏差 正中  PM  6 */ -2.000,  -2.000,  -2.000,  -2.000,    -2.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 正大  PB  7 */ -1.000,  -1.000,  -1.000,  -1.000,    -1.000,  -1.000,  -1.000,  -1.000,
};

// I
static const Float32_t s_i_gain_tab_yaw_err_feed[LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE] = {
  /*                      0        1        2        3          4        5         6        7     */
  /*   向右移动  */ /*速度: 负大     负中      负小     负零        正零      正小      正中      正大   */ /* 向左移动 */
  /* 偏差 负大  NB  0 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 负中  NM  1 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 负小  NS  2 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 负零  NZ  3 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,

  /* 偏差 正零  PZ  4 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 正小  PS  5 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 正中  PM  6 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
  /* 偏差 正大  PB  7 */ +0.000,  +0.000,  +0.000,  +0.000,    +0.000,  +0.000,  +0.000,  +0.000,
};

// D
static const Float32_t s_d_gain_tab_yaw_err_feed[LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE] = {
  /*                      0        1        2        3          4        5         6        7     */
  /*   向右移动  */ /*速度: 负大     负中      负小     负零        正零      正小      正中      正大   */ /* 向左移动 */
  /* 偏差 负大  NB  0 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 负中  NM  1 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 负小  NS  2 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 负零  NZ  3 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,

  /* 偏差 正零  PZ  4 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 正小  PS  5 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 正中  PM  6 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
  /* 偏差 正大  PB  7 */ -2.000,  -2.000,  -2.000,  -0.000,    -0.000,  -2.000,  -2.000,  -2.000,
};
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          航向角误差补偿 (End)                                         */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          偏航角速度误差补偿 (Begin)                                    */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
// 通过速度修正角速度误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
static const Float32_t s_key_tab_crt_yaw_rate_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F/3.6F,  10.0F/3.6F,  20.0F/3.6F,  30.0F/3.6F,  40.0F/3.6F,
   50.0F/3.6F,  60.0F/3.6F,  70.0F/3.6F,  80.0F/3.6F,  90.0F/3.6F,
  100.0F/3.6F, 110.0F/3.6F, 120.0F/3.6F, 130.0F/3.6F, 140.0F/3.6F,
  150.0F/3.6F, 160.0F/3.6F, 170.0F/3.6F, 180.0F/3.6F, 190.0F/3.6F,
  200.0F/3.6F, 210.0F/3.6F, 220.0F/3.6F, 230.0F/3.6F, 240.0F/3.6F
};
// P
static const Float32_t s_p_tab_crt_yaw_rate_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.000F, 0.000F, 0.700F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.100F, 1.200F, 1.100F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
};
// I
static const Float32_t s_i_tab_crt_yaw_rate_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.000F, 0.000F, 0.700F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
// D
static const Float32_t s_d_tab_crt_yaw_rate_err_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.000F, 0.000F, 0.700F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};

// 通过重量修正角速度误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
static const Float32_t s_key_tab_crt_yaw_rate_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
      0.0F, 10000.0F, 12000.0F, 14000.0F, 16000.0F,
  18000.0F, 20000.0F, 22000.0F, 24000.0F, 26000.0F,
  28000.0F, 30000.0F, 32000.0F, 34000.0F, 36000.0F,
  38000.0F, 40000.0F, 42000.0F, 44000.0F, 46000.0F,
  48000.0F, 50000.0F, 52000.0F, 56000.0F, 60000.0F
};
// P
static const Float32_t s_p_tab_crt_yaw_rate_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.550F, 0.550F, 0.550F, 0.580F, 0.610F,
  0.640F, 0.670F, 0.700F, 0.730F, 0.760F,
  0.790F, 0.820F, 0.850F, 0.880F, 0.910F,
  0.940F, 0.970F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
// I
static const Float32_t s_i_tab_crt_yaw_rate_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};
// D
static const Float32_t s_d_tab_crt_yaw_rate_err_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.550F, 0.550F, 0.550F, 0.580F, 0.610F,
  0.640F, 0.670F, 0.700F, 0.730F, 0.760F,
  0.790F, 0.820F, 0.850F, 0.880F, 0.910F,
  0.940F, 0.970F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F
};

/* k001 pengc 2023-12-01 (begin) */
/// 不同横向距离上，角角速度误差的目标值
// Key
static const Float32_t s_key_tab_tar_yaw_rate_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.10F,  0.20F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.90F,
  1.00F,  1.10F,  1.20F,  1.30F,  1.40F,
  1.50F,  1.60F,  1.70F,  1.80F,  1.90F,
  2.00F,  2.10F,  2.20F,  2.30F,  2.40F
};
// 角速度误差的目标值, standard deviation
#if 0
static const Float32_t s_dev_tab_tar_yaw_rate_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.05F*0.017453293F,  0.05F*0.017453293F,  0.05F*0.017453293F,  0.10F*0.017453293F,  0.15F*0.017453293F,
  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,
  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,
  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,
  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,  0.20F*0.017453293F,
};
#else
static const Float32_t s_dev_tab_tar_yaw_rate_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.10F*0.017453293F,  0.10F*0.017453293F,  0.15F*0.017453293F,  0.20F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
};
#endif
/* k001 pengc 2023-12-01 (end) */

// 角速度误差补偿Fuzzy Table
// 误差等级表(误差左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_yaw_rate_err_level[LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1] = {
/*             0                   1                     2                   3                   4              */
/*   0                     1                  2                    3                 4                     5    */
/* 负大5       ][         负大4     ][        负大3        ][       负大2       ][     负大1        ][       负大   */
        -3.00*0.017453293F, -2.50*0.017453293F, -2.00*0.017453293F, -1.50*0.017453293F, -1.00*0.017453293F,
/*             5                   6                     7                   8                   9                  10                  11             */
/*   5                     6                  7                    8                 9                     10                 11                   12  */
/* 负大        ][         负中      ][        负小         ][       负零        ][     正零         ][       正小       ][       正中       ][         正大  */
        -0.75*0.017453293F, -0.50*0.017453293F, -0.25*0.017453293F, +0.00*0.017453293F, +0.25*0.017453293F, +0.50*0.017453293F, +0.75*0.017453293F,
/*             12                  13                    14                  15                  16              */
/*   12                    13                 14                   15                16                    17    */
/* 正大        ][         正大1     ][        正大2        ][       正大3       ][     正大4        ][       正大5 */
        +1.00*0.017453293F, +1.50*0.017453293F, +2.00*0.017453293F, +2.50*0.017453293F, 3.00*0.017453293F
};

// 角速度变化速度(误差变化速度左正右负, 等级从负大到正大排列)
static const Float32_t s_tab_yaw_rate_spd_level[LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1] = {
/*             0                   1                     2                   3                   4              */
/*   0                     1                  2                    3                 4                     5    */
/* 负大5       ][         负大4     ][        负大3        ][       负大2       ][     负大1        ][       负大   */
        -3.00*0.017453293F, -2.50*0.017453293F, -2.00*0.017453293F, -1.50*0.017453293F, -1.00*0.017453293F,
/*             5                   6                     7                   8                   9                  10                  11             */
/*   5                     6                  7                    8                 9                     10                 11                   12  */
/* 负大        ][         负中      ][        负小         ][       负零        ][     正零         ][       正小       ][       正中       ][         正大  */
        -0.75*0.017453293F, -0.50*0.017453293F, -0.25*0.017453293F, +0.00*0.017453293F, +0.25*0.017453293F, +0.50*0.017453293F, +0.75*0.017453293F,
/*             12                  13                    14                  15                  16              */
/*   12                    13                 14                   15                16                    17    */
/* 正大        ][         正大1     ][        正大2        ][       正大3       ][     正大4        ][       正大5 */
        +1.00*0.017453293F, +1.50*0.017453293F, +2.00*0.017453293F, +2.50*0.017453293F, 3.00*0.017453293F
};

// 角速度误差补偿系数表
// P
static const Float32_t s_p_gain_tab_yaw_rate_err_feed[LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE] = {
  /*                       0       1       2       3       4        5       6       7       8        9       10      11      12       13      14      15      16      17      */
  /*   向右移动  */ /*速度: 负大5    负大4   负大3    负大2   负大1      负大     负中    负小    负零       正零    正小     正中     正大     正大1    正大2   正大3    正大4    正大5   */ /* 向左移动 */
  /* 偏差 负大5  NB  0 */ +0.000, +0.900, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800, +1.800,
  /* 偏差 负大4  NB  1 */ +0.000, +0.900, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800, +1.800,
  /* 偏差 负大3  NB  2 */ +0.000, +0.900, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800, +1.800,
  /* 偏差 负大2  NB  3 */ +0.000, +0.900, +1.800, +2.100, +2.500,  +2.500, +2.500, +2.500, +2.500,   +2.500, +2.500, +2.500, +2.500,  +2.500, +2.500, +2.500, +2.500, +2.500,
  /* 偏差 负大1  NB  4 */ +0.000, +0.900, +1.800, +2.500, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200, +3.200,
                                                                                                                                                                          
  /* 偏差 负大   NB  5 */ +0.000, +0.900, +1.800, +2.500, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200, +3.200,
  /* 偏差 负中   NM  6 */ +0.000, +0.900, +1.800, +2.500, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200, +3.200,
  /* 偏差 负小   NS  7 */ +0.000, +0.900, +1.800, +2.500, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200, +3.200,
  /* 偏差 负零   NZ  8 */ +0.000, +0.900, +1.800, +2.500, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200, +3.200,
                                                                                                                                                                          
  /* 偏差 正零   PZ  9 */ +3.200, +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +2.500, +1.800, +0.900, +0.000,
  /* 偏差 正小   PS 10 */ +3.200, +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +2.500, +1.800, +0.900, +0.000,
  /* 偏差 正中   PM 11 */ +3.200, +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +2.500, +1.800, +0.900, +0.000,
  /* 偏差 正大   PB 12 */ +3.200, +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +2.500, +1.800, +0.900, +0.000,
                                                                                                                                                                          
  /* 偏差 正大1  PB 13 */ +3.200, +3.200, +3.200, +3.200, +3.200,  +3.200, +3.200, +3.200, +3.200,   +3.200, +3.200, +3.200, +3.200,  +3.200, +2.500, +1.800, +0.900, +0.000,
  /* 偏差 正大2  PB 14 */ +2.500, +2.500, +2.500, +2.500, +2.500,  +2.500, +2.500, +2.500, +2.500,   +2.500, +2.500, +2.500, +2.500,  +2.500, +2.100, +1.800, +0.900, +0.000,
  /* 偏差 正大3  PB 15 */ +1.800, +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +0.900, +0.000,
  /* 偏差 正大4  PB 16 */ +1.800, +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +0.900, +0.000,
  /* 偏差 正大5  PB 17 */ +1.800, +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +1.800,   +1.800, +1.800, +1.800, +1.800,  +1.800, +1.800, +1.800, +0.900, +0.000,
};

// I
static const Float32_t s_i_gain_tab_yaw_rate_err_feed[LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE] = {
  /*                       0       1       2       3       4        5       6       7       8        9       10      11      12       13      14      15      16      17      */
  /*   向右移动  */ /*速度: 负大5    负大4   负大3    负大2   负大1      负大     负中    负小    负零       正零    正小     正中     正大     正大1    正大2   正大3    正大4    正大5   */ /* 向左移动 */
  /* 偏差 负大5  NB  0 */ +0.000, +0.000, +0.000, -0.100, -0.100,  +0.000, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.150,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负大4  NB  1 */ +0.000, +0.000, +0.000, -0.100, -0.100,  +0.000, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.150,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负大3  NB  2 */ +0.000, +0.000, +0.000, -0.100, -0.100,  +0.000, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.150,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负大2  NB  3 */ +0.000, +0.000, +0.000, -0.100, -0.100,  +0.000, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.150,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负大1  NB  4 */ +0.000, +0.000, +0.000, -0.100, -0.100,  +0.000, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.150,  +0.000, +0.000, +0.000, +0.000, +0.000,
                                                                                                                                                                          
  /* 偏差 负大   NB  5 */ +0.000, +0.000, +0.000, -0.100, -0.100,  -0.100, +0.000, +0.150, +0.150,   +0.150, +0.200, +0.200, +0.200,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负中   NM  6 */ +0.000, +0.000, +0.000, -0.100, -0.100,  -0.100, -0.100, +0.150, +0.150,   +0.150, +0.200, +0.200, +0.200,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负小   NS  7 */ +0.000, +0.000, +0.000, -0.150, -0.150,  -0.150, -0.100, +0.050, +0.150,   +0.200, +0.250, +0.250, +0.250,  +0.000, +0.000, +0.000, +0.000, +0.000,
  /* 偏差 负零   NZ  8 */ +0.000, +0.000, +0.000, -0.150, -0.150,  -0.150, -0.150, -0.100, +0.000,   +0.200, +0.250, +0.250, +0.250,  +0.000, +0.000, +0.000, +0.000, +0.000,
                                                                                                                                                                          
  /* 偏差 正零   PZ  9 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.250, +0.250, +0.250, +0.200,   +0.000, -0.100, -0.150, -0.150,  -0.150, -0.150, +0.000, +0.000, +0.000,
  /* 偏差 正小   PS 10 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.250, +0.250, +0.250, +0.200,   +0.150, +0.050, -0.100, -0.150,  -0.150, -0.150, +0.000, +0.000, +0.000,
  /* 偏差 正中   PM 11 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.200, +0.200, +0.200, +0.200,   +0.150, +0.150, -0.100, -0.100,  -0.100, -0.100, +0.000, +0.000, +0.000,
  /* 偏差 正大   PB 12 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.200, +0.200, +0.200, +0.200,   +0.150, +0.150, +0.000, -0.100,  -0.100, -0.100, +0.000, +0.000, +0.000,
                                                                                                                                                                          
  /* 偏差 正大1  PB 13 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.150, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.000,  -0.100, -0.100, +0.000, +0.000, +0.000,
  /* 偏差 正大2  PB 14 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.150, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.000,  -0.100, -0.100, +0.000, +0.000, +0.000,
  /* 偏差 正大3  PB 15 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.150, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.000,  -0.100, -0.100, +0.000, +0.000, +0.000,
  /* 偏差 正大4  PB 16 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.150, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.000,  -0.100, -0.100, +0.000, +0.000, +0.000,
  /* 偏差 正大5  PB 17 */ +0.000, +0.000, +0.000, +0.000, +0.000,  +0.150, +0.150, +0.150, +0.150,   +0.150, +0.150, +0.150, +0.000,  -0.100, -0.100, +0.000, +0.000, +0.000,
};

// D
static const Float32_t s_d_gain_tab_yaw_rate_err_feed[LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE] = {
  /*                       0       1       2       3       4        5       6       7       8        9       10      11      12       13      14      15      16      17      */
  /*   向右移动  */ /*速度: 负大5    负大4   负大3    负大2   负大1      负大     负中    负小    负零       正零    正小     正中     正大     正大1    正大2   正大3    正大4    正大5   */ /* 向左移动 */
  /* 偏差 负大5  NB  0 */ -2.100, -2.100, -2.100, -1.050, -0.000,  -0.000, -0.000, -0.000, -0.000,   -0.000, -0.700, -1.200, -1.700,  -2.100, -2.450, -2.800, -2.800, -2.800,
  /* 偏差 负大4  NB  1 */ -2.150, -2.150, -2.150, -1.150, -0.250,  -0.190, -0.130, -0.060, -0.000,   -0.000, -0.600, -1.100, -1.600,  -2.050, -2.400, -2.750, -2.750, -2.750,
  /* 偏差 负大3  NB  2 */ -2.200, -2.200, -2.200, -1.350, -0.500,  -0.380, -0.250, -0.130, -0.000,   -0.000, -0.500, -1.000, -1.500,  -2.000, -2.350, -2.700, -2.700, -2.700,
  /* 偏差 负大2  NB  3 */ -2.250, -2.250, -2.250, -1.480, -0.750,  -0.560, -0.380, -0.190, -0.000,   -0.000, -0.490, -0.960, -1.440,  -1.950, -2.300, -2.650, -2.650, -2.650,
  /* 偏差 负大1  NB  4 */ -2.300, -2.300, -2.300, -1.600, -1.000,  -0.750, -0.500, -0.250, -0.000,   -0.000, -0.480, -0.950, -1.430,  -1.900, -2.250, -2.600, -2.600, -2.600,
                                                                                                                                                                          
  /* 偏差 负大   NB  5 */ -2.400, -2.400, -2.400, -2.050, -1.700,  -1.300, -0.850, -0.430, -0.000,   -0.000, -0.450, -0.900, -1.350,  -1.800, -2.150, -2.500, -2.500, -2.500,
  /* 偏差 负中   NM  6 */ -2.400, -2.400, -2.400, -2.050, -1.700,  -1.300, -0.850, -0.430, -0.000,   -0.000, -0.450, -0.900, -1.350,  -1.800, -2.150, -2.500, -2.500, -2.500,
  /* 偏差 负小   NS  7 */ -2.400, -2.400, -2.400, -2.050, -2.000,  -2.000, -0.850, -0.430, -0.000,   -0.000, -0.450, -0.900, -2.000,  -2.000, -2.150, -2.500, -2.500, -2.500,
  /* 偏差 负零   NZ  8 */ -2.400, -2.400, -2.400, -2.050, -2.000,  -2.000, -0.850, -0.430, -0.000,   -0.000, -0.450, -0.900, -2.000,  -2.000, -2.150, -2.500, -2.500, -2.500,
                                                                                                                                                                          
  /* 偏差 正零   PZ  9 */ -2.500, -2.500, -2.500, -2.150, -2.000,  -2.000, -0.900, -0.450, -0.000,   -0.000, -0.430, -0.850, -2.000,  -2.000, -2.050, -2.400, -2.400, -2.400,
  /* 偏差 正小   PS 10 */ -2.500, -2.500, -2.500, -2.150, -2.000,  -2.000, -0.900, -0.450, -0.000,   -0.000, -0.430, -0.850, -2.000,  -2.000, -2.050, -2.400, -2.400, -2.400,
  /* 偏差 正中   PM 11 */ -2.500, -2.500, -2.500, -2.150, -1.800,  -1.350, -0.900, -0.450, -0.000,   -0.000, -0.430, -0.850, -1.300,  -1.700, -2.050, -2.400, -2.400, -2.400,
  /* 偏差 正大   PB 12 */ -2.500, -2.500, -2.500, -2.150, -1.800,  -1.350, -0.900, -0.450, -0.000,   -0.000, -0.430, -0.850, -1.300,  -1.700, -2.050, -2.400, -2.400, -2.400,
                                                                                                                                                                          
  /* 偏差 正大1  PB 13 */ -2.600, -2.600, -2.600, -2.250, -1.900,  -1.430, -0.950, -0.480, -0.000,   -0.000, -0.250, -0.500, -0.750,  -1.000, -1.600, -2.300, -2.300, -2.300,
  /* 偏差 正大2  PB 14 */ -2.650, -2.650, -2.650, -2.300, -1.950,  -1.440, -0.960, -0.490, -0.000,   -0.000, -0.190, -0.380, -0.560,  -0.750, -1.480, -2.250, -2.250, -2.250,
  /* 偏差 正大3  PB 15 */ -2.700, -2.700, -2.700, -2.350, -2.000,  -1.500, -1.000, -0.500, -0.000,   -0.000, -0.130, -0.250, -0.380,  -0.500, -1.350, -2.200, -2.200, -2.200,
  /* 偏差 正大4  PB 16 */ -2.750, -2.750, -2.750, -2.400, -2.050,  -1.600, -1.100, -0.600, -0.000,   -0.000, -0.060, -0.130, -0.190,  -0.250, -1.150, -2.150, -2.150, -2.150,
  /* 偏差 正大5  PB 17 */ -2.800, -2.800, -2.800, -2.450, -2.100,  -1.700, -1.200, -0.700, -0.000,   -0.000, -0.000, -0.000, -0.000,  -0.000, -1.050, -2.100, -2.100, -2.100,
};


/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          偏航角速度误差补偿 (End)                                      */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          转向不足补偿 (Begin)                                         */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
// 通过速度修正动态特性补偿(Key table & gain table)
static const Float32_t s_key_tab_dynamic_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F/3.6F,  10.0F/3.6F,  20.0F/3.6F,  30.0F/3.6F,  40.0F/3.6F,
   50.0F/3.6F,  60.0F/3.6F,  70.0F/3.6F,  80.0F/3.6F,  90.0F/3.6F,
  100.0F/3.6F, 110.0F/3.6F, 120.0F/3.6F, 130.0F/3.6F, 140.0F/3.6F,
  150.0F/3.6F, 160.0F/3.6F, 170.0F/3.6F, 180.0F/3.6F, 190.0F/3.6F,
  200.0F/3.6F, 210.0F/3.6F, 220.0F/3.6F, 230.0F/3.6F, 240.0F/3.6F
};
// Gain
static const Float32_t s_gain_tab_dynamic_feed_by_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.000F, 0.000F, 0.000F, 0.000F, 0.050F,
  0.090F, 0.130F, 0.130F, 0.120F, 0.120F,
  0.120F, 0.120F, 0.100F, 0.100F, 0.100F,
  0.100F, 0.100F, 0.100F, 0.100F, 0.100F,
  0.100F, 0.100F, 0.100F, 0.100F, 0.100F,
};

// 通过重量修正动态特性补偿(Key table & gain table)
static const Float32_t s_key_tab_dynamic_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
      0.0F, 10000.0F, 12000.0F, 14000.0F, 16000.0F,
  18000.0F, 20000.0F, 22000.0F, 24000.0F, 26000.0F,
  28000.0F, 30000.0F, 32000.0F, 34000.0F, 36000.0F,
  38000.0F, 40000.0F, 42000.0F, 44000.0F, 46000.0F,
  48000.0F, 50000.0F, 52000.0F, 56000.0F, 60000.0F
};

static const Float32_t s_gain_tab_dynamic_feed_by_weight[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.000F, 1.000F,
  1.000F, 1.000F, 1.000F, 1.100F, 1.100F,
  1.100F, 1.100F, 1.100F, 1.100F, 1.100F
};
/// 车辆动态特性补偿(end)
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          转向不足补偿 (End)                                           */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
/*          方向盘角度增益 (Begin)                                       */
/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>*/
// 通过方向盘角度修正角度增益(Key table & gain table)
static const Float32_t s_key_tab_steering_feed_by_angle[LAT_CTL_PID_LERP_TABLE_SIZE] = {
    0.0F,                1.0F*0.017453293F,   2.0F*0.017453293F,   3.0F*0.017453293F,   4.0F*0.017453293F,
    5.0F*0.017453293F,   6.0F*0.017453293F,   7.0F*0.017453293F,   8.0F*0.017453293F,   9.0F*0.017453293F,
   10.0F*0.017453293F,  15.0F*0.017453293F,  20.0F*0.017453293F,  30.0F*0.017453293F,  40.0F*0.017453293F,
   50.0F*0.017453293F,  60.0F*0.017453293F,  80.0F*0.017453293F, 100.0F*0.017453293F, 200.0F*0.017453293F,
  300.0F*0.017453293F, 400.0F*0.017453293F, 500.0F*0.017453293F, 600.0F*0.017453293F, 700.0F*0.017453293F,
};

// Gain
static const Float32_t s_gain_tab_steering_feed_by_angle[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.00F, 1.00F, 1.00F, 1.00F, 1.00F,
  1.00F, 1.00F, 1.00F, 1.00F, 1.00F,
  1.00F, 1.00F, 1.00F, 1.00F, 1.00F,
  1.00F, 1.00F, 1.00F, 1.00F, 1.00F,
  1.00F, 1.00F, 1.00F, 1.00F, 1.00F
};
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/*          方向盘角度增益 (End)                                         */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/


/******************************************************************************/
/* 内部函数                                                                    */
/******************************************************************************/

/*
 * @brief 计算两点间的平方距离(2D)
 * @param[in] x1 第一个点的x坐标
 * @param[in] y1 第一个点的y坐标
 * @param[in] x2 第二个点的x坐标
 * @param[in] y2 第二个点的y坐标
 * @return 平方距离
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcSquareDistBtwPoints(
    Float32_t x1, Float32_t y1, Float32_t x2, Float32_t y2) {
  Float32_t dx = x2 - x1;
  Float32_t dy = y2 - y1;

  return (dx*dx + dy*dy);
}

/*
 * @brief 计算两点间的内积(2D)
 * @param[in] x1 第一个点的x坐标
 * @param[in] y1 第一个点的y坐标
 * @param[in] x2 第二个点的x坐标
 * @param[in] y2 第二个点的y坐标
 * @return 内积
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcInnerProdBtwPoints(
    Float32_t x1, Float32_t y1, Float32_t x2, Float32_t y2) {
  return (x1 * x2 + y1 * y2);
}

/*
 * @brief 判断点P与有向线段AB之间的方位关系
 * @param[in] a 线段起点
 * @param[in] b 线段终点
 * @param[in] p 待判断的点
 * @return 0 ~ 三个点共线 \n
 *         1 ~ 点在线段左边 \n
 *         -1 ~ 点在线段右边
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Int32_t Orient_2D(
    const LatCtlPoint2d_t* a, const LatCtlPoint2d_t* b,
    const LatCtlPoint2d_t* p) {
  Float32_t orient = (a->x - p->x) * (b->y - p->y)
      - (a->y - p->y) * (b->x - p->x);

  if ((-1e-5F < orient) && (orient < 1e-5F)) {
    // the three points are collinear
    return (0);
  } else if (orient > 0.0F) {
    // p lies to the left of the directed line AB
    // the triangle ABC is oriented counterclockwise
    return (1);
  } else {
    // p lies to the right of the directed line AB
    // the triangle ABC is oriented clockwise
    return (-1);
  }
}

/*
 * @brief 计算线段AB上与点P的最近点
 * @param[in] a 线段起点
 * @param[in] b 线段终点
 * @param[in] p 待判断的点
 * @param[out] d 线段AB上与P点最近的点
 * @param[out] t 线段AB上与P点最近的点在线段AB上的比例值(范围[0, 1])
 * @par Note:
 * @code
 *     Given segment AB and point P, computes closest point D on AB.
 *     Also returns t for the parametric position of D, D(t) = A + t*(B - A)
 * @endcode
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ClosestPtPointToSeg_2D(
    const LatCtlPoint2d_t* a, const LatCtlPoint2d_t* b,
    const LatCtlPoint2d_t* p, LatCtlPoint2d_t* const d, Float32_t* const t) {
  LatCtlPoint2d_t v_ab;
  LatCtlPoint2d_t v_ap;
  v_ab.x = b->x - a->x;
  v_ab.y = b->y - a->y;
  v_ap.x = p->x - a->x;
  v_ap.y = p->y - a->y;
  // Project c onto ab, but deferring divide by Dot(ab, ab)
  *t = CalcInnerProdBtwPoints(v_ab.x, v_ab.y, v_ap.x, v_ap.y);
  if (*t <= 1e-5F) {
    // c projects outside the [a,b] interval, on the a side; clamp to a
    *t = 0.0F;
    *d = *a;
  } else {
    // Always nonnegative since denom = ||ab||^2
    Float32_t denom = v_ab.x * v_ab.x + v_ab.y * v_ab.y;
    if (*t >= denom) {
      // c projects outside the [a,b] interval, on the b side; clamp to b
      *t = 1.0F;
      *d = *b;
    } else {
      // c projects inside the [a,b] interval; must do deferred divide now
      *t = (*t) / denom;
      d->x = a->x + (*t) * v_ab.x;
      d->y = a->y + (*t) * v_ab.y;
    }
  }
}

/*
 * @brief 计算直线AB上与点P的最近点
 * @param[in] a 直线AB上的点A
 * @param[in] b 直线AB上的点B
 * @param[in] p 待判断的点
 * @param[out] d 直线AB上与P点最近的点
 * @param[out] t 直线AB上与P点最近的点在线段AB上的比例值
 * @par Note:
 * @code
 *     Given line AB and point P, computes closest point D on AB.
 *     Also returns t for the parametric position of D, D(t) = A + t*(B - A)
 * @endcode
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ClosestPtPointToLine_2D(
    const LatCtlPoint2d_t* a, const LatCtlPoint2d_t* b,
    const LatCtlPoint2d_t* p, LatCtlPoint2d_t* const d, Float32_t* const t) {
  LatCtlPoint2d_t v_ab;
  LatCtlPoint2d_t v_ap;
  v_ab.x = b->x - a->x;
  v_ab.y = b->y - a->y;
  v_ap.x = p->x - a->x;
  v_ap.y = p->y - a->y;
  // Project c onto ab, but deferring divide by Dot(ab, ab)
  *t = CalcInnerProdBtwPoints(v_ab.x, v_ab.y, v_ap.x, v_ap.y);

  // Always nonnegative since denom = ||ab||^2
  Float32_t denom = v_ab.x * v_ab.x + v_ab.y * v_ab.y;
  if (denom < 1e-5F) {
    *d = *a;
    *t = 0.0F;
    return;
  }

  *t = (*t) / denom;
  d->x = a->x + (*t) * v_ab.x;
  d->y = a->y + (*t) * v_ab.y;
}

/*
 * @brief 查找轨迹中与输入点最近的点
 * @param[in] p 待查询的点
 * @param[out] path_in 轨迹
 * @param[out] nearest 最近的点
 * @param[out] squared_dist 点与轨迹之间的平方距离
 * @param[out] nearest_index 最近的点在轨迹中的索引
 * @param[out] t 最近的点在轨迹中的比例值(最近的轨迹采样点)
 * @return     0 ~ 成功, others ~ 失败
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Int32_t FindNearestPointOnPath(
    const LatCtlPoint2d_t* p, const LatCtlTrajectory_t* path_in,
    LatCtlPoint2d_t* const nearest, Float32_t* const squared_dist,
    Int32_t* const nearest_index, Float32_t* const t) {
  Int32_t index = 0;
  Int32_t path_points_size = path_in->points_num;
  Float32_t tmp_t = 0.0F;
  Float32_t sq_dist = 0.0F;
  LatCtlPoint2d_t start_p;
  LatCtlPoint2d_t end_p;
  LatCtlPoint2d_t tmp_point;

  if ((path_points_size < 1) || (Nullptr_t == nearest)) {
    return (-1);
  }

  if (1 == path_points_size) {
    nearest->x = path_in->points[0].x;
    nearest->y = path_in->points[0].y;
    *squared_dist = CalcSquareDistBtwPoints(
          p->x, p->y, path_in->points[0].x, path_in->points[0].y);
    *nearest_index = 0;
    *t = 0.0F;
    return (-2);
  }

  *squared_dist = 9999999.0F;
  for (index = 0; index < (path_points_size - 1); ++index) {
    start_p.x = path_in->points[index].x;
    start_p.y = path_in->points[index].y;
    end_p.x = path_in->points[index+1].x;
    end_p.y = path_in->points[index+1].y;
    ClosestPtPointToSeg_2D(&start_p, &end_p, p, &tmp_point, &tmp_t);
    sq_dist = CalcSquareDistBtwPoints(p->x, p->y, tmp_point.x, tmp_point.y);
    if (sq_dist < (*squared_dist)) {
      *nearest = tmp_point;
      *squared_dist = sq_dist;
      *nearest_index = index;
      *t = tmp_t;
    }
  }

  return (0);
}

/*
 * @brief 获取点在路径的某一条线段所在直线上的投影点。
 * @param[in] p 待查询的点
 * @param[in] index_low 线段起点在路径点列中的索引
 * @param[out] path_in 轨迹
 * @param[out] path_point_out 点在路径的某一条线段所在直线上的投影点
 * @return     0 ~ 成功, others ~ 失败
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Int32_t GetSmoothPojectivePointOnSegmentOfPath(
    const LatCtlPoint2d_t* p, const Int32_t index_low,
    const LatCtlTrajectory_t* path_in,
    LatCtlPathPoint_t* const path_point_out) {
  static const Float32_t kMinSegDistWhenProjOutOfEnd = 2.0F;

  const Int32_t points_size_tmp = path_in->points_num;
  Int32_t orientation_on_path = 0;
  Int32_t next_index = 0;
  Float32_t t = 0.0F;
  Float32_t squared_dist = 0.0F;
  LatCtlPoint2d_t start_p;
  LatCtlPoint2d_t end_p;
  LatCtlPoint2d_t tmp_point;

  if ((index_low < 0) || (index_low > points_size_tmp - 2)) {
    return (-1);
  }

  start_p.x = path_in->points[index_low].x;
  start_p.y = path_in->points[index_low].y;
  end_p.x = path_in->points[index_low+1].x;
  end_p.y = path_in->points[index_low+1].y;
  ClosestPtPointToLine_2D(&start_p, &end_p, p, &tmp_point, &t);
  path_point_out->x = tmp_point.x;
  path_point_out->y = tmp_point.y;
  squared_dist = CalcSquareDistBtwPoints(p->x, p->y, tmp_point.x, tmp_point.y);
  orientation_on_path = Orient_2D(&start_p, &end_p, p);

  if ((index_low < 1) && (t < 0.0F)) {
    // before start point of path
    if (path_in->points[1].s > kMinSegDistWhenProjOutOfEnd) {
      path_point_out->h = path_in->points[0].h;
      path_point_out->c = path_in->points[0].c;
      path_point_out->s = t * path_in->points[1].s;
    } else {
      next_index = 1;
      for (; next_index < (points_size_tmp-1); ++next_index) {
        if (path_in->points[next_index].s > kMinSegDistWhenProjOutOfEnd) {
          break;
        }
      }

      start_p.x = path_in->points[0].x;
      start_p.y = path_in->points[0].y;
      end_p.x = path_in->points[next_index].x;
      end_p.y = path_in->points[next_index].y;
      ClosestPtPointToLine_2D(&start_p, &end_p, p, &tmp_point, &t);
      path_point_out->x = tmp_point.x;
      path_point_out->y = tmp_point.y;
      squared_dist = CalcSquareDistBtwPoints(
            p->x, p->y, tmp_point.x, tmp_point.y);
      orientation_on_path = Orient_2D(&start_p, &end_p, p);

      path_point_out->h =
          phoenix_com_atan2_f(end_p.y - start_p.y, end_p.x - start_p.x);
      path_point_out->c = path_in->points[0].c;
      path_point_out->s = t * path_in->points[next_index].s;
    }
  } else if ((index_low >= (points_size_tmp-2)) && (t > 1.0F)) {
    // after end point of path
    if ((path_in->points[points_size_tmp-1].s -
         path_in->points[points_size_tmp-2].s) > kMinSegDistWhenProjOutOfEnd) {
      path_point_out->h = path_in->points[points_size_tmp-1].h;
      path_point_out->c = path_in->points[points_size_tmp-1].c;
      path_point_out->s = path_in->points[index_low].s +
          t * (path_in->points[index_low + 1].s - path_in->points[index_low].s);
    } else {
      next_index = points_size_tmp-2;
      for (; next_index > 0; --next_index) {
        if ((path_in->points[points_size_tmp-1].s -
             path_in->points[next_index].s) > kMinSegDistWhenProjOutOfEnd) {
          break;
        }
      }
      start_p.x = path_in->points[next_index].x;
      start_p.y = path_in->points[next_index].y;
      end_p.x = path_in->points[points_size_tmp-1].x;
      end_p.y = path_in->points[points_size_tmp-1].y;
      ClosestPtPointToLine_2D(&start_p, &end_p, p, &tmp_point, &t);
      path_point_out->x = tmp_point.x;
      path_point_out->y = tmp_point.y;
      squared_dist = CalcSquareDistBtwPoints(
            p->x, p->y, tmp_point.x, tmp_point.y);
      orientation_on_path = Orient_2D(&start_p, &end_p, p);

      path_point_out->h =
          phoenix_com_atan2_f(end_p.y - start_p.y, end_p.x - start_p.x);
      path_point_out->c = path_in->points[points_size_tmp-1].c;
      path_point_out->s = path_in->points[next_index].s +
          t * (path_in->points[points_size_tmp-1].s -
          path_in->points[next_index].s);
    }
  } else {
    path_point_out->s = path_in->points[index_low].s +
        t * (path_in->points[index_low + 1].s - path_in->points[index_low].s);

    if (((path_point_out->s - path_in->points[index_low].s) > 2.0F) &&
       ((path_in->points[index_low+1].s - path_point_out->s) > 2.0F)) {
      path_point_out->h = path_in->points[index_low].h;
      path_point_out->c = path_in->points[index_low].c;
    } else {
      path_point_out->h = Phoenix_Common_AngleLerp_f(
            path_in->points[index_low].h, path_in->points[index_low + 1].h, t);
      path_point_out->c = (1.0F - t) * path_in->points[index_low].c +
          t * path_in->points[index_low + 1].c;
    }
  }

  if (orientation_on_path < 0) {
    // right side
    path_point_out->l = -phoenix_com_sqrt_f(squared_dist);
  } else {
    // left side
    path_point_out->l = phoenix_com_sqrt_f(squared_dist);
  }

  return (0);
}

/*
 * @brief 查找输入点在轨迹中的投影点
 * @param[in] p 待查询的点
 * @param[out] path_in 轨迹
 * @param[out] path_point_projection 投影点
 * @return     0 ~ 成功, others ~ 失败
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Int32_t FindProjection(
    const LatCtlPoint2d_t* p, const LatCtlTrajectory_t* path_in,
    LatCtlPathPoint_t* const path_point_projection) {
  const Int32_t points_size_tmp = path_in->points_num;
  Int32_t index = 0;
  Float32_t t = 0.0F;
  Float32_t squared_dist = 0.0F;
  LatCtlPoint2d_t nearest_p;

  if (points_size_tmp < 2) {
    return (-1);
  }

  if (FindNearestPointOnPath(p, path_in, &nearest_p,
                             &squared_dist, &index, &t) < 0) {
    return (-2);
  }
  path_point_projection->x = nearest_p.x;
  path_point_projection->y = nearest_p.y;

  if ((index < 0) || (index > (points_size_tmp - 2))) {
    return (-3);
  }

  return (GetSmoothPojectivePointOnSegmentOfPath(
            p, index, path_in, path_point_projection));
}

/*
 * @brief 查找路径上与路径长对应的点
 * @param[in] s 路径长
 * @param[out] path_in 轨迹
 * @param[out] path_point_out 路径上与路径长对应的点
 * @param[out] low_index 路径中与路径长对应的点的索引
 * @return     0 ~ 成功, others ~ 失败
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Int32_t FindSmoothPoint(
    Float32_t s, const LatCtlTrajectory_t* path_in,
    LatCtlPathPoint_t * const path_point_out, Int32_t * const low_index) {
  static const Float32_t kMinSegDistWhenProjOutOfEnd = 2.0F;
  Int32_t path_points_num = path_in->points_num;
  Int32_t first = 0;
  Int32_t mid = 0;
  Int32_t half = 0;
  Int32_t len = path_points_num;
  Int32_t index = 0;
  Float32_t delta_s = 0.0F;
  Float32_t t = 0.0F;

  // 路径上点过少时
  if (path_points_num < 2) {
    path_point_out->x = path_in->points[0].x;
    path_point_out->y = path_in->points[0].y;
    path_point_out->h = 0.0F;
    path_point_out->c = 0.0F;
    path_point_out->s = 0.0F;
    path_point_out->l = 0.0F;

    *low_index = 0;
    return (-1);
  }

  // 待查找点的弧长小于0时
  if (s < 0.0F) {
    path_point_out->x = path_in->points[0].x;
    path_point_out->y = path_in->points[0].y;
    path_point_out->h = path_in->points[0].h;
    path_point_out->c = path_in->points[0].c;
    path_point_out->s = s;
    path_point_out->l = 0.0F;

    index = 1;
    for (; index < (path_points_num-1); ++index) {
      if (path_in->points[index].s > kMinSegDistWhenProjOutOfEnd) {
        break;
      }
    }

    t = s / (path_in->points[index].s - path_in->points[0].s);

    path_point_out->x =
        (1.0F - t) * path_in->points[0].x + t * path_in->points[index].x;
    path_point_out->y =
        (1.0F - t) * path_in->points[0].y + t * path_in->points[index].y;
    path_point_out->h =
        phoenix_com_atan2_f(path_in->points[index].y - path_in->points[0].y,
        path_in->points[index].x - path_in->points[0].x);

    *low_index = 0;
    return (0);
  }

  // 待查找点的弧长大于路径总长度时
  if (s > path_in->points[path_points_num-1].s) {
    path_point_out->x = path_in->points[path_points_num-1].x;
    path_point_out->y = path_in->points[path_points_num-1].y;
    path_point_out->h = path_in->points[path_points_num-1].h;
    path_point_out->c = path_in->points[path_points_num-1].c;
    path_point_out->s = path_in->points[path_points_num-1].s;
    path_point_out->l = 0.0F;

    index = path_points_num-2;
    for (; index > 0; --index) {
      if ((path_in->points[path_points_num-1].s -
           path_in->points[index].s) > kMinSegDistWhenProjOutOfEnd) {
        break;
      }
    }

    t = (s - path_in->points[index].s) /
        (path_in->points[path_points_num-1].s - path_in->points[index].s);

    path_point_out->x =
        (1.0F - t) * path_in->points[index].x +
        t * path_in->points[path_points_num-1].x;
    path_point_out->y =
        (1.0F - t) * path_in->points[index].y +
        t * path_in->points[path_points_num-1].y;
    path_point_out->h =
        phoenix_com_atan2_f(
          path_in->points[path_points_num-1].y - path_in->points[index].y,
          path_in->points[path_points_num-1].x - path_in->points[index].x);

    *low_index = path_points_num - 2;
    if (*low_index < 0) {
      *low_index = 0;
    }
    return (0);
  }

  // 查找待查找点所在路径上的线段的终点的索引
  first = 0;
  mid = 0;
  half = 0;
  len = path_points_num;
  while (len > 0) {
    half = len >> 1;
    mid = first + half;
    if (s > path_in->points[mid].s) {
      first = mid + 1;
      // 在右边子序列中查找
      len = len - half - 1;
    } else {
      // 在左边子序列（包含mid）中查找
      len = half;
    }
  }
  index = first;

  if (index > (path_points_num - 1)) {
    path_point_out->x = path_in->points[path_points_num-1].x;
    path_point_out->y = path_in->points[path_points_num-1].y;
    path_point_out->h = path_in->points[path_points_num-1].h;
    path_point_out->c = path_in->points[path_points_num-1].c;
    path_point_out->s = path_in->points[path_points_num-1].s;
    path_point_out->l = 0.0F;

    *low_index = path_points_num - 2;
    if (*low_index < 0) {
      *low_index = 0;
    }
    return (0);
  }
  delta_s = path_in->points[index].s - s;
  // 待查找点与线段的终点重合时
  if ((0 == index) || (delta_s < 1e-4F)) {
    path_point_out->x = path_in->points[index].x;
    path_point_out->y = path_in->points[index].y;
    path_point_out->h = path_in->points[index].h;
    path_point_out->c = path_in->points[index].c;
    path_point_out->s = path_in->points[index].s;
    path_point_out->l = 0.0F;

    *low_index = index - 1;
    if (*low_index < 0) {
      *low_index = 0;
    }
    return (0);
  }

  // 待查找点在线段的中间时
  t = (s - path_in->points[index-1].s)
      / (path_in->points[index].s - path_in->points[index-1].s);
  path_point_out->x =
      (1.0F - t) * path_in->points[index-1].x + t * path_in->points[index].x;
  path_point_out->y =
      (1.0F - t) * path_in->points[index-1].y + t * path_in->points[index].y;
  path_point_out->s = s;
  path_point_out->l = 0.0F;

  *low_index = index - 1;

  if (((s - path_in->points[index-1].s) > 2.0F) &&
      ((path_in->points[index].s - s) > 2.0F)) {
    // 待查找点在一条很长的路径的线段中间，直接以这条线段的起点的航向角和曲率
    // 作为待查找点的航向角和曲率。
    // 这样做的原因是线段长度变大时，插值误差会变大，尤其是该线段的起点为直道，
    // 终点为弯道的情况。
    path_point_out->h = path_in->points[index-1].h;
    path_point_out->c = path_in->points[index-1].c;
  } else {
    path_point_out->h =
        Phoenix_Common_AngleLerp_f(path_in->points[index-1].h,
        path_in->points[index].h, t);
    path_point_out->c = (1.0F - t) * path_in->points[index-1].c +
        t * path_in->points[index].c;
  }

  return (0);
}


/*
 * @brief 初始化横向控制RC滤波器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/10/16  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static  void InitializeLatCtlRCLowPassFilter(LatCtlRCLowPassFilterInstance_t* const instance) {
  phoenix_com_memset(instance, 0, sizeof(LatCtlRCLowPassFilterInstance_t));
}

/*
 * @brief 设置横向控制RC滤波器参数
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/10/16  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ChangeLatCtlRCLowPassFilterParam(
    LatCtlRCLowPassFilterInstance_t* const instance, Float32_t decay, Int32_t delay_setting) {
  if (decay > 1.0F) {
    decay = 1.0F;
  } else if (decay < 0.0F) {
    decay = 0.0F;
  } else {
    // nothing to do
  }

  if (delay_setting < 1) {
    instance->delay_setting = 0;
    instance->tar_decay_ratio = decay;
    instance->cur_decay_ratio = decay;
  } else {
    instance->delay_setting = delay_setting;
    instance->tar_decay_ratio = decay;
  }
}

/*
 * @brief 更新横向控制RC滤波器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/10/16  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t UpdateLatCtlRCLowPassFilter(
    LatCtlRCLowPassFilterInstance_t* const instance, Float32_t input_value) {
  if (instance->delay_setting > 0) {
    instance->delay_setting--;
    if (instance->delay_setting < 1) {
      instance->cur_decay_ratio = instance->tar_decay_ratio;
    }
  }

  instance->output_value = 
      instance->cur_decay_ratio * instance->output_value +
      (1.0F - instance->cur_decay_ratio) * input_value;
  
  return (instance->output_value);
}


/*
 * @brief 初始化FFT变换
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/08/31  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void InitializeLatCtlFFT(LatCtlFFTInstance_t* const instance) {
  phoenix_com_memset(instance->data_buff, 0, sizeof(instance->data_buff));
  Phoenix_Com_RingBuffer_Init(
      &(instance->ring_buff), LAT_CTL_FFT_DATA_SIZE,
      sizeof(Float32_t), instance->data_buff);
  phoenix_com_memset(instance->rex, 0, sizeof(instance->rex));
  phoenix_com_memset(instance->imx, 0, sizeof(instance->imx));
  phoenix_com_memset(instance->mag, 0, sizeof(instance->mag));
  phoenix_com_memset(instance->pha, 0, sizeof(instance->pha));
}

/*
 * @brief FFT变换
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/08/31  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void FftForLatCtl(LatCtlFFTInstance_t* const instance, Float32_t new_data) {
  Int32_t idx = 0;
  RingBufferIterator_t ring_buff_it_begin;
  RingBufferIterator_t ring_buff_it_end;

  // Update yaw rate list
  Phoenix_Com_RingBuffer_PushBackOverride(
        &(instance->ring_buff), &(new_data));
  Phoenix_Com_RingBuffer_SetItToBegin(
        &(instance->ring_buff), &ring_buff_it_begin);
  Phoenix_Com_RingBuffer_SetItToEnd(
        &(instance->ring_buff), &ring_buff_it_end);
  idx = 0;
  phoenix_com_memset(instance->rex, 0, sizeof(instance->rex));
  phoenix_com_memset(instance->imx, 0, sizeof(instance->imx));
  while (Phoenix_Com_RingBufferIterator_IsNotEqual(
           &ring_buff_it_begin, &ring_buff_it_end)) {
    instance->rex[idx] =
        *(Float32_t*)Phoenix_Com_RingBufferIterator_GetCurrent(
          &ring_buff_it_begin);
    ++idx;

    Phoenix_Com_RingBufferIterator_Increase(&ring_buff_it_begin);
  }

#if 0
  printf("\n**************** UpdateLatHuntingDetector (begin) *************\n");
  // Check signals
  printf("The signals are:\n");
  for (Int32_t i = 0; i < LAT_CTL_FFT_SIZE; ++i) {
    printf("%0.4f ", phoenix_com_rad2deg_f(instance->rex[i]));
  }
  printf("\n");
#endif

  // Forward FFT
  Phoenix_Common_ForwardFFT_f(LAT_CTL_FFT_SIZE, instance->rex, instance->imx);

  // Calculate polar form
  for (idx = 0; idx < LAT_CTL_FFT_SIZE/2; ++idx) {
    // 计算幅值
    instance->mag[idx] =
        phoenix_com_sqrt_f(
          instance->rex[idx]*instance->rex[idx] +
          instance->imx[idx]*instance->imx[idx]);
    if (0 == idx) {
      instance->mag[idx] /= LAT_CTL_FFT_SIZE;
    } else {
      instance->mag[idx] /= LAT_CTL_FFT_SIZE/2;
    }

#if 1
    // 计算相位
    instance->pha[idx] = phoenix_com_atan2_f(
        instance->imx[idx]*instance->imx[idx], 
        instance->rex[idx]*instance->rex[idx]);
#endif
  }

#if 0
  // Check result of Forward FFT
  printf("\nAfter Forward FFT.\n");
  printf("The rex are:\n");
  for (Int32_t i = 0; i < LAT_CTL_FFT_SIZE; ++i) {
    printf("%0.4f ", phoenix_com_rad2deg_f(instance->rex[i]));
  }
  printf("\n");
  printf("The imx are:\n");
  for (Int32_t i = 0; i < LAT_CTL_FFT_SIZE; ++i) {
    printf("%0.4f ", phoenix_com_rad2deg_f(instance->imx[i]));
  }
  printf("\n");
#endif
#if 0
  printf("The magnitude are:\n");
  for (Int32_t i = 0; i < LAT_CTL_FFT_SIZE/2; ++i) {
    printf("%0.4f ", phoenix_com_rad2deg_f(instance->mag[i]));
  }
  printf("\n");
  printf("The phase are:\n");
  for (Int32_t i = 0; i < LAT_CTL_FFT_SIZE/2; ++i) {
    printf("%0.4f ", phoenix_com_rad2deg_f(instance->pha[i]));
  }
  printf("\n");
  printf("\n**************** UpdateLatHuntingDetector (end) ***************\n");
#endif
}

/*
 * @brief 初始化定时器
 * @param[in] instance 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/12/01  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void InitializeTimers(LatCtlPidInstance_t* const instance) {
  Phoenix_Com_Timer_Init(&(instance->timers.is_in_changing_lane), 0);
  Phoenix_Com_Timer_Init(&(instance->timers.smt_lat_spd_feed), 0);
  Phoenix_Com_Timer_Init(&(instance->timers.smt_yaw_err_feed), 0);
  Phoenix_Com_Timer_Init(&(instance->timers.smt_lat_err_feed), 0);
  Phoenix_Com_Timer_Init(&(instance->timers.smt_yaw_rate_err_feed), 0);
}

/*
 * @brief 更新定时器
 * @param[in] instance 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/12/01  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void UpdateTimers(LatCtlPidInstance_t* const instance) {
  Phoenix_Com_Timer_UpdateWithStamp(&(instance->timers.is_in_changing_lane), instance->timestamp);
  Phoenix_Com_Timer_UpdateWithStamp(&(instance->timers.smt_lat_spd_feed), instance->timestamp);
  Phoenix_Com_Timer_UpdateWithStamp(&(instance->timers.smt_yaw_err_feed), instance->timestamp);
  Phoenix_Com_Timer_UpdateWithStamp(&(instance->timers.smt_lat_err_feed), instance->timestamp);
  Phoenix_Com_Timer_UpdateWithStamp(&(instance->timers.smt_yaw_rate_err_feed), instance->timestamp);
}

/*
 * @brief 更新当前的状态
 * @param[in] instance 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/12/01  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void UpdateCurrentStatus(
    LatCtlPidInstance_t* const ins, const LatCtlDataSource_t* data) {
  ins->status.curr_eps_auto = data->chassis.eps_auto;
  ins->status.curr_trj_stat = data->planning_trj_status;

  ins->status.synthetic_lat_err =
      0.40F * data->lat_err.samples[0].lat_err +
      0.60F * data->lat_err.samples[1].lat_err;
  ins->status.synthetic_lat_spd =
      0.40F * data->lat_err.samples[0].lat_err_chg_rate +
      0.60F * data->lat_err.samples[1].lat_err_chg_rate;
  ins->status.synthetic_yaw_err = 
      0.40F * data->lat_err.samples[0].yaw_err +
      0.60F * data->lat_err.samples[1].yaw_err;
  ins->status.synthetic_yaw_spd = 
      0.40F * data->lat_err.samples[0].yaw_err_chg_rate +
      0.60F * data->lat_err.samples[1].yaw_err_chg_rate;
}

/*
 * @brief 更新之前的状态
 * @param[in] instance 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/12/01  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void UpdatePreviousStatus(
    LatCtlPidInstance_t* const ins, const LatCtlDataSource_t* data) {
  ins->status.prev_eps_auto = data->chassis.eps_auto;
  ins->status.prev_trj_stat = data->planning_trj_status;
}

/*
 * @brief 初始化向加速度的结构体
 * @param[in] acc_info  成员变量
 * @param[in] timestamp 时间戳
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void InitializeLatAccInfo(LatCtlLatAccInfo_t* acc_info, Int64_t timestamp) {
  acc_info->valid = 0;
  acc_info->timestamp = timestamp;
  acc_info->speed = 0;
  acc_info->prev_acc = 0;
  phoenix_com_memset(acc_info->acc_list, 0, sizeof(acc_info->acc_list));
}

/*
 * @brief 根据横向速度计算横向加速度
 * @param[in] acc_info 成员变量
 * @param[in] speed 横向速度
 * @param[in] timestamp 时间戳
 * @return 当前加速度
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t UpdateLatAccInfo(LatCtlLatAccInfo_t* acc_info, Float32_t speed, Int64_t timestamp) {
  Float32_t acceleration = 0.0f;
  Int64_t elapsed = 0;
  
  if (acc_info->valid) {
    elapsed = Phoenix_Common_CalcElapsedClockMs(acc_info->timestamp, timestamp);
	
    if ((200 <= elapsed) && (elapsed <= 400)) {
      acceleration = (speed - acc_info->speed) / elapsed * 1000;

      acc_info->acc_list[2] = acc_info->acc_list[1];
      acc_info->acc_list[1] = acc_info->acc_list[0];
      acceleration = 0.1F*acc_info->acc_list[2] +
          0.4F*acc_info->acc_list[1] + 0.5F*acceleration;
      acc_info->acc_list[0] = acceleration;

      acc_info->speed = speed;
      acc_info->prev_acc = acceleration;
      acc_info->timestamp = timestamp;
    } else if (elapsed > 400) {
      acc_info->speed = speed;
      acc_info->prev_acc = 0;
      acc_info->timestamp = timestamp;
    } else if (elapsed < 0) {
      acc_info->speed = speed;
      acc_info->prev_acc = 0;
      acc_info->timestamp = timestamp;
    } else {
      acceleration = acc_info->prev_acc;
    }
  } else {
    acc_info->speed = speed;
    acc_info->valid = 1;
    acc_info->prev_acc = 0;
    acc_info->timestamp = timestamp;
  }

  return (acceleration);
}

/*
 * @brief 初始化轨迹曲率信息的结构体
 * @param[in] ins  成员变量
 * @param[in] timestamp 时间戳
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void InitializeTrjCurvatureInfo(LatCtlTrjD1CurvatureInfo_t* ins, Int64_t timestamp) {
  ins->valid = 0;
  ins->timestamp = timestamp;
  ins->curvature = 0;
  ins->prev_d1_curvature = 0;
  phoenix_com_memset(ins->d1_curvature_list, 0, sizeof(ins->d1_curvature_list));
}

/*
 * @brief 计算曲率变化率
 * @param[in] ins 成员变量
 * @param[in] curvature 轨迹曲率
 * @param[in] timestamp 时间戳
 * @return 当前曲率变化率
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t UpdateTrjCurvatureInfo(LatCtlTrjD1CurvatureInfo_t* ins, Float32_t curvature, Int64_t timestamp) {
  Float32_t d1_curvature = 0.0f;
  Int64_t elapsed = 0;
  
  if (ins->valid) {
    elapsed = Phoenix_Common_CalcElapsedClockMs(ins->timestamp, timestamp);
	
    if ((500 <= elapsed) && (elapsed <= 600)) {
      d1_curvature = (curvature - ins->curvature) * 1000 / elapsed;

      ins->d1_curvature_list[2] = ins->d1_curvature_list[1];
      ins->d1_curvature_list[1] = ins->d1_curvature_list[0];
      d1_curvature = 0.1F*ins->d1_curvature_list[2] +
          0.4F*ins->d1_curvature_list[1] + 0.5F*d1_curvature;
      ins->d1_curvature_list[0] = d1_curvature;

      ins->curvature = curvature;
      ins->prev_d1_curvature = d1_curvature;
      ins->timestamp = timestamp;
    } else if (elapsed > 2000) {
      ins->curvature = curvature;
      ins->prev_d1_curvature = 0;
      ins->timestamp = timestamp;
    } else if (elapsed < 0) {
      ins->curvature = curvature;
      ins->prev_d1_curvature = 0;
      ins->timestamp = timestamp;
    } else {
      d1_curvature = ins->prev_d1_curvature;
    }
  } else {
    ins->curvature = curvature;
    ins->valid = 1;
    ins->prev_d1_curvature = 0;
    ins->timestamp = timestamp;
  }

  return (d1_curvature);
}

/*
 * @brief 根据目标轨迹计算前馈值
 * @param[in] instance 成员变量
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[in] cur_proj_on_trj 当前位置在目标轨迹中的投影点
 * @param[in] ref_trj_curvatrue 车道中心线的曲率
 * @param[in] tar_trj 目标轨迹
 * @param[out] status_info 内部状态信息
 * @return 前馈值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcFeedforwardValueFromTrajectory(
    LatCtlPidInstance_t* const instance,
    const LatCtlPos_t* cur_pos, const LatCtlPathPoint_t* cur_proj_on_trj,
    Float32_t ref_trj_curvatrue,
    const LatCtlTrajectory_t* tar_trj,
    LateralControlPidInfo_t* const status_info) {
  const Int32_t trj_points_num = tar_trj->points_num;
  Int32_t index = 0;
  Int32_t goal_point_index_near = -1;
  Int32_t goal_point_index_far = -1;
  Float32_t dist = 0.0F;
  Float32_t goal_dist = 0.0F;
  Float32_t goal_dist_near = 0.0F;
  Float32_t goal_dist_far = 0.0F;
  // Float32_t goal_dist_curvature_ratio = 1.0F;
  Float32_t goal_near_to_far_ratio = 0.0F;
  LatCtlPathPoint_t goal_point;
  LatCtlPathPoint_t goal_point_near;
  LatCtlPathPoint_t goal_point_far;
  Float32_t sin_cur_heading = 0.0F;
  Float32_t cos_cur_heading = 0.0F;
  Float32_t tmp_float = 0.0F;
  Float32_t tar_curvature = 0.0F;
  Float32_t tar_curvature_goal = 0.0F;
  Float32_t tar_curvature_near = 0.0F;
  Float32_t tar_curvature_far = 0.0F;
  // 通过速度修正预瞄距离
  Float32_t goal_dist_key_ratio = 0.0F;
  Int32_t goal_dist_key_index = Phoenix_Common_LerpInOrderedTable_f(
        instance->param.key_tab_crt_lead_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &goal_dist_key_ratio);
  Float32_t goal_dist_tgap = Phoenix_Common_Lerp_f(
        instance->param.tgap_tab_crt_lead_by_spd[goal_dist_key_index],
        instance->param.tgap_tab_crt_lead_by_spd[goal_dist_key_index+1],
        goal_dist_key_ratio);
  Float32_t goal_dist_near_tgap = Phoenix_Common_Lerp_f(
        instance->param.near_tgap_tab_crt_lead_by_spd[goal_dist_key_index],
        instance->param.near_tgap_tab_crt_lead_by_spd[goal_dist_key_index+1],
        goal_dist_key_ratio);
  Float32_t goal_dist_far_tgap = Phoenix_Common_Lerp_f(
        instance->param.far_tgap_tab_crt_lead_by_spd[goal_dist_key_index],
        instance->param.far_tgap_tab_crt_lead_by_spd[goal_dist_key_index+1],
        goal_dist_key_ratio);
  // 通过曲率修正预瞄距离
  Float32_t abs_trj_curvature = phoenix_com_abs_f(ref_trj_curvatrue);
  Float32_t key_ratio_crt_by_curvature = 0.0F;
  Int32_t key_idx_crt_by_curvature = Phoenix_Common_LerpInOrderedTable_f(
        instance->param.key_tab_crt_lead_by_curvature,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        abs_trj_curvature,
        &key_ratio_crt_by_curvature);
  Float32_t gain_crt_by_curvature = Phoenix_Common_Lerp_f(
        instance->param.gain_tab_crt_lead_by_curvature[key_idx_crt_by_curvature],
        instance->param.gain_tab_crt_lead_by_curvature[key_idx_crt_by_curvature+1],
        key_ratio_crt_by_curvature);

  if (trj_points_num < 2) {
    // Invalid trajectory
    LOG_ERR_C("[CTL][LatCtlPid] Invalid trajectory (number of points is too small).");
    return (0.0F);
  }

  // 限制最小的曲率增益值
  if (gain_crt_by_curvature < 0.5F) {
    gain_crt_by_curvature = 0.5F;
  }

  /* Find the goal point */
  goal_dist = gain_crt_by_curvature * goal_dist_tgap * cur_pos->v;
  if (goal_dist < instance->param.min_leading_len) {
    goal_dist = instance->param.min_leading_len;
  }
  goal_dist_near = gain_crt_by_curvature * goal_dist_near_tgap * cur_pos->v;
  if (goal_dist_near < instance->param.min_near_leading_len) {
    goal_dist_near = instance->param.min_near_leading_len;
  }
  goal_dist_far = gain_crt_by_curvature * goal_dist_far_tgap * cur_pos->v;
  if (goal_dist_far < instance->param.min_far_leading_len) {
    goal_dist_far = instance->param.min_far_leading_len;
  }

#if (ENABLE_LAT_CTL_PID_TRACE)
  printf("@@@ Trj_Feed: v=%0.1f, curvature=%0.4f"
         ", tgap=%0.2f, near_tgap=%0.2f, far_tgap=%0.2f"
         ", gain_crt_by_curvature=%0.2f"
         ", dist=%0.1f, near_dist=%0.1f, far_dist=%0.1f\n",
         cur_pos->v*3.6f, ref_trj_curvatrue,
         goal_dist_tgap, goal_dist_near_tgap, goal_dist_far_tgap,
         gain_crt_by_curvature,
         goal_dist, goal_dist_near, goal_dist_far);
#endif

  dist = 0.0F;
  goal_point_index_near = -1;
  goal_point_index_far = -1;

  if (FindSmoothPoint(goal_dist_near+cur_proj_on_trj->s, tar_trj,
                      &goal_point_near, &index) < 0) {
    // Invalid trajectory
    LOG_ERR_C("[CTL][LatCtlPid] Failed to find smooth point.");
    return (0.0F);
  }
  if (FindSmoothPoint(goal_dist_far+cur_proj_on_trj->s, tar_trj,
                      &goal_point_far, &index) < 0) {
    // Invalid trajectory
    LOG_ERR_C("[CTL][LatCtlPid] Failed to find smooth point.");
    return (0.0F);
  }

  if (goal_dist < goal_dist_near) {
    goal_dist = goal_dist_near;
  }
  if (goal_dist > goal_dist_far) {
    goal_dist = goal_dist_far;
  }
  if (goal_dist_far - goal_dist_near < 0.5F) {
    goal_near_to_far_ratio = 0.5F;
  } else {
    goal_near_to_far_ratio =
        (goal_dist - goal_dist_near) / (goal_dist_far - goal_dist_near);
  }

  status_info->trj_feed.goal_dist = goal_dist;
  status_info->trj_feed.goal_dist_near = goal_dist_near;
  status_info->trj_feed.goal_dist_far = goal_dist_far;
  status_info->trj_feed.cur_proj_on_trj.x = cur_proj_on_trj->x;
  status_info->trj_feed.cur_proj_on_trj.y = cur_proj_on_trj->y;
  status_info->trj_feed.cur_proj_on_trj.h = cur_proj_on_trj->h;
  status_info->trj_feed.cur_proj_on_trj.s = cur_proj_on_trj->s;
  status_info->trj_feed.goal_point_near.x = goal_point_near.x;
  status_info->trj_feed.goal_point_near.y = goal_point_near.y;
  status_info->trj_feed.goal_point_near.h = goal_point_near.h;
  status_info->trj_feed.goal_point_near.s = goal_point_near.s;
  status_info->trj_feed.goal_point_far.x = goal_point_far.x;
  status_info->trj_feed.goal_point_far.y = goal_point_far.y;
  status_info->trj_feed.goal_point_far.h = goal_point_far.h;
  status_info->trj_feed.goal_point_far.s = goal_point_far.s;

  if (FindSmoothPoint(goal_dist+cur_proj_on_trj->s, tar_trj,
                      &goal_point, &index) < 0) {
    // Invalid trajectory
    LOG_ERR_C("[CTL][LatCtlPid] Failed to find smooth point.");
    return (0.0F);
  }

  /* Transform the goal point to vehicle coordinates. */
  sin_cur_heading = phoenix_com_sin_f(cur_pos->heading);
  cos_cur_heading = phoenix_com_cos_f(cur_pos->heading);
  // goal
  goal_point.x -= cur_pos->x;
  goal_point.y -= cur_pos->y;
  goal_point.h = Phoenix_Common_AngleDiff_f(cur_pos->heading, goal_point.h);
  goal_point.s = goal_dist;
  tmp_float = cos_cur_heading * goal_point.x -
      sin_cur_heading * goal_point.y;
  goal_point.y = sin_cur_heading * goal_point.x +
      cos_cur_heading * goal_point.y;
  goal_point.x = tmp_float;
  // near
  goal_point_near.x -= cur_pos->x;
  goal_point_near.y -= cur_pos->y;
  goal_point_near.h = Phoenix_Common_AngleDiff_f(
        cur_pos->heading, goal_point_near.h);
  goal_point_near.s = goal_dist_near;
  tmp_float = cos_cur_heading * goal_point_near.x -
      sin_cur_heading * goal_point_near.y;
  goal_point_near.y = sin_cur_heading * goal_point_near.x +
      cos_cur_heading * goal_point_near.y;
  goal_point_near.x = tmp_float;
  // far
  goal_point_far.x -= cur_pos->x;
  goal_point_far.y -= cur_pos->y;
  goal_point_far.h = Phoenix_Common_AngleDiff_f(
        cur_pos->heading, goal_point_far.h);
  goal_point_far.s = goal_dist_far;
  tmp_float = cos_cur_heading * goal_point_far.x -
      sin_cur_heading * goal_point_far.y;
  goal_point_far.y = sin_cur_heading * goal_point_far.x +
      cos_cur_heading * goal_point_far.y;
  goal_point_far.x = tmp_float;

  /* Calculate the curvature to request the vehicle to set
     the steering to that curvature. */
  tar_curvature_goal =
      2.0F * goal_point.y /
      (goal_point.x * goal_point.x +
       goal_point.y * goal_point.y);
  tar_curvature_near =
      2.0F * goal_point_near.y /
      (goal_point_near.x * goal_point_near.x +
       goal_point_near.y * goal_point_near.y);
  tar_curvature_far =
      2.0F * goal_point_far.y /
      (goal_point_far.x * goal_point_far.x +
       goal_point_far.y * goal_point_far.y);
  tar_curvature = (1.0F - goal_near_to_far_ratio) * tar_curvature_near +
      goal_near_to_far_ratio * tar_curvature_far;


  status_info->trj_feed.feed_value_near = tar_curvature_near;
  status_info->trj_feed.feed_value_far = tar_curvature_far;
  status_info->trj_feed.feed_value = tar_curvature;

  return (tar_curvature);
}


/*
 * @brief 重置横向误差反馈补偿控制器
 * @param[in] ins 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ResetLatErrFeedController(
    LatCtlPidInstance_t* const ins) {
  Int32_t ret = 0;

  // Lat err
  phoenix_com_memset(&(ins->lat_err_feed), 0,
                     sizeof(ins->lat_err_feed));

  ret = Phoenix_Com_FuzzyPID_Init(
        &(ins->lat_err_feed.pid_controller),
        &(ins->param.tab_lat_err_level),
        &(ins->param.tab_lat_err_spd_level));
  if (ret < 0) {
    LOG_ERR_C("Failed to initialize lateral error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_err_feed.pid_controller), 0,
        &(ins->param.p_gain_tab_lat_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set P gain table of lateral error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_err_feed.pid_controller), 1,
        &(ins->param.i_gain_tab_lat_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set I gain table of lateral error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_err_feed.pid_controller), 2,
        &(ins->param.d_gain_tab_lat_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set D gain table of lateral error pid controller.");
    COM_CHECK_C(0 == ret);
  }

  phoenix_com_memset(
    ins->lat_err_feed.filter.lat_err_queue.data_buf, 0, 
    sizeof(ins->lat_err_feed.filter.lat_err_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->lat_err_feed.filter.lat_err_queue.ring_buf), LAT_CTL_AVG_LAT_ERR_LIST_SIZE,
      sizeof(Float32_t), ins->lat_err_feed.filter.lat_err_queue.data_buf);
}

/*
 * @brief 根据横向误差计算反馈补偿值
 * @param[in] ins 成员变量
 * @param[in] data_source 控制器所需要的数据
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[out] status_info 内部状态信息
 * @return 反馈补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void CalcFeedValueFromLatErr(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t timestamp = data_source->timestamp;
  Int64_t time_elapsed_ms = 0;
  Float32_t time_elapsed = 0.0F;

  // 轨迹变更方向
  Int32_t prev_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.prev_trj_stat);
  Int32_t curr_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.curr_trj_stat);

  // 误差及其变化率
  Float32_t lat_err = 0.0F;
  Float32_t lat_err_v = 0.0F;
  Float32_t abs_lat_err = 0.0F;
  Float32_t abs_lat_err_v = 0.0F;
  // PID 控制器
  FuzzyPID_t* lat_err_pid_controller = &(ins->lat_err_feed.pid_controller);
  // 误差及其变化率的等级索引
  Int32_t lat_err_lv_idx = 0;
  Int32_t lat_err_spd_lv_idx = 0;
  // 补偿值
  Float32_t kp_lat_err = 0.0F;
  Float32_t ki_lat_err = 0.0F;
  Float32_t kd_lat_err = 0.0F;
  Float32_t p_value_lat_err = 0.0F;
  Float32_t i_value_lat_err = 0.0F;
  Float32_t d_value_lat_err = 0.0F;
  Float32_t ret_p_value = 0.0F;
  Float32_t ret_i_value = 0.0F;
  Float32_t ret_d_value = 0.0F;
  // 根据速度修调补偿量
  Float32_t key_ratio_crt_by_spd = 0.0F;
  Int32_t key_idx_crt_by_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_crt_by_spd);
  Float32_t kp_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.p_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t ki_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t kd_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  // 根据重量修调补偿量
  // Float32_t weight = 10000.0F; // 空载(D17-B2)
  // Float32_t weight = 50000.0F; // 满载(D17-B2)
  Float32_t weight = data_source->chassis.gross_weight;
  Float32_t key_ratio_crt_by_wgt = 0.0F;
  Int32_t key_idx_crt_by_wgt = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_weight,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        weight,
        &key_ratio_crt_by_wgt);
  Float32_t kp_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.p_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t ki_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t kd_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  // 出现蛇形时，减小控制增益
  Float32_t hunting_gain_p = 1.0F;
  Float32_t hunting_gain_d = 1.0F;
  Float32_t hunting_gain_1 = ins->hunting_detector.yaw_rate.hunting_gain;
  Float32_t hunting_gain_2 = 1.0F;
  Int8_t is_in_changing_lane_stage_1 = 
      ((TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_LEFT_STAGE_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_RIGHT_STAGE_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_RIGHT_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_LEFT_I == data_source->planning_trj_status));
  Int8_t is_in_changing_lane_stage_2 = 
      ((TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_LEFT_STAGE_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_RIGHT_STAGE_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_RIGHT_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_LEFT_II == data_source->planning_trj_status));

  // 获取误差及其变化率
  lat_err = ins->status.synthetic_lat_err;
  lat_err_v = ins->status.synthetic_lat_spd;
  abs_lat_err = phoenix_com_abs_f(lat_err);
  abs_lat_err_v = phoenix_com_abs_f(lat_err_v);

  // 时间戳
  time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, timestamp);
  time_elapsed = 0.001F * time_elapsed_ms;

  if (is_in_changing_lane_stage_1 || is_in_changing_lane_stage_2) {
    Phoenix_Com_Timer_SetTimeout(&(ins->timers.is_in_changing_lane), 4*1000);
    Phoenix_Com_Timer_Restart(&(ins->timers.is_in_changing_lane));
  }

  // 检测突变, 避免过大的方向盘调整
  if ((phoenix_com_abs_f(lat_err - ins->lat_err_feed.filter.lat_err) > 0.3F) ||                                         /* 误差突变       */
      ((0 == ins->status.prev_eps_auto) && (0 != ins->status.curr_eps_auto)) ||                                         /* 刚进入自动驾驶   */
      ((prev_path_dir == 0) && (curr_path_dir != 0)) ||                                                                 /* 变道或避让      */
      (((prev_path_dir < 0) && (curr_path_dir > 0)) || ((prev_path_dir > 0) && (curr_path_dir < 0)))                    /* 轨迹变化方向变更 */
     ) {
#if 0
    printf("!!!!!! Smooth lat_err_feed_gain: \n"
           "    prev_lat_err=%0.2f, curr_lat_err=%0.2f, err_diff=%0.2f\n"
           "    prev_eps_auto=%d, curr_eps_auto=%d\n"
           "    prev_path_dir=%d, curr_path_dir=%d\n",
           ins->lat_err_feed.filter.lat_err, lat_err, 
           lat_err - ins->lat_err_feed.filter.lat_err,
           ins->status.prev_eps_auto, ins->status.curr_eps_auto,
           prev_path_dir, curr_path_dir);
#endif
    Phoenix_Com_Timer_SetTimeout(&(ins->timers.smt_lat_err_feed), 2*1000);
    Phoenix_Com_Timer_Restart(&(ins->timers.smt_lat_err_feed));
  }

  // 近段时间横向误差平均值
  Float32_t avg_lat_err = ins->lat_err_feed.filter.avg_lat_err;
  if (!Phoenix_Com_Timer_IsActive(&(ins->timers.is_in_changing_lane))) {
    // 不统计变道过程中的误差
    if (Phoenix_Com_RingBuffer_IsFull(&(ins->lat_err_feed.filter.lat_err_queue.ring_buf))) {
      avg_lat_err = Phoenix_Com_Filter_MovingAverage_f(
          LAT_CTL_AVG_LAT_ERR_LIST_SIZE, LAT_CTL_AVG_LAT_ERR_LIST_SIZE, ins->lat_err_feed.filter.avg_lat_err, 
          lat_err, *(Float32_t*)Phoenix_Com_RingBuffer_GetFront(&(ins->lat_err_feed.filter.lat_err_queue.ring_buf)));
    } else {
      avg_lat_err = Phoenix_Com_Filter_MovingAverage_f(
          LAT_CTL_AVG_LAT_ERR_LIST_SIZE, Phoenix_Com_RingBuffer_GetSize(&(ins->lat_err_feed.filter.lat_err_queue.ring_buf)), 
          ins->lat_err_feed.filter.avg_lat_err, lat_err, 0.0F);
    }
    Phoenix_Com_RingBuffer_PushBackOverride(
          &(ins->lat_err_feed.filter.lat_err_queue.ring_buf), &(lat_err));
  }

  // 更新当前误差等级
  // 横向误差
  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(lat_err_pid_controller, lat_err, lat_err_v);
  lat_err_lv_idx = lat_err_pid_controller->err_level_idx_;
  lat_err_spd_lv_idx = lat_err_pid_controller->err_spd_level_idx_;

  // 计算当前PID增益
  // 横向误差
  kp_lat_err = Phoenix_Com_FuzzyPID_GetGain_f(lat_err_pid_controller, 0);
  ki_lat_err = Phoenix_Com_FuzzyPID_GetGain_f(lat_err_pid_controller, 1);
  kd_lat_err = Phoenix_Com_FuzzyPID_GetGain_f(lat_err_pid_controller, 2);
  p_value_lat_err = 1.0F * kp_lat_err * lat_err;
  i_value_lat_err = 1.0F * ki_lat_err * lat_err;
  d_value_lat_err = 1.0F * kd_lat_err * lat_err_v;

#if 0
  if (abs_lat_err_v > 0.2F) {
    d_value_lat_err = 0.5F * kd_lat_err * lat_err_v;
  } else {
    d_value_lat_err = 0.7F * kd_lat_err * lat_err_v;
  }
#endif

#if 0
  if (!Phoenix_Com_Timer_IsActive(&(ins->timers.is_in_changing_lane))) {
    Float32_t ext_i_ratio = phoenix_com_abs_f(avg_lat_err) * 2.0F;
    if (ext_i_ratio > 0.3F) {
      ext_i_ratio = 0.3F;
    }
    if ((i_value_lat_err > 0.0F) && (avg_lat_err < 0.0F)) {
      i_value_lat_err += i_value_lat_err * ext_i_ratio;
      printf("---> avg_err=%0.2f, exi_i_lat_err=%0.4f, ratio=%0.2f\n", 
          avg_lat_err, i_value_lat_err * ext_i_ratio * 57.3F, ext_i_ratio);
    } else if ((i_value_lat_err < 0.0F) && (avg_lat_err > 0.0F)) {
      i_value_lat_err += i_value_lat_err * ext_i_ratio;
      printf("---> avg_err=%0.2f, exi_i_lat_err=%0.4f, ratio=%0.2f\n", 
          avg_lat_err, i_value_lat_err * ext_i_ratio * 57.3F, ext_i_ratio);
    } else {
      // nothing to do
    }
  }
#endif

#if 0
  Float32_t ext_i_ratio = data_source->ref_trj_curvature * 600.0F;
  if ((data_source->ref_trj_curvature > 0.0001F) && (i_value_lat_err > 0.0F)) {
    i_value_lat_err += i_value_lat_err * ext_i_ratio;
    printf("---> curv=%0.4f, exi_i_lat_err=%0.4f, ratio=%0.2f\n", 
        data_source->ref_trj_curvature, i_value_lat_err * ext_i_ratio, ext_i_ratio);
  } else if ((data_source->ref_trj_curvature < -0.0001F) && (i_value_lat_err < 0.0F)) {
    i_value_lat_err -= i_value_lat_err * ext_i_ratio;
    printf("---> curv=%0.4f, exi_i_lat_err=%0.3f, ratio=%0.2f\n", 
        data_source->ref_trj_curvature, -i_value_lat_err * ext_i_ratio, ext_i_ratio);
  } else {
    // nothing to do
  }
#endif

  // 变道初始阶段不补偿
  if ((abs_lat_err > 1.0F) ||
      (is_in_changing_lane_stage_1) ||
      ((abs_lat_err > 1.0F) && (0 != data_source->lat_err.moving_flag) && 
       (!is_in_changing_lane_stage_2))
      ) {
    p_value_lat_err = 0.0F;
    i_value_lat_err = 0.0F;
    d_value_lat_err = 0.0F;
  }
  // 有突变时, 不补偿
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_err_feed))) {
    p_value_lat_err = 0.0F;
    i_value_lat_err = 0.0F;
    d_value_lat_err = 0.0F;
  }
  // 横向距离过大，不积分
  if (abs_lat_err > 1.0F) {
    i_value_lat_err = 0.0F;
  }
  // 变道过程中，不进行比例补偿
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.is_in_changing_lane))) {
    p_value_lat_err = 0.0F;
  }

  // 最终的补偿值
  ret_p_value = 
      ins->param.p_global_gain_lat_err_feed *  /* 误差补偿的全局增益P     */
      kp_crt_by_spd *                          /* 根据车速修调           */
      kp_crt_by_wgt *                          /* 根据重量修调           */
      p_value_lat_err;
  ret_i_value =
      ins->param.i_global_gain_lat_err_feed *  /* 误差补偿的全局增益I     */
      ki_crt_by_spd *                          /* 根据车速修调           */
      ki_crt_by_wgt *                          /* 根据重量修调           */
      i_value_lat_err;
  ret_d_value = 
      ins->param.d_global_gain_lat_err_feed *  /* 误差补偿的全局增益D     */
      kd_crt_by_spd *                          /* 根据车速修调           */
      kd_crt_by_wgt *                          /* 根据重量修调           */
      d_value_lat_err;

#if (HUNTING_SUPPRESS_MODE == HUNTING_SUPPRESS_MODE_I)
  // 蛇行抑制
  hunting_gain_2 = 
  Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
    &(ins->perf_ana.analyser), ret_p_value, data_source->cur_pos.v);
  hunting_gain_p = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(lat_err_p) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_p);
  ret_p_value *= hunting_gain_p;

  hunting_gain_2 = 
  Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
    &(ins->perf_ana.analyser), ret_d_value, data_source->cur_pos.v);
  hunting_gain_d = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(lat_err_d) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_d);
  ret_d_value *= hunting_gain_d;
#endif

  // 计算返回值
#if (LAT_FEED_BACK_CHG_LIMIT_MODE == LAT_FEED_BACK_CHG_LIMIT_MODE_I)
  // 限制补偿的增量
  Float32_t max_step_gain = 0.4F * 0.017453293F;
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_spd_feed))) {
    max_step_gain = 0.2F * 0.017453293F;
  }
  // P
  Float32_t p_value_diff = ret_p_value - ins->lat_err_feed.p_value;
  if (p_value_diff > max_step_gain) {
    ins->lat_err_feed.p_value = ins->lat_err_feed.p_value + max_step_gain;
  } else if (p_value_diff < -max_step_gain) {
    ins->lat_err_feed.p_value = ins->lat_err_feed.p_value - max_step_gain;
  } else {
    ins->lat_err_feed.p_value = ret_p_value;
  }
  // I
  ins->lat_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  Float32_t d_value_diff = ret_d_value - ins->lat_err_feed.d_value;
  if (d_value_diff > max_step_gain) {
    ins->lat_err_feed.d_value = ins->lat_err_feed.d_value + max_step_gain;
  } else if (d_value_diff < -max_step_gain) {
    ins->lat_err_feed.d_value = ins->lat_err_feed.d_value - max_step_gain;
  } else {
    ins->lat_err_feed.d_value = ret_d_value;
  }
#else
  // P
  ins->lat_err_feed.p_value = ret_p_value;
  // I
  ins->lat_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  ins->lat_err_feed.d_value = ret_d_value;
#endif

  // Lat err
  // 限制P的最大值
  static const Float32_t kMaxFeedValueP = 10.0F * 0.017453293F;
  if(ins->lat_err_feed.p_value > kMaxFeedValueP) {
    ins->lat_err_feed.p_value = kMaxFeedValueP;
  } else if(ins->lat_err_feed.p_value < -kMaxFeedValueP) {
    ins->lat_err_feed.p_value = -kMaxFeedValueP;
  } else {
    // nothing to do
  }
  // 限制I的最大值
  static const Float32_t kMaxFeedValueI = 0.4F * 0.017453293F;
  if (ins->lat_err_feed.i_value > kMaxFeedValueI) {
    ins->lat_err_feed.i_value = kMaxFeedValueI;
  } else if (ins->lat_err_feed.i_value < -kMaxFeedValueI) {
    ins->lat_err_feed.i_value = -kMaxFeedValueI;
  } else {
    // nothing to do
  }
  // 限制D的最大值
  static const Float32_t kMaxFeedValueD = 10.0F * 0.017453293F;
  if(ins->lat_err_feed.d_value > kMaxFeedValueD) {
    ins->lat_err_feed.d_value = kMaxFeedValueD;
  } else if (ins->lat_err_feed.d_value < -kMaxFeedValueD) {
    ins->lat_err_feed.d_value = -kMaxFeedValueD;
  } else {
    // nothing to do
  }

  // 保存滤波相关的量
  ins->lat_err_feed.filter.valid = 1;
  ins->lat_err_feed.filter.lat_err = lat_err;
  ins->lat_err_feed.filter.avg_lat_err = avg_lat_err;

//#if (ENABLE_LAT_CTL_PID_TRACE)
  printf("@@@@@ Lat_err_Feed: smt_flag=%d\n"
         "    lat_err{ [%0.2f, %0.2f], [%0.2f, %0.2f] }\n"
         "    v=%0.1f, w=%0.1f, lat_err=%0.2f, lat_err_v=%0.2f, err_idx=%d, spd_idx=%d\n",
         Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_err_feed)),
         data_source->lat_err.samples[0].lat_err, data_source->lat_err.samples[0].lat_err_chg_rate,
         data_source->lat_err.samples[1].lat_err, data_source->lat_err.samples[1].lat_err_chg_rate,
         cur_pos->v*3.6F, weight, lat_err, lat_err_v, lat_err_lv_idx, lat_err_spd_lv_idx);
  printf("    P: v_ratio=%0.4f, w_ratio=%0.4f, kp=%0.4f, p=%0.3f, p_value=%0.2f, h=%0.2f\n",
         kp_crt_by_spd, kp_crt_by_wgt, kp_lat_err, phoenix_com_rad2deg_f(p_value_lat_err),
         phoenix_com_rad2deg_f(ins->lat_err_feed.p_value), hunting_gain_p);
  printf("    I: v_ratio=%0.4f, w_ratio=%0.4f, ki=%0.4f, i=%0.3f, i_value=%0.2f\n",
         ki_crt_by_spd, ki_crt_by_wgt, ki_lat_err, phoenix_com_rad2deg_f(i_value_lat_err),
         phoenix_com_rad2deg_f(ins->lat_err_feed.i_value));
  printf("    D: v_ratio=%0.4f, w_ratio=%0.4f, kd=%0.4f, d=%0.3f, d_value=%0.2f, h=%0.2f\n",
         kd_crt_by_spd, kd_crt_by_wgt, kd_lat_err, phoenix_com_rad2deg_f(d_value_lat_err),
         phoenix_com_rad2deg_f(ins->lat_err_feed.d_value), hunting_gain_d);
//#endif

  // 更新调试信息
  // Lat err
  status_info->lat_err_feed.lat_err = lat_err;
  status_info->lat_err_feed.avg_lat_err = avg_lat_err;
  status_info->lat_err_feed.lat_err_spd = lat_err_v;
  status_info->lat_err_feed.lat_err_lv_idx = lat_err_lv_idx;
  status_info->lat_err_feed.lat_err_spd_lv_idx = lat_err_spd_lv_idx;
  status_info->lat_err_feed.p_feed.v_ratio = kp_crt_by_spd;
  status_info->lat_err_feed.p_feed.w_ratio = kp_crt_by_wgt;
  status_info->lat_err_feed.p_feed.k_ratio = kp_lat_err;
  status_info->lat_err_feed.p_feed.k_value = p_value_lat_err;
  status_info->lat_err_feed.p_feed.feed = ins->lat_err_feed.p_value;
  status_info->lat_err_feed.i_feed.v_ratio = ki_crt_by_spd;
  status_info->lat_err_feed.i_feed.w_ratio = ki_crt_by_wgt;
  status_info->lat_err_feed.i_feed.k_ratio = ki_lat_err;
  status_info->lat_err_feed.i_feed.k_value = i_value_lat_err;
  status_info->lat_err_feed.i_feed.feed = ins->lat_err_feed.i_value;
  status_info->lat_err_feed.d_feed.v_ratio = kd_crt_by_spd;
  status_info->lat_err_feed.d_feed.w_ratio = kd_crt_by_wgt;
  status_info->lat_err_feed.d_feed.k_ratio = kd_lat_err;
  status_info->lat_err_feed.d_feed.k_value = d_value_lat_err;
  status_info->lat_err_feed.d_feed.feed = ins->lat_err_feed.d_value;
  status_info->lat_err_feed.feed_value = ins->lat_err_feed.p_value + ins->lat_err_feed.d_value;
}

/*
 * @brief 重置横向误差速率反馈补偿控制器
 * @param[in] ins 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/04/08  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ResetLatSpdFeedController(
    LatCtlPidInstance_t* const ins) {
  Int32_t ret = 0;

  // Lat err speed
  phoenix_com_memset(&(ins->lat_spd_feed), 0,
                     sizeof(ins->lat_spd_feed));

  ret = Phoenix_Com_FuzzyPID_Init(
        &(ins->lat_spd_feed.pid_controller),
        &(ins->param.tab_lat_spd_err_level),
        &(ins->param.tab_lat_acc_level));
  if (ret < 0) {
    LOG_ERR_C("Failed to initialize lateral speed pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_spd_feed.pid_controller), 0,
        &(ins->param.p_gain_tab_lat_spd_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set P gain table of lateral speed pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_spd_feed.pid_controller), 1,
        &(ins->param.i_gain_tab_lat_spd_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set I gain table of lateral speed pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->lat_spd_feed.pid_controller), 2,
        &(ins->param.d_gain_tab_lat_spd_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set D gain table of lateral speed pid controller.");
    COM_CHECK_C(0 == ret);
  }

  phoenix_com_memset(
    ins->lat_spd_feed.filter.lat_acc_queue.data_buf, 0, 
    sizeof(ins->lat_spd_feed.filter.lat_acc_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->lat_spd_feed.filter.lat_acc_queue.ring_buf), LAT_CTL_D2_LAT_ERR_FILTER_WND_SIZE,
      sizeof(Float32_t), ins->lat_spd_feed.filter.lat_acc_queue.data_buf);
  ins->lat_spd_feed.filter.sum_tar_p_value = 0.0F;
  phoenix_com_memset(
    ins->lat_spd_feed.filter.tar_p_value_queue.data_buf, 0, 
    sizeof(ins->lat_spd_feed.filter.tar_p_value_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->lat_spd_feed.filter.tar_p_value_queue.ring_buf), LAT_CTL_LAT_SPD_FEED_ITG_WND_SIZE,
      sizeof(Float32_t), ins->lat_spd_feed.filter.tar_p_value_queue.data_buf);
  ins->lat_spd_feed.filter.sum_cur_p_value = 0.0F;
  phoenix_com_memset(
    ins->lat_spd_feed.filter.cur_p_value_queue.data_buf, 0, 
    sizeof(ins->lat_spd_feed.filter.cur_p_value_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->lat_spd_feed.filter.cur_p_value_queue.ring_buf), LAT_CTL_LAT_SPD_FEED_ITG_WND_SIZE,
      sizeof(Float32_t), ins->lat_spd_feed.filter.cur_p_value_queue.data_buf);
  InitializeLatAccInfo(&(ins->lat_spd_feed.filter.lat_acc_info), ins->timestamp);
}

/* k001 pengc 2023-11-07 (begin) */
/*
 * @brief 根据横向误差速率计算反馈补偿值
 * @param[in] ins 成员变量
 * @param[in] data_source 控制器所需要的数据
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[out] status_info 内部状态信息
 * @return 反馈补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023-11-07  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void CalcFeedValueFromLatSpd(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, data_source->timestamp);
  Float32_t time_elapsed = 0.001F * time_elapsed_ms;

  Float32_t lat_err = ins->status.synthetic_lat_err;
  Float32_t lat_spd = ins->status.synthetic_lat_spd;
  Float32_t abs_lat_err = phoenix_com_abs_f(lat_err);
  Float32_t abs_lat_spd = phoenix_com_abs_f(lat_spd);
  Float32_t hunting_gain_p = 1.0F;
  Float32_t hunting_gain_1 = ins->hunting_detector.yaw_rate.hunting_gain;
  Float32_t hunting_gain_2 = 1.0F;
  FuzzyPID_t* lat_spd_pid_controller = &(ins->lat_spd_feed.pid_controller);
  
  // 轨迹变更方向
  Int32_t prev_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.prev_trj_stat);
  Int32_t curr_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.curr_trj_stat);

  /// 使用误差补偿的修调参数
  // 根据速度修调补偿量
  Float32_t key_ratio_crt_by_spd = 0.0F;
  Int32_t key_idx_crt_by_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_crt_by_spd);
  Float32_t kp_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],      /// !!! 使用误差补偿的D增益修调表
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t ki_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t kd_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  // 根据重量修调补偿量
  Float32_t key_ratio_crt_by_wgt = 0.0F;
  Int32_t key_idx_crt_by_wgt = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_weight,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        data_source->chassis.gross_weight,
        &key_ratio_crt_by_wgt);
  Float32_t kp_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],    /// !!! 使用误差补偿的D增益修调表
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t ki_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t kd_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);

  Float32_t corrected_spd_err = 0.0F;
  Float32_t raw_lat_acc = 0.0F;
  Float32_t lat_acc = 0.0F;

  Float32_t key_ratio_tar_lat_spd = 0.0F;
  Int32_t key_idx_tar_lat_spd = 0;
  Float32_t tar_lat_spd_exp = 0.0F;  // expected speed
  Float32_t tar_lat_spd_dev = 0.0F;  // standard deviation
  Float32_t tar_lat_spd_up = 0.0F;
  Float32_t tar_lat_spd_dn = 0.0F;
  Int32_t feed_dir_flag = 0; // 横向速度误差调节方向标记

  Int32_t lat_spd_err_lv_idx = 0;
  Int32_t lat_acc_lv_idx = 0;
  Float32_t kp_lat_spd = 0.0F;
  Float32_t ki_lat_spd = 0.0F;
  Float32_t kd_lat_spd = 0.0F;
  Float32_t p_value_lat_spd = 0.0F;
  Float32_t i_value_lat_spd = 0.0F;
  Float32_t d_value_lat_spd = 0.0F;
  Float32_t ret_p_value = 0.0F;
  Float32_t ret_i_value = 0.0F;
  Float32_t ret_d_value = 0.0F;

  // 获取期望的横向速度
  key_ratio_tar_lat_spd = 0.0F;
  key_idx_tar_lat_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_tar_lat_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        /*phoenix_com_abs_f(smt_lat_err),*/abs_lat_err,
        &key_ratio_tar_lat_spd);
  tar_lat_spd_exp = Phoenix_Common_Lerp_f(
        ins->param.exp_tab_tar_lat_spd[key_idx_tar_lat_spd],
        ins->param.exp_tab_tar_lat_spd[key_idx_tar_lat_spd+1],
        key_ratio_tar_lat_spd);
  tar_lat_spd_dev = Phoenix_Common_Lerp_f(
        ins->param.dev_tab_tar_lat_spd[key_idx_tar_lat_spd],
        ins->param.dev_tab_tar_lat_spd[key_idx_tar_lat_spd+1],
        key_ratio_tar_lat_spd);
  if (lat_err > 0.0F) {
    tar_lat_spd_exp = -tar_lat_spd_exp;
  }

  // 计算目标横向速度
  tar_lat_spd_up = tar_lat_spd_exp + tar_lat_spd_dev;
  tar_lat_spd_dn = tar_lat_spd_exp - tar_lat_spd_dev;

  // 计算横向加速度
#if 1
  if (ins->lat_spd_feed.filter.valid) {
    raw_lat_acc = (lat_spd - 
        ins->lat_spd_feed.filter.cur_lat_spd) / time_elapsed;
  } else {
    raw_lat_acc = 0.0F;
  }
  if (Phoenix_Com_RingBuffer_IsFull(&(ins->lat_spd_feed.filter.lat_acc_queue.ring_buf))) {
    lat_acc = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D2_LAT_ERR_FILTER_WND_SIZE, LAT_CTL_D2_LAT_ERR_FILTER_WND_SIZE, ins->lat_spd_feed.filter.cur_lat_acc, 
        raw_lat_acc, *(Float32_t*)Phoenix_Com_RingBuffer_GetFront(&(ins->lat_spd_feed.filter.lat_acc_queue.ring_buf)));
  } else {
    lat_acc = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D2_LAT_ERR_FILTER_WND_SIZE, Phoenix_Com_RingBuffer_GetSize(&(ins->lat_spd_feed.filter.lat_acc_queue.ring_buf)), 
        ins->lat_spd_feed.filter.cur_lat_acc, raw_lat_acc, 0.0F);
  }
  Phoenix_Com_RingBuffer_PushBackOverride(
        &(ins->lat_spd_feed.filter.lat_acc_queue.ring_buf), &(raw_lat_acc));
#else
  lat_acc = UpdateLatAccInfo(&(ins->lat_spd_feed.filter.lat_acc_info), lat_spd, data_source->timestamp);
#endif
  
  //lat_acc = cur_pos->v*cur_pos->yaw_rate_chg_rate;

  // 计算期望横向速度误差
  if (lat_spd > tar_lat_spd_up) {
    corrected_spd_err = tar_lat_spd_up - lat_spd;
    if (tar_lat_spd_up > 0.0F) {
      // 速度正大, 需要减小, 向右调节
      feed_dir_flag = 1;
    } else {
      // 速度负小，需要增加, 向右调节
      feed_dir_flag = 3;
    }
  } else if (lat_spd < tar_lat_spd_dn) {
    corrected_spd_err = tar_lat_spd_dn - lat_spd;
    if (tar_lat_spd_dn < 0.0F) {
      // 速度负大, 需要减小, 向左调节
      feed_dir_flag = 2;
    } else {
      // 速度正小，需要增加, 向左调节
      feed_dir_flag = 4;
    }
  } else {
    // 速度适中，无需调节
    feed_dir_flag = 0;
    corrected_spd_err = 0.0F; 
  }

  // 检测突变, 避免过大的方向盘调整
  if ((phoenix_com_abs_f(tar_lat_spd_exp - ins->lat_spd_feed.filter.tar_lat_spd_exp) > 0.2F) ||       /* 期望值偏差过大   */
      ((0 == ins->status.prev_eps_auto) && (0 != ins->status.curr_eps_auto)) ||                       /* 刚进入自动驾驶   */
      ((prev_path_dir == 0) && (curr_path_dir != 0)) ||                                               /* 变道或避让      */
      (((prev_path_dir < 0) && (curr_path_dir > 0)) || ((prev_path_dir > 0) && (curr_path_dir < 0)))  /* 轨迹变化方向变更 */
     ) {
#if 0
    printf("!!!!!! Smooth lat_spd_feed_gain: \n"
           "    prev_exp=%0.2f, curr_exp=%0.2f, exp_diff=%0.2f\n"
           "    prev_eps_auto=%d, curr_eps_auto=%d\n"
           "    prev_path_dir=%d, curr_path_dir=%d\n",
           ins->lat_spd_feed.filter.tar_lat_spd_exp, tar_lat_spd_exp, tar_lat_spd_exp - ins->lat_spd_feed.filter.tar_lat_spd_exp,
           ins->status.prev_eps_auto, ins->status.curr_eps_auto,
           prev_path_dir, curr_path_dir);
#endif
    Phoenix_Com_Timer_SetTimeout(&(ins->timers.smt_lat_spd_feed), 2*1000);
    Phoenix_Com_Timer_Restart(&(ins->timers.smt_lat_spd_feed));
  }

  // 横向误差速率
  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(lat_spd_pid_controller, corrected_spd_err, lat_acc);
  lat_spd_err_lv_idx = lat_spd_pid_controller->err_level_idx_;
  lat_acc_lv_idx = lat_spd_pid_controller->err_spd_level_idx_;

  // 横向误差速率
  kp_lat_spd = Phoenix_Com_FuzzyPID_GetGain_f(lat_spd_pid_controller, 0);
  ki_lat_spd = Phoenix_Com_FuzzyPID_GetGain_f(lat_spd_pid_controller, 1);
  kd_lat_spd = Phoenix_Com_FuzzyPID_GetGain_f(lat_spd_pid_controller, 2);
  p_value_lat_spd = 1.0F * kp_lat_spd * corrected_spd_err;
  i_value_lat_spd = 1.0F * ki_lat_spd * corrected_spd_err;
  d_value_lat_spd = 1.0F * kd_lat_spd * lat_acc;

#if 0
  Float32_t ext_ratio = data_source->ref_trj_curvature * 600.0F;
  if ((data_source->ref_trj_curvature > 0.0001F) && (i_value_lat_spd > 0.0F)) {
    i_value_lat_spd += i_value_lat_spd * ext_ratio;
    printf("---> curv=%0.4f, exi_i_lat_spd=%0.4f, ratio=%0.2f\n", 
        data_source->ref_trj_curvature, i_value_lat_spd * ext_ratio, ext_ratio);
  } else if ((data_source->ref_trj_curvature < -0.0001F) && (i_value_lat_spd < 0.0F)) {
    i_value_lat_spd -= i_value_lat_spd * ext_ratio;
    printf("---> curv=%0.4f, exi_i_lat_spd=%0.3f, ratio=%0.2f\n", 
        data_source->ref_trj_curvature, -i_value_lat_spd * ext_ratio, ext_ratio);
  } else {
    // nothing to do
  }
#endif

static const Float32_t s_key_tab_tar_lat_mv_time[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F,  0.10F,  0.20F,  0.30F,  0.40F,
  0.50F,  0.60F,  0.70F,  0.80F,  0.90F,
  1.00F,  1.10F,  1.20F,  1.30F,  1.40F,
  1.50F,  1.60F,  1.70F,  1.80F,  1.90F,
  2.00F,  2.10F,  2.20F,  2.30F,  2.40F
};
// 横向误差变化率的目标值
static const Float32_t s_val_tab_tar_lat_mv_time[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  1.00F,  2.00F,  3.00F,  3.00F,  3.00F,
  3.00F,  3.00F,  3.00F,  3.00F,  3.20F,
  3.50F,  3.80F,  4.20F,  4.50F,  4.80F,
  5.20F,  5.50F,  5.80F,  6.20F,  6.50F,
  6.80F,  7.20F,  7.50F,  7.80F,  8.00F,
};

#if 0
  // 补偿侧向加速度
  if (cur_pos->v > 20.0F/3.6F) {
    Float32_t key_ratio_mv_t = 0.0F;
    Int32_t key_idx_mv_t = Phoenix_Common_LerpInOrderedTable_f(
        s_key_tab_tar_lat_mv_time, LAT_CTL_PID_LERP_TABLE_SIZE,
        abs_lat_err, &key_ratio_mv_t);
    Float32_t tar_mv_time = Phoenix_Common_Lerp_f(
        s_val_tab_tar_lat_mv_time[key_idx_mv_t],
        s_val_tab_tar_lat_mv_time[key_idx_mv_t+1],
        key_ratio_mv_t);
    Float32_t tar_lat_acc = 2.0F * (-lat_err - lat_spd * tar_mv_time) / (tar_mv_time * tar_mv_time);
    Float32_t lat_acc_err = tar_lat_acc - lat_acc;
    Float32_t ex_i_value = 0.02F * lat_acc_err / cur_pos->v;
    static const Float32_t kMaxYawRateSpdForExI = 0.3F * 0.017453293F;
    if ((ex_i_value > 0.0F) && (cur_pos->yaw_rate_chg_rate > kMaxYawRateSpdForExI)) {
      ex_i_value = 0.0F;
    } else if ((ex_i_value < 0.0F) && (cur_pos->yaw_rate_chg_rate < -kMaxYawRateSpdForExI)) {
      ex_i_value = 0.0F;
    } else {
      // nothing to do
    }
    static const Float32_t kMaxExI = 0.1F * 0.017453293F;
    if (ex_i_value > kMaxExI) {
      ex_i_value = kMaxExI;
    } else if (ex_i_value < -kMaxExI) {
      ex_i_value = -kMaxExI;
    } else {
      // nothing to do
    }
    ret_i_value += ex_i_value;
    
    printf("侧向加速度 tar_lat_acc=%0.2f, lat_acc=%0.2f, err=%0.2f, ex_i=%0.3f, %s\n", 
          tar_lat_acc, lat_acc, lat_acc_err, ex_i_value*57.3F,
          ex_i_value > 0.0F ? "左修正" : "右修正");
  }
#endif

  // 轨迹方向有突变时，暂停积分功能
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_spd_feed))) {
    i_value_lat_spd = 0.0F;
  }

  // 最终的补偿值
  ret_p_value =
      ins->param.d_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益D */
      kp_crt_by_spd *                          /* 根据车速修调           */
      kp_crt_by_wgt *                          /* 根据重量修调           */
      p_value_lat_spd;
  ret_i_value =
      ins->param.i_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益I */
      ki_crt_by_spd *                          /* 根据车速修调           */
      ki_crt_by_wgt *                          /* 根据重量修调           */
      i_value_lat_spd;
  ret_d_value =
      ins->param.i_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益D */
      ki_crt_by_spd *                          /* 根据车速修调           */
      ki_crt_by_wgt *                          /* 根据重量修调           */
      d_value_lat_spd;

#if (HUNTING_SUPPRESS_MODE == HUNTING_SUPPRESS_MODE_I)
  // 蛇行抑制
  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), ret_p_value, data_source->cur_pos.v);
  hunting_gain_p = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(lat_spd_p) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_p);
  ret_p_value *= hunting_gain_p;
#endif

  // 返回补偿值
#if (LAT_FEED_BACK_CHG_LIMIT_MODE == LAT_FEED_BACK_CHG_LIMIT_MODE_I)
  // 限制补偿的增量
  Float32_t max_step_gain = 0.4F * 0.017453293F;
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_spd_feed))) {
    max_step_gain = 0.2F * 0.017453293F;
  }
  // P
  Float32_t p_value_diff = ret_p_value - ins->lat_spd_feed.p_value;
  if (p_value_diff > max_step_gain) {
    ins->lat_spd_feed.p_value = ins->lat_spd_feed.p_value + max_step_gain;
  } else if (p_value_diff < -max_step_gain) {
    ins->lat_spd_feed.p_value = ins->lat_spd_feed.p_value - max_step_gain;
  } else {
    ins->lat_spd_feed.p_value = ret_p_value;
  }
  // I
  ins->lat_spd_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  ins->lat_spd_feed.d_value = 0.0F;
  ins->lat_spd_feed.i_value += ret_d_value; // !!! 加入到积分项中
#else
  // P
  ins->lat_spd_feed.p_value = ret_p_value;
  // I
  ins->lat_spd_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  ins->lat_spd_feed.d_value = 0.0F;
  ins->lat_spd_feed.i_value += ret_d_value; // !!! 加入到积分项中
#endif

  // Lat err
  // 限制P的最大值
  static const Float32_t kMaxFeedValueP = 14.0F * 0.017453293F;
  if(ins->lat_spd_feed.p_value > kMaxFeedValueP) {
    ins->lat_spd_feed.p_value = kMaxFeedValueP;
  } else if(ins->lat_spd_feed.p_value < -kMaxFeedValueP) {
    ins->lat_spd_feed.p_value = -kMaxFeedValueP;
  } else {
    // nothing to do
  }
  // 限制I的最大值
  static const Float32_t kMaxFeedValueI = 0.4F * 0.017453293F;
  if (ins->lat_spd_feed.i_value > kMaxFeedValueI) {
    ins->lat_spd_feed.i_value = kMaxFeedValueI;
  } else if (ins->lat_spd_feed.i_value < -kMaxFeedValueI) {
    ins->lat_spd_feed.i_value = -kMaxFeedValueI;
  } else {
    // nothing to do
  }
  // 限制D的最大值
  static const Float32_t kMaxFeedValueD = 10.0F * 0.017453293F;
  if(ins->lat_spd_feed.d_value > kMaxFeedValueD) {
    ins->lat_spd_feed.d_value = kMaxFeedValueD;
  } else if (ins->lat_spd_feed.d_value < -kMaxFeedValueD) {
    ins->lat_spd_feed.d_value = -kMaxFeedValueD;
  } else {
    // nothing to do
  }

  // 保存当前状态
  ins->lat_spd_feed.err_list[2] = ins->lat_spd_feed.err_list[1];
  ins->lat_spd_feed.err_list[1] = ins->lat_spd_feed.err_list[0];
  ins->lat_spd_feed.err_list[0] = corrected_spd_err;

  // 保存滤波相关的量
  ins->lat_spd_feed.filter.valid = 1;
  ins->lat_spd_feed.filter.tar_lat_spd_exp = tar_lat_spd_exp;
  ins->lat_spd_feed.filter.cur_lat_spd = lat_spd;
  ins->lat_spd_feed.filter.cur_lat_acc = lat_acc;

  printf("lat_acc=%0.4f, ay=%0.4f\n", 
      lat_acc, cur_pos->v*cur_pos->yaw_rate_chg_rate);

//#if (ENABLE_LAT_CTL_PID_TRACE)
  const char* feed_dir_flag_description[5] = {
    "速度适中, 无需调节", "速度正大, 向右调节", "速度负大, 向左调节",
    "速度负小, 向右调节", "速度正小, 向左调节"
  };
  printf("@@@@@ Lat_Spd_Feed: trj=%d, smt_gain=%d\n"
         "    lat [offset: %0.2f, spd: %0.2f, acc: %0.2f]\n"
         "    exp=%0.2f, dev=%0.2f, dir:%s\n"
         "    err=%0.2f, chg=%0.2f, err_idx=%d, chg_idx=%d\n",
         data_source->planning_trj_status, Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_spd_feed)),
         lat_err, lat_spd, lat_acc,
         tar_lat_spd_exp, tar_lat_spd_dev, feed_dir_flag_description[feed_dir_flag],
         corrected_spd_err, lat_acc, lat_spd_err_lv_idx, lat_acc_lv_idx);
  printf("    P: v_ratio=%0.4f, w_ratio=%0.4f, kp=%0.4f, p=%0.3f, p_value=%0.2f, h=%0.2f\n",
         kp_crt_by_spd, kp_crt_by_wgt, kp_lat_spd, phoenix_com_rad2deg_f(p_value_lat_spd),
         phoenix_com_rad2deg_f(ins->lat_spd_feed.p_value), hunting_gain_p);
  printf("    I: v_ratio=%0.4f, w_ratio=%0.4f, ki=%0.4f, i=%0.3f, i_value=%0.2f\n",
         ki_crt_by_spd, ki_crt_by_wgt, ki_lat_spd, phoenix_com_rad2deg_f(i_value_lat_spd),
         phoenix_com_rad2deg_f(ins->lat_spd_feed.i_value));
  printf("    D: v_ratio=%0.4f, w_ratio=%0.4f, kd=%0.4f, d=%0.3f, d_value=%0.2f\n",
         kd_crt_by_spd, kd_crt_by_wgt, kd_lat_spd, phoenix_com_rad2deg_f(d_value_lat_spd),
         phoenix_com_rad2deg_f(ins->lat_spd_feed.d_value));
//#endif

  // 保存状态量
  status_info->lat_err_feed.lat_err_acc = lat_acc;
  status_info->lat_err_feed.tar_lat_spd = tar_lat_spd_exp;
  status_info->lat_err_feed.lat_spd_err = corrected_spd_err;
}
/* k001 pengc 2023-11-07 (end) */


/*
 * @brief 重置横向角度误差反馈补偿控制器
 * @param[in] ins 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/04/08  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ResetYawErrFeedController(
    LatCtlPidInstance_t* const ins) {
  Int32_t ret = 0;

  // Yaw err
  phoenix_com_memset(&(ins->yaw_err_feed), 0,
                     sizeof(ins->yaw_err_feed));

  ret = Phoenix_Com_FuzzyPID_Init(
        &(ins->yaw_err_feed.pid_controller),
        &(ins->param.tab_yaw_err_level),
        &(ins->param.tab_yaw_err_spd_level));
  if (ret < 0) {
    LOG_ERR_C("Failed to initialize yaw error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_err_feed.pid_controller), 0,
        &(ins->param.p_gain_tab_yaw_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set P gain table of yaw error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_err_feed.pid_controller), 1,
        &(ins->param.i_gain_tab_yaw_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set I gain table of yaw error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_err_feed.pid_controller), 2,
        &(ins->param.d_gain_tab_yaw_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set D gain table of yaw error pid controller.");
    COM_CHECK_C(0 == ret);
  }
}

/* k001 pengc 2023-12-01 (begin) */
/*
 * @brief 根据横向角度误差计算反馈补偿值
 * @param[in] ins 成员变量
 * @param[in] data_source 控制器所需要的数据
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[out] status_info 内部状态信息
 * @return 反馈补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023-11-07  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void CalcFeedValueFromYawErr(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, data_source->timestamp);
  Float32_t time_elapsed = 0.001F * time_elapsed_ms;

  Float32_t lat_err = ins->status.synthetic_lat_err;
  Float32_t yaw_err = ins->status.synthetic_yaw_err;
  Float32_t yaw_spd = ins->status.synthetic_yaw_spd;
  Float32_t abs_lat_err = phoenix_com_abs_f(lat_err);
  Float32_t hunting_gain_p = 1.0F;
  Float32_t hunting_gain_d = 1.0F;
  Float32_t hunting_gain_1 = ins->hunting_detector.yaw_rate.hunting_gain;
  Float32_t hunting_gain_2 = 1.0F;
  FuzzyPID_t* yaw_err_pid_controller = &(ins->yaw_err_feed.pid_controller);
  
  // 轨迹变更方向
  Int32_t prev_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.prev_trj_stat);
  Int32_t curr_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.curr_trj_stat);

  /// 使用误差补偿的修调参数
  // 根据速度修调补偿量
  Float32_t key_ratio_crt_by_spd = 0.0F;
  Int32_t key_idx_crt_by_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_crt_by_spd);
  Float32_t kp_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.p_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t ki_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.i_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t kd_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.d_tab_crt_lat_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  // 根据重量修调补偿量
  Float32_t key_ratio_crt_by_wgt = 0.0F;
  Int32_t key_idx_crt_by_wgt = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_lat_err_feed_by_weight,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        data_source->chassis.gross_weight,
        &key_ratio_crt_by_wgt);
  Float32_t kp_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.p_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t ki_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.i_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t kd_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.d_tab_crt_lat_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);

  Float32_t corrected_yaw_err = 0.0F;

  Float32_t key_ratio_crt_exp_by_spd = 0.0F;
  Int32_t key_idx_crt_exp_by_spd  = 0;
  Float32_t ratio_crt_exp_by_spd = 0.0F;

  Float32_t key_ratio_tar_yaw_err = 0.0F;
  Int32_t key_idx_tar_yaw_err = 0;
  Float32_t tar_yaw_err_exp = 0.0F;  // expected speed
  Float32_t tar_yaw_err_dev = 0.0F;  // standard deviation
  Float32_t tar_yaw_err_up = 0.0F;
  Float32_t tar_yaw_err_dn = 0.0F;
  Int32_t feed_dir_flag = 0; // 横向速度误差调节方向标记

  Int32_t yaw_err_lv_idx = 0;
  Int32_t yaw_spd_lv_idx = 0;
  Float32_t kp_yaw_err = 0.0F;
  Float32_t ki_yaw_err = 0.0F;
  Float32_t kd_yaw_err = 0.0F;
  Float32_t p_value_yaw_err = 0.0F;
  Float32_t i_value_yaw_err = 0.0F;
  Float32_t d_value_yaw_err = 0.0F;
  Float32_t ret_p_value = 0.0F;
  Float32_t ret_i_value = 0.0F;
  Float32_t ret_d_value = 0.0F;

  // 通过速度修正角度误差的目标值
  key_ratio_crt_exp_by_spd = 0.0F;
  key_idx_crt_exp_by_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_yaw_err_exp_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_crt_exp_by_spd);
  ratio_crt_exp_by_spd = Phoenix_Common_Lerp_f(
        ins->param.ratio_tab_crt_yaw_err_exp_by_spd[key_idx_crt_exp_by_spd],
        ins->param.ratio_tab_crt_yaw_err_exp_by_spd[key_idx_crt_exp_by_spd+1],
        key_ratio_crt_exp_by_spd);
  // 获取期望的角度误差
  key_ratio_tar_yaw_err = 0.0F;
  key_idx_tar_yaw_err = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_tar_yaw_err,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        abs_lat_err,
        &key_ratio_tar_yaw_err);
  tar_yaw_err_exp = Phoenix_Common_Lerp_f(
        ins->param.exp_tab_tar_yaw_err[key_idx_tar_yaw_err],
        ins->param.exp_tab_tar_yaw_err[key_idx_tar_yaw_err+1],
        key_ratio_tar_yaw_err);
  tar_yaw_err_dev = Phoenix_Common_Lerp_f(
        ins->param.dev_tab_tar_yaw_err[key_idx_tar_yaw_err],
        ins->param.dev_tab_tar_yaw_err[key_idx_tar_yaw_err+1],
        key_ratio_tar_yaw_err);
  tar_yaw_err_dev *= ratio_crt_exp_by_spd;
  if (lat_err > 0.0F) {
    tar_yaw_err_exp = -tar_yaw_err_exp;
  }
  tar_yaw_err_up = tar_yaw_err_exp + tar_yaw_err_dev;
  tar_yaw_err_dn = tar_yaw_err_exp - tar_yaw_err_dev;

  // 计算期望角度误差
  if (yaw_err > tar_yaw_err_up) {
    corrected_yaw_err = -(tar_yaw_err_up - yaw_err);
    if (tar_yaw_err_up > 0.0F) {
      // 角度正大, 需要减小, 向右调节
      feed_dir_flag = 1;
    } else {
      // 角度负小，需要增加, 向右调节
      feed_dir_flag = 3;
    }
  } else if (yaw_err < tar_yaw_err_dn) {
    corrected_yaw_err = -(tar_yaw_err_dn - yaw_err);
    if (tar_yaw_err_dn < 0.0F) {
      // 角度负大, 需要减小, 向左调节
      feed_dir_flag = 2;
    } else {
      // 角度正小，需要增加, 向左调节
      feed_dir_flag = 4;
    }
  } else {
    // 角度适中，无需调节
    feed_dir_flag = 0;
    corrected_yaw_err = 0.0F; 
  }

  // 检测突变, 避免过大的方向盘调整
  if ((phoenix_com_abs_f(tar_yaw_err_exp - ins->yaw_err_feed.filter.tar_yaw_err_exp) > phoenix_com_deg2rad_f(0.5F)) ||  /* 期望值偏差过大   */
      ((0 == ins->status.prev_eps_auto) && (0 != ins->status.curr_eps_auto)) ||                                         /* 刚进入自动驾驶   */
      ((prev_path_dir == 0) && (curr_path_dir != 0)) ||                                                                 /* 变道或避让      */
      (((prev_path_dir < 0) && (curr_path_dir > 0)) || ((prev_path_dir > 0) && (curr_path_dir < 0)))                    /* 轨迹变化方向变更 */
     ) {
#if 0
    printf("!!!!!! Smooth yaw_err_feed_gain: \n"
           "    prev_exp=%0.2f, curr_exp=%0.2f, exp_diff=%0.2f\n"
           "    prev_eps_auto=%d, curr_eps_auto=%d\n"
           "    prev_path_dir=%d, curr_path_dir=%d\n",
           phoenix_com_rad2deg_f(ins->yaw_err_feed.filter.tar_yaw_err_exp), phoenix_com_rad2deg_f(tar_yaw_err_exp), 
           phoenix_com_rad2deg_f(tar_yaw_err_exp - ins->yaw_err_feed.filter.tar_yaw_err_exp),
           ins->status.prev_eps_auto, ins->status.curr_eps_auto,
           prev_path_dir, curr_path_dir);
#endif
    Phoenix_Com_Timer_SetTimeout(&(ins->timers.smt_yaw_err_feed), 2*1000);
    Phoenix_Com_Timer_Restart(&(ins->timers.smt_yaw_err_feed));
  }

  // 横向误差速率
  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(yaw_err_pid_controller, corrected_yaw_err, yaw_spd);
  yaw_err_lv_idx = yaw_err_pid_controller->err_level_idx_;
  yaw_spd_lv_idx = yaw_err_pid_controller->err_spd_level_idx_;

  // 横向误差速率
  kp_yaw_err = Phoenix_Com_FuzzyPID_GetGain_f(yaw_err_pid_controller, 0);
  ki_yaw_err = Phoenix_Com_FuzzyPID_GetGain_f(yaw_err_pid_controller, 1);
  kd_yaw_err = Phoenix_Com_FuzzyPID_GetGain_f(yaw_err_pid_controller, 2);
  p_value_yaw_err = 1.0F * kp_yaw_err * corrected_yaw_err;
  i_value_yaw_err =        ki_yaw_err * corrected_yaw_err;
  d_value_yaw_err = 1.0F * kd_yaw_err * yaw_spd;

  // 最终的补偿值
  ret_p_value =
      ins->param.p_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益P */
      kp_crt_by_spd *                          /* 根据车速修调           */
      kp_crt_by_wgt *                          /* 根据重量修调           */
      p_value_yaw_err;
  ret_i_value =
      ins->param.i_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益I */
      ki_crt_by_spd *                          /* 根据车速修调           */
      ki_crt_by_wgt *                          /* 根据重量修调           */
      i_value_yaw_err;
  ret_d_value =
      ins->param.d_global_gain_lat_err_feed *  /* 使用误差补偿的全局增益D */
      kd_crt_by_spd *                          /* 根据车速修调           */
      kd_crt_by_wgt *                          /* 根据重量修调           */
      d_value_yaw_err;

#if (HUNTING_SUPPRESS_MODE == HUNTING_SUPPRESS_MODE_I)
  // 蛇行抑制
  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), ret_p_value, data_source->cur_pos.v);
  hunting_gain_p = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(yaw_err_p) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_p);
  ret_p_value *= hunting_gain_p;

  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), ret_d_value, data_source->cur_pos.v);
  hunting_gain_d = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(yaw_err_d) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_d);
  ret_d_value *= hunting_gain_d;
#endif

  // 返回补偿值
#if (LAT_FEED_BACK_CHG_LIMIT_MODE == LAT_FEED_BACK_CHG_LIMIT_MODE_I)
  // 限制补偿的增量
  Float32_t max_step_gain = 0.4F * 0.017453293F;
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_err_feed))) {
    max_step_gain = 0.2F * 0.017453293F;
  }
  // P
  Float32_t p_value_diff = ret_p_value - ins->yaw_err_feed.p_value;
  if (p_value_diff > max_step_gain) {
    ins->yaw_err_feed.p_value += max_step_gain;
  } else if (p_value_diff < -max_step_gain) {
    ins->yaw_err_feed.p_value -= max_step_gain;
  } else {
    ins->yaw_err_feed.p_value = ret_p_value;
  }
  // I
  ins->yaw_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  Float32_t d_value_diff = ret_d_value - ins->yaw_err_feed.d_value;
  if (d_value_diff > max_step_gain) {
    ins->yaw_err_feed.d_value += max_step_gain;
  } else if (d_value_diff < -max_step_gain) {
    ins->yaw_err_feed.d_value -= max_step_gain;
  } else {
    ins->yaw_err_feed.d_value = ret_d_value;
  }
#else
  // P
  ins->yaw_err_feed.p_value = ret_p_value;
  // I
  ins->yaw_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  ins->yaw_err_feed.d_value = ret_d_value;
#endif

  // 限制P的最大值
  static const Float32_t kMaxFeedValueP = 10.0F * 0.017453293F;
  if(ins->yaw_err_feed.p_value > kMaxFeedValueP) {
    ins->yaw_err_feed.p_value = kMaxFeedValueP;
  } else if(ins->yaw_err_feed.p_value < -kMaxFeedValueP) {
    ins->yaw_err_feed.p_value = -kMaxFeedValueP;
  } else {
    // nothing to do
  }
  // 限制I的最大值
  static const Float32_t kMaxFeedValueI = 0.4F * 0.017453293F;
  if (ins->yaw_err_feed.i_value > kMaxFeedValueI) {
    ins->yaw_err_feed.i_value = kMaxFeedValueI;
  } else if (ins->yaw_err_feed.i_value < -kMaxFeedValueI) {
    ins->yaw_err_feed.i_value = -kMaxFeedValueI;
  } else {
    // nothing to do
  }
  // 限制D的最大值
  static const Float32_t kMaxFeedValueD = 10.0F * 0.017453293F;
  if(ins->yaw_err_feed.d_value > kMaxFeedValueD) {
    ins->yaw_err_feed.d_value = kMaxFeedValueD;
  } else if(ins->yaw_err_feed.d_value < -kMaxFeedValueD) {
    ins->yaw_err_feed.d_value = -kMaxFeedValueD;
  } else {
    // nothing to do
  }

  // 保存滤波相关的量
  ins->yaw_err_feed.filter.valid = 1;
  ins->yaw_err_feed.filter.tar_yaw_err_exp = tar_yaw_err_exp;

#if (ENABLE_LAT_CTL_PID_TRACE)
  const char* feed_dir_flag_description[5] = {
    "角度适中, 无需调节", "角度正大, 向右调节", "角度负大, 向左调节",
    "角度负小, 向右调节", "角度正小, 向左调节"
  };
  printf("@@@@@ Yaw_Err_Feed: smt_gain=%d\n"
         "    yaw [err: %0.2f, spd: %0.2f]\n"
         "    exp=%0.2f, dev=%0.2f, dir:%s\n"
         "    err=%0.2f, chg=%0.2f, err_idx=%d, chg_idx=%d\n",
         Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_err_feed)),
         phoenix_com_rad2deg_f(yaw_err), phoenix_com_rad2deg_f(yaw_spd),
         phoenix_com_rad2deg_f(tar_yaw_err_exp), phoenix_com_rad2deg_f(tar_yaw_err_dev), feed_dir_flag_description[feed_dir_flag],
         phoenix_com_rad2deg_f(corrected_yaw_err), phoenix_com_rad2deg_f(yaw_spd), yaw_err_lv_idx, yaw_spd_lv_idx);
  printf("    P: v_ratio=%0.4f, w_ratio=%0.4f, kp=%0.4f, p=%0.3f, p_value=%0.2f, h=%0.2f\n",
         kp_crt_by_spd, kp_crt_by_wgt, kp_yaw_err, phoenix_com_rad2deg_f(p_value_yaw_err),
         phoenix_com_rad2deg_f(ins->yaw_err_feed.p_value), hunting_gain_p);
  printf("    I: v_ratio=%0.4f, w_ratio=%0.4f, ki=%0.4f, i=%0.3f, i_value=%0.2f\n",
         ki_crt_by_spd, ki_crt_by_wgt, ki_yaw_err, phoenix_com_rad2deg_f(i_value_yaw_err),
         phoenix_com_rad2deg_f(ins->yaw_err_feed.i_value));
  printf("    D: v_ratio=%0.4f, w_ratio=%0.4f, kd=%0.4f, d=%0.3f, d_value=%0.2f, h=%0.2f\n",
         kd_crt_by_spd, kd_crt_by_wgt, kd_yaw_err, phoenix_com_rad2deg_f(d_value_yaw_err),
         phoenix_com_rad2deg_f(ins->yaw_err_feed.d_value), hunting_gain_d);
#endif

  // 保存状态量
  status_info->yaw_err_feed.yaw_err = yaw_err;
  status_info->yaw_err_feed.tar_yaw_err = tar_yaw_err_exp;
  status_info->yaw_err_feed.crt_yaw_err = corrected_yaw_err;
  status_info->yaw_err_feed.yaw_err_spd = yaw_spd;
  status_info->yaw_err_feed.yaw_err_lv_idx = yaw_err_lv_idx;
  status_info->yaw_err_feed.yaw_err_spd_lv_idx = yaw_spd_lv_idx;
  status_info->yaw_err_feed.p_feed.v_ratio = kp_crt_by_spd;
  status_info->yaw_err_feed.p_feed.w_ratio = kp_crt_by_wgt;
  status_info->yaw_err_feed.p_feed.k_ratio = kp_yaw_err;
  status_info->yaw_err_feed.p_feed.k_value = p_value_yaw_err;
  status_info->yaw_err_feed.p_feed.feed = ins->yaw_err_feed.p_value;
  status_info->yaw_err_feed.i_feed.v_ratio = ki_crt_by_spd;
  status_info->yaw_err_feed.i_feed.w_ratio = ki_crt_by_wgt;
  status_info->yaw_err_feed.i_feed.k_ratio = ki_yaw_err;
  status_info->yaw_err_feed.i_feed.k_value = i_value_yaw_err;
  status_info->yaw_err_feed.i_feed.feed = ins->yaw_err_feed.i_value;
  status_info->yaw_err_feed.d_feed.v_ratio = kd_crt_by_spd;
  status_info->yaw_err_feed.d_feed.w_ratio = kd_crt_by_wgt;
  status_info->yaw_err_feed.d_feed.k_ratio = kd_yaw_err;
  status_info->yaw_err_feed.d_feed.k_value = d_value_yaw_err;
  status_info->yaw_err_feed.d_feed.feed = ins->yaw_err_feed.d_value;
  status_info->yaw_err_feed.feed_value = ins->yaw_err_feed.p_value + ins->yaw_err_feed.d_value;
}
/* k001 pengc 2023-12-01 (end) */

/*
 * @brief 重置角速度误差反馈补偿控制器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ResetYawRateErrFeedController(
    LatCtlPidInstance_t* const ins) {
  Int32_t ret = 0;

  phoenix_com_memset(
      &(ins->yaw_rate_err_feed), 0, sizeof(ins->yaw_rate_err_feed));

  ret = Phoenix_Com_FuzzyPID_Init(
        &(ins->yaw_rate_err_feed.pid_controller),
        &(ins->param.tab_yaw_rate_err_level),
        &(ins->param.tab_yaw_rate_spd_level));
  if (ret < 0) {
    LOG_ERR_C("Failed to initialize lateral error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_rate_err_feed.pid_controller), 0,
        &(ins->param.p_gain_tab_yaw_rate_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set P gain table of yaw rate error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_rate_err_feed.pid_controller), 1,
        &(ins->param.i_gain_tab_yaw_rate_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set I gain table of yaw rate error pid controller.");
    COM_CHECK_C(0 == ret);
  }
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(ins->yaw_rate_err_feed.pid_controller), 2,
        &(ins->param.d_gain_tab_yaw_rate_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set D gain table of yaw rate error pid controller.");
    COM_CHECK_C(0 == ret);
  }

  phoenix_com_memset(
    ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.data_buf, 0, 
    sizeof(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.ring_buf), LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE,
      sizeof(Float32_t), ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.data_buf);
}

/*
 * @brief 根据角速度误差计算反馈补偿值
 * @param[in] ins 成员变量
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[in] tar_yaw_rate 目标角速度
 * @param[out] status_info 内部状态信息
 * @return 反馈补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void CalcFeedValueFromYawRateErr(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    Float32_t tar_yaw_rate,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, data_source->timestamp);
  Float32_t time_elapsed = 0.001F * time_elapsed_ms;

  // 角速度误差及其变化率
  const Float32_t lat_err = ins->status.synthetic_lat_err;
  const Float32_t lat_err_spd = ins->status.synthetic_lat_spd;
  const Float32_t yaw_rate_err = tar_yaw_rate - cur_pos->yaw_rate;
  const Float32_t yaw_rate_spd = cur_pos->yaw_rate_chg_rate;
  // PID 控制器
  FuzzyPID_t* pid_controller = &(ins->yaw_rate_err_feed.pid_controller);
  // 出现蛇形时，减小控制增益
  Float32_t hunting_gain_p = 1.0F;
  Float32_t hunting_gain_d = 1.0F;
  Float32_t hunting_gain_1 = ins->hunting_detector.yaw_rate.hunting_gain;
  Float32_t hunting_gain_2 = 1.0F;

    // 轨迹变更方向
  Int32_t prev_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.prev_trj_stat);
  Int32_t curr_path_dir = Phoenix_AdMsg_GetTrjPlanngingTrjChgDirection(ins->status.curr_trj_stat);
  Int8_t is_in_changing_lane_stage_1 = 
      ((TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_LEFT_STAGE_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_RIGHT_STAGE_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_RIGHT_I == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_LEFT_I == data_source->planning_trj_status));
  Int8_t is_in_changing_lane_stage_2 = 
      ((TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_LEFT_STAGE_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_RIGHT_STAGE_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_RIGHT_II == data_source->planning_trj_status) ||
       (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_LEFT_II == data_source->planning_trj_status));

  // 误差及其变化率的等级索引
  Int32_t err_lv_idx = 0;
  Int32_t spd_lv_idx = 0;
  // 补偿值
  Float32_t kp_yaw_rate_err = 0.0F;
  Float32_t ki_yaw_rate_err = 0.0F;
  Float32_t kd_yaw_rate_err = 0.0F;
  Float32_t p_value_yaw_rate_err = 0.0F;
  Float32_t i_value_yaw_rate_err = 0.0F;
  Float32_t d_value_yaw_rate_err = 0.0F;
  Float32_t ret_p_value = 0.0F;
  Float32_t ret_i_value = 0.0F;
  Float32_t ret_d_value = 0.0F;

  // 根据速度修调补偿量
  Float32_t key_ratio_crt_by_spd = 0.0F;
  Int32_t key_idx_crt_by_spd = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_yaw_rate_err_feed_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_crt_by_spd);
  Float32_t kp_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.p_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t ki_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.i_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  Float32_t kd_crt_by_spd = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd],
        ins->param.d_tab_crt_yaw_rate_err_feed_by_spd[key_idx_crt_by_spd+1],
        key_ratio_crt_by_spd);
  // 根据重量修调补偿量
  Float32_t weight = data_source->chassis.gross_weight;
  Float32_t key_ratio_crt_by_wgt = 0.0F;
  Int32_t key_idx_crt_by_wgt = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_crt_yaw_rate_err_feed_by_weight,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        weight,
        &key_ratio_crt_by_wgt);
  Float32_t kp_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.p_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.p_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t ki_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.i_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.i_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);
  Float32_t kd_crt_by_wgt = Phoenix_Common_Lerp_f(
        ins->param.d_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt],
        ins->param.d_tab_crt_yaw_rate_err_feed_by_weight[key_idx_crt_by_wgt+1],
        key_ratio_crt_by_wgt);

  // 获取期望的角速度误差
  Float32_t key_ratio_tar_yaw_rate_err = 0.0F;
  Int32_t key_idx_tar_yaw_rate_err = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_tar_yaw_rate_err,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        phoenix_com_abs_f(ins->status.synthetic_lat_err),
        &key_ratio_tar_yaw_rate_err);
  Float32_t tar_yaw_rate_err_dev = Phoenix_Common_Lerp_f(
        ins->param.dev_tab_tar_yaw_rate_err[key_idx_tar_yaw_rate_err],
        ins->param.dev_tab_tar_yaw_rate_err[key_idx_tar_yaw_rate_err+1],
        key_ratio_tar_yaw_rate_err);
  Float32_t abs_cur_yaw_rate = phoenix_com_abs_f(cur_pos->yaw_rate);
  tar_yaw_rate_err_dev = tar_yaw_rate_err_dev > 0.3F*abs_cur_yaw_rate ? tar_yaw_rate_err_dev : 0.3F*abs_cur_yaw_rate;
  Float32_t tar_yaw_rate_err_up = tar_yaw_rate + tar_yaw_rate_err_dev;
  Float32_t tar_yaw_rate_err_dn = tar_yaw_rate - tar_yaw_rate_err_dev;
  Float32_t corrected_yaw_rate_err = 0.0F;
  Int32_t feed_dir_flag = 0;

  // 计算期望角速度误差
  if (cur_pos->yaw_rate > tar_yaw_rate_err_up) {
    corrected_yaw_rate_err = tar_yaw_rate_err_up - cur_pos->yaw_rate;
    if (tar_yaw_rate_err_up > 0.0F) {
      // 角速度正大, 需要减小, 向右调节
      feed_dir_flag = 1;
    } else {
      // 角速度负小，需要增加, 向右调节
      feed_dir_flag = 3;
    }
  } else if (cur_pos->yaw_rate < tar_yaw_rate_err_dn) {
    corrected_yaw_rate_err = tar_yaw_rate_err_dn - cur_pos->yaw_rate;
    if (tar_yaw_rate_err_dn < 0.0F) {
      // 角速度负大, 需要减小, 向左调节
      feed_dir_flag = 2;
    } else {
      // 角速度正小，需要增加, 向左调节
      feed_dir_flag = 4;
    }
  } else {
    // 角速度适中，无需调节
    feed_dir_flag = 0;
    corrected_yaw_rate_err = 0.0F; 
  }

  // 计算目标横摆角速度变化率
  Float32_t raw_tar_yaw_rate_spd = 0.0F;
  Float32_t tar_yaw_rate_spd = 0.0F;
  if (ins->yaw_rate_err_feed.filter.valid) {
    raw_tar_yaw_rate_spd = (tar_yaw_rate - 
        ins->yaw_rate_err_feed.filter.tar_yaw_rate) / time_elapsed;
  } else {
    raw_tar_yaw_rate_spd = 0.0F;
  }
  if (Phoenix_Com_RingBuffer_IsFull(&(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.ring_buf))) {
    tar_yaw_rate_spd = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, 
        ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd, raw_tar_yaw_rate_spd, 
        *(Float32_t*)Phoenix_Com_RingBuffer_GetFront(&(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.ring_buf)));
  } else {
    tar_yaw_rate_spd = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, 
        Phoenix_Com_RingBuffer_GetSize(&(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.ring_buf)), 
        ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd, raw_tar_yaw_rate_spd, 0.0F);
  }
  Phoenix_Com_RingBuffer_PushBackOverride(
        &(ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd_queue.ring_buf), &(raw_tar_yaw_rate_spd));

  // 检测突变, 避免过大的方向盘调整
  if ((phoenix_com_abs_f(tar_yaw_rate - ins->yaw_rate_err_feed.filter.tar_yaw_rate) > phoenix_com_deg2rad_f(0.5F)) ||  /* 期望值偏差过大   */
      ((0 == ins->status.prev_eps_auto) && (0 != ins->status.curr_eps_auto)) ||                                        /* 刚进入自动驾驶   */
      ((prev_path_dir == 0) && (curr_path_dir != 0)) ||                                                                /* 变道或避让      */
      (((prev_path_dir < 0) && (curr_path_dir > 0)) || ((prev_path_dir > 0) && (curr_path_dir < 0)))                   /* 轨迹变化方向变更 */
     ) {
#if 0
    printf("!!!!!! Smooth yaw_rate_err_feed_gain: \n"
           "    prev_exp=%0.2f, curr_exp=%0.2f, exp_diff=%0.2f\n"
           "    prev_eps_auto=%d, curr_eps_auto=%d\n"
           "    prev_path_dir=%d, curr_path_dir=%d\n",
           phoenix_com_rad2deg_f(ins->yaw_rate_err_feed.filter.tar_yaw_rate), phoenix_com_rad2deg_f(tar_yaw_rate), 
           phoenix_com_rad2deg_f(tar_yaw_rate - ins->yaw_rate_err_feed.filter.tar_yaw_rate),
           ins->status.prev_eps_auto, ins->status.curr_eps_auto,
           prev_path_dir, curr_path_dir);
#endif
    Phoenix_Com_Timer_SetTimeout(&(ins->timers.smt_yaw_rate_err_feed), 2*1000);
    Phoenix_Com_Timer_Restart(&(ins->timers.smt_yaw_rate_err_feed));
  }

  // 更新当前误差等级
  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(pid_controller, yaw_rate_err, yaw_rate_spd);
  err_lv_idx = pid_controller->err_level_idx_;
  spd_lv_idx = pid_controller->err_spd_level_idx_;
  // 计算当前PID增益
  kp_yaw_rate_err = Phoenix_Com_FuzzyPID_GetGain_f(pid_controller, 0);
  kd_yaw_rate_err = Phoenix_Com_FuzzyPID_GetGain_f(pid_controller, 2);
  p_value_yaw_rate_err = 1.0F * kp_yaw_rate_err * corrected_yaw_rate_err;
  d_value_yaw_rate_err = 1.0F * kd_yaw_rate_err * yaw_rate_spd;

  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(pid_controller, corrected_yaw_rate_err, yaw_rate_spd);
  err_lv_idx = pid_controller->err_level_idx_;
  spd_lv_idx = pid_controller->err_spd_level_idx_;
  ki_yaw_rate_err = Phoenix_Com_FuzzyPID_GetGain_f(pid_controller, 1);
  i_value_yaw_rate_err = 1.0F * ki_yaw_rate_err * corrected_yaw_rate_err;

  // 车速低，不补偿
  if (cur_pos->v < 5.0F/3.6F) {
    p_value_yaw_rate_err = 0.0F;
    i_value_yaw_rate_err = 0.0F;
    d_value_yaw_rate_err = 0.0F;
  }

  if (is_in_changing_lane_stage_1 || is_in_changing_lane_stage_2) {
    i_value_yaw_rate_err = 0.0F;
  }

  //printf("--------trj=%d   yaw_rate_err=%0.3f  err_spd=%0.3f    i_value=%0.4f\n", 
  //       data_source->planning_trj_status, corrected_yaw_rate_err*57.3F, yaw_rate_err_spd*57.3F,
  //       i_value_yaw_rate_err*57.3F);

  // 最终的补偿值
  ret_p_value =
      ins->param.p_global_gain_yaw_rate_err_feed *  /* 角速度误差补偿的全局增益P */
      kp_crt_by_spd *                               /* 根据车速修调           */
      kp_crt_by_wgt *                               /* 根据重量修调           */
      p_value_yaw_rate_err;
  ret_i_value =
      ins->param.i_global_gain_yaw_rate_err_feed *  /* 角速度误差补偿的全局增益I */
      ki_crt_by_spd *                               /* 根据车速修调           */
      ki_crt_by_wgt *                               /* 根据重量修调           */
      i_value_yaw_rate_err;
  ret_d_value =
      ins->param.d_global_gain_yaw_rate_err_feed *  /* 角速度误差补偿的全局增益D */
      kd_crt_by_spd *                               /* 根据车速修调           */
      kd_crt_by_wgt *                               /* 根据重量修调           */
      d_value_yaw_rate_err;

#if 1
  // 额外的补偿
  Float32_t yaw_rate_spd_err = tar_yaw_rate_spd - yaw_rate_spd;
  Float32_t ex_i_value = 0.1F*yaw_rate_spd_err;
  static const Float32_t kMaxYawRateSpdForExI = 0.3F * 0.017453293F;
  if ((ex_i_value > 0.0F) && (yaw_rate_spd > kMaxYawRateSpdForExI)) {
    ex_i_value = 0.0F;
  } else if ((ex_i_value < 0.0F) && (yaw_rate_spd < -kMaxYawRateSpdForExI)) {
    ex_i_value = 0.0F;
  } else {
    // nothing to do
  }
  static const Float32_t kMaxExI = 0.1F * 0.017453293F;
  if (ex_i_value > kMaxExI) {
    ex_i_value = kMaxExI;
  } else if (ex_i_value < -kMaxExI) {
    ex_i_value = -kMaxExI;
  } else {
    // nothing to do
  }
  ret_i_value += ex_i_value;
  
  printf("角速度变化率 tar_yaw_rate_spd=%0.3f, yaw_rate_spd=%0.3f, err=%0.3f, ex_i=%0.3f, %s\n", 
         tar_yaw_rate_spd*57.3F, yaw_rate_spd*57.3F, yaw_rate_spd_err*57.3F, ex_i_value*57.3F,
         ex_i_value > 0.0F ? "左修正" : "右修正");
#endif

#if 1
  static const Float32_t kMaxYawRateSpdForValueI = 0.3F * 0.017453293F;
  if ((ret_i_value > 0.0F) && (yaw_rate_spd > kMaxYawRateSpdForValueI)) {
    ret_i_value = 0.0F;
  } else if ((ret_i_value < 0.0F) && (yaw_rate_spd < -kMaxYawRateSpdForValueI)) {
    ret_i_value = 0.0F;
  } else {
    // nothing to do
  }
#endif

#if (HUNTING_SUPPRESS_MODE == HUNTING_SUPPRESS_MODE_I)
  // 蛇行抑制
  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), ret_p_value, data_source->cur_pos.v);
  hunting_gain_p = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(yaw_rate_p) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_p);
  ret_p_value *= hunting_gain_p;

  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), ret_d_value, data_source->cur_pos.v);
  hunting_gain_d = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(yaw_rate_d) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_d);
  ret_d_value *= hunting_gain_d;
#endif

  // 返回补偿值
#if (LAT_FEED_BACK_CHG_LIMIT_MODE == LAT_FEED_BACK_CHG_LIMIT_MODE_I)
  // 限制补偿的增量
  Float32_t max_step_gain = 0.4F * 0.017453293F;
  if (Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_rate_err_feed))) {
    max_step_gain = 0.2F * 0.017453293F;
  }
  // P
  Float32_t p_value_diff = ret_p_value - ins->yaw_rate_err_feed.p_value;
  if (p_value_diff > max_step_gain) {
    ins->yaw_rate_err_feed.p_value += max_step_gain;
  } else if (p_value_diff < -max_step_gain) {
    ins->yaw_rate_err_feed.p_value -= max_step_gain;
  } else {
    ins->yaw_rate_err_feed.p_value = ret_p_value;
  }
  // I
  ins->yaw_rate_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  Float32_t d_value_diff = ret_d_value - ins->yaw_rate_err_feed.d_value;
  if (d_value_diff > max_step_gain) {
    ins->yaw_rate_err_feed.d_value += max_step_gain;
  } else if (d_value_diff < -max_step_gain) {
    ins->yaw_rate_err_feed.d_value -= max_step_gain;
  } else {
    ins->yaw_rate_err_feed.d_value = ret_d_value;
  }
#else
  // P
  ins->yaw_rate_err_feed.p_value = ret_p_value;
  // I
  ins->yaw_rate_err_feed.i_value = ret_i_value;  // !!! 此处不要累加，放到反馈积分中累加
  // D
  ins->yaw_rate_err_feed.d_value = ret_d_value;
#endif

  // 限制P的最大值
  static const Float32_t kMaxFeedValueP = 10.0F * 0.017453293F;
  if(ins->yaw_rate_err_feed.p_value > kMaxFeedValueP) {
    ins->yaw_rate_err_feed.p_value = kMaxFeedValueP;
  } else if(ins->yaw_rate_err_feed.p_value < -kMaxFeedValueP) {
    ins->yaw_rate_err_feed.p_value = -kMaxFeedValueP;
  } else {
    // nothing to do
  }
  // 限制I的最大值
  static const Float32_t kMaxFeedValueI = 0.1F * 0.017453293F;
  if (ins->yaw_rate_err_feed.i_value > kMaxFeedValueI) {
    ins->yaw_rate_err_feed.i_value = kMaxFeedValueI;
  } else if (ins->yaw_rate_err_feed.i_value < -kMaxFeedValueI) {
    ins->yaw_rate_err_feed.i_value = -kMaxFeedValueI;
  } else {
    // nothing to do
  }
  // 限制D的最大值
  static const Float32_t kMaxFeedValueD = 10.0F * 0.017453293F;
  if(ins->yaw_rate_err_feed.d_value > kMaxFeedValueD) {
    ins->yaw_rate_err_feed.d_value = kMaxFeedValueD;
  } else if(ins->yaw_rate_err_feed.d_value < -kMaxFeedValueD) {
    ins->yaw_rate_err_feed.d_value = -kMaxFeedValueD;
  } else {
    // nothing to do
  }

  // 保存滤波相关的量
  ins->yaw_rate_err_feed.filter.valid = 1;
  ins->yaw_rate_err_feed.filter.tar_yaw_rate = tar_yaw_rate;
  ins->yaw_rate_err_feed.filter.tar_yaw_rate_spd = tar_yaw_rate_spd;
  ins->yaw_rate_err_feed.filter.yaw_rate_err = corrected_yaw_rate_err;

//#if (ENABLE_LAT_CTL_PID_TRACE)
  const char* feed_dir_flag_description[5] = {
    "角速度适中, 无需调节", "角速度正大, 向右调节", "角速度负大, 向左调节",
    "角速度负小, 向右调节", "角速度正小, 向左调节"
  };
  printf("@@@@@ Yaw_Rate_Err_Feed: smt_gain=%d, trj=%d\n"
         "    lat_err: %0.2f, lat_spd: %0.2f\n"
         "    yaw_rate [cur: %0.2f, spd: %0.2f, err: %0.2f, tar_spd: %0.2f]\n"
         "    exp=%0.2f, dev=%0.2f, dir:%s\n"
         "    err=%0.2f, err_v=%0.2f, err_idx=%d, spd_idx=%d\n",
         Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_rate_err_feed)), data_source->planning_trj_status,
         lat_err, lat_err_spd,
         phoenix_com_rad2deg_f(cur_pos->yaw_rate), phoenix_com_rad2deg_f(yaw_rate_spd), phoenix_com_rad2deg_f(yaw_rate_err), phoenix_com_rad2deg_f(tar_yaw_rate_spd),
         phoenix_com_rad2deg_f(tar_yaw_rate), phoenix_com_rad2deg_f(tar_yaw_rate_err_dev), feed_dir_flag_description[feed_dir_flag],
         phoenix_com_rad2deg_f(corrected_yaw_rate_err), phoenix_com_rad2deg_f(yaw_rate_spd), err_lv_idx, spd_lv_idx);
  printf("    P: v_ratio=%0.4f, w_ratio=%0.4f, kp=%0.4f, p=%0.3f, p_value=%0.2f, h=%0.2f\n",
         kp_crt_by_spd, kp_crt_by_wgt, kp_yaw_rate_err, phoenix_com_rad2deg_f(p_value_yaw_rate_err),
         phoenix_com_rad2deg_f(ins->yaw_rate_err_feed.p_value), hunting_gain_p);
  printf("    I: v_ratio=%0.4f, w_ratio=%0.4f, ki=%0.4f, i=%0.4f, i_value=%0.4f\n",
         ki_crt_by_spd, ki_crt_by_wgt, ki_yaw_rate_err, phoenix_com_rad2deg_f(i_value_yaw_rate_err),
         phoenix_com_rad2deg_f(ins->yaw_rate_err_feed.i_value));
  printf("    D: v_ratio=%0.4f, w_ratio=%0.4f, kd=%0.4f, d=%0.3f, d_value=%0.2f, h=%0.2f\n",
         kd_crt_by_spd, kd_crt_by_wgt, kd_yaw_rate_err, phoenix_com_rad2deg_f(d_value_yaw_rate_err),
         phoenix_com_rad2deg_f(ins->yaw_rate_err_feed.d_value), hunting_gain_d);
//#endif

  // 保存调试信息
  status_info->yaw_rate_err_feed.yaw_rate_err = corrected_yaw_rate_err;
  status_info->yaw_rate_err_feed.tar_yaw_rate_spd = tar_yaw_rate_spd;
  status_info->yaw_rate_err_feed.yaw_rate_spd = yaw_rate_spd;
  status_info->yaw_rate_err_feed.yaw_rate_err_lv_idx = err_lv_idx;
  status_info->yaw_rate_err_feed.yaw_rate_spd_lv_idx = spd_lv_idx;
  status_info->yaw_rate_err_feed.p_feed.v_ratio = kp_crt_by_spd;
  status_info->yaw_rate_err_feed.p_feed.w_ratio = kp_crt_by_wgt;
  status_info->yaw_rate_err_feed.p_feed.k_ratio = kp_yaw_rate_err;
  status_info->yaw_rate_err_feed.p_feed.k_value = p_value_yaw_rate_err;
  status_info->yaw_rate_err_feed.p_feed.feed = ins->yaw_rate_err_feed.p_value;
  status_info->yaw_rate_err_feed.i_feed.v_ratio = ki_crt_by_spd;
  status_info->yaw_rate_err_feed.i_feed.w_ratio = ki_crt_by_wgt;
  status_info->yaw_rate_err_feed.i_feed.k_ratio = ki_yaw_rate_err;
  status_info->yaw_rate_err_feed.i_feed.k_value = i_value_yaw_rate_err;
  status_info->yaw_rate_err_feed.i_feed.feed = ins->yaw_rate_err_feed.i_value;
  status_info->yaw_rate_err_feed.d_feed.v_ratio = kd_crt_by_spd;
  status_info->yaw_rate_err_feed.d_feed.w_ratio = kd_crt_by_wgt;
  status_info->yaw_rate_err_feed.d_feed.k_ratio = kd_yaw_rate_err;
  status_info->yaw_rate_err_feed.d_feed.k_value = d_value_yaw_rate_err;
  status_info->yaw_rate_err_feed.d_feed.feed = ins->yaw_rate_err_feed.d_value;
  status_info->yaw_rate_err_feed.feed_value = ins->yaw_rate_err_feed.p_value + ins->yaw_rate_err_feed.d_value;
}


/*
 * @brief 重置反馈补偿控制器
* @param[in] ins 成员变量
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/04/08  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static void ResetFeedBackController(
    LatCtlPidInstance_t* const ins) {
  // 重置横向误差反馈补偿控制器
  ResetLatErrFeedController(ins);
  // 重置横向误差速率反馈补偿控制器
  ResetLatSpdFeedController(ins);
  // 重置横向角度误差反馈补偿控制器
  ResetYawErrFeedController(ins);

  // 重置角速度误差反馈补偿控制器
  ResetYawRateErrFeedController(ins);

  // 初始化反馈控制结构体
  phoenix_com_memset(
      &(ins->lat_feedback), 0, sizeof(ins->lat_feedback));

  phoenix_com_memset(
    ins->lat_feedback.filter.tar_yaw_rate_spd_queue.data_buf, 0, 
    sizeof(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.ring_buf), LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE,
      sizeof(Float32_t), ins->lat_feedback.filter.tar_yaw_rate_spd_queue.data_buf);
}

/*
 * @brief 计算反馈补偿值
 * @param[in] instance 成员变量
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[in] tar_yaw_rate 目标角速度
 * @param[out] status_info 内部状态信息
 * @return 反馈补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/04/08  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcFeedBackValue(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    Float32_t tar_yaw_rate,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t timestamp = data_source->timestamp;
  Int64_t time_elapsed_ms = 0;
  Float32_t time_elapsed = 0.0F;
  Float32_t feed_value_pd = 0.0F;
  Float32_t feed_value_i = 0.0F;
  // 角速度误差及其变化率
  const Float32_t lat_err = ins->status.synthetic_lat_err;
  const Float32_t lat_err_spd = ins->status.synthetic_lat_spd;
  const Float32_t yaw_rate_err = tar_yaw_rate - cur_pos->yaw_rate;
  const Float32_t yaw_rate_spd = cur_pos->yaw_rate_chg_rate;
  // 出现蛇形时，减小控制增益
  Float32_t hunting_gain_pd = 1.0F;
  Float32_t hunting_gain_1 = ins->hunting_detector.yaw_rate.hunting_gain;
  Float32_t hunting_gain_2 = 1.0F;
  Bool_t saltation_suppress = False_t;

  // 超时检测
  time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, timestamp);
  time_elapsed = 0.001F * time_elapsed_ms;
  if ((time_elapsed_ms > 300) || (time_elapsed_ms < 0)) {
    ResetFeedBackController(ins);
  }

  // 横向误差补偿
  CalcFeedValueFromLatErr(ins, data_source, cur_pos, status_info);
  // 横向误差速率补偿
  CalcFeedValueFromLatSpd(ins, data_source, cur_pos, status_info);
  // 航向角误差补偿
  CalcFeedValueFromYawErr(ins, data_source, cur_pos, status_info);

  // 角速度误差补偿值
  CalcFeedValueFromYawRateErr(ins, data_source, cur_pos, tar_yaw_rate, status_info);

  // 计算反馈值
  feed_value_pd = 
      ins->lat_err_feed.p_value + ins->lat_err_feed.d_value +
      ins->lat_spd_feed.p_value + ins->lat_spd_feed.d_value +
      ins->yaw_err_feed.p_value + ins->yaw_err_feed.d_value +
      ins->yaw_rate_err_feed.p_value + ins->yaw_rate_err_feed.d_value;
  feed_value_i = 
      ins->lat_err_feed.i_value +
      ins->lat_spd_feed.i_value +
      ins->yaw_err_feed.i_value +
      ins->yaw_rate_err_feed.i_value;

#if 0
  // 根据曲率变化，适当放大补偿值
  if (True_t) {
    static const Float128_t kCurvatureThreshold = 0.0001F;
    Float32_t abs_curr_curvature = phoenix_com_abs_f(ins->ref_trj_info.curr_curvature);
    Float32_t abs_prev_curvature = phoenix_com_abs_f(ins->ref_trj_info.prev_curvature);
    Float32_t curvature_diff = ins->ref_trj_info.curr_curvature - ins->ref_trj_info.prev_curvature;
    Float32_t curve_threshold = 0.1F * (abs_curr_curvature > abs_prev_curvature ? abs_curr_curvature : abs_prev_curvature);
    curve_threshold = curve_threshold > kCurvatureThreshold ? curve_threshold : kCurvatureThreshold;
    Float32_t key_yaw_rate = phoenix_com_abs_f(curvature_diff*cur_pos->v);
    Float32_t ex_i_ratio = key_yaw_rate * 15.0F;
    if (ex_i_ratio > 0.5F) {
      ex_i_ratio = 0.5F;
    }
    if (curvature_diff > curve_threshold) {
      // 出右弯 or 入左弯, 允许向左较大的补偿
      if (feed_value_i > 0.0F) {
#if 1
        printf("  出右弯 or 入左弯, 允许向左较大的补偿 curv_diff=%0.6f, key=%0.2f, ex_i=%0.3f, ratio=%0.2f\n",
               curvature_diff, key_yaw_rate*57.3F, feed_value_i*ex_i_ratio*57.3F, ex_i_ratio);
#endif
        feed_value_i += feed_value_i * ex_i_ratio;
      }
    } else if (curvature_diff < -curve_threshold) {
      // 出左弯 or 入右弯, 允许向右较大的补偿
      if (feed_value_i < 0.0F) {
#if 1
        printf("  出左弯 or 入右弯, 允许向右较大的补偿, curv_diff=%0.6f, key=%0.2f, ex_i=%0.3f, ratio=%0.2f\n",
               curvature_diff, key_yaw_rate*57.3F, feed_value_i*ex_i_ratio*57.3F, ex_i_ratio);
#endif
        feed_value_i += feed_value_i * ex_i_ratio;
      }
    } else {
      // 轨迹曲率不变 (直线 or 弯道), 不允许较大的角速度变化率
      // nothing to do
    }
  }
#endif

#if 0
  Float32_t ext_i_ratio = data_source->ref_trj_curvature * 600.0F;
  if ((data_source->ref_trj_curvature > 0.0001F) && (feed_value_i > 0.0F)) {
    feed_value_i += feed_value_i * ext_i_ratio;
    //printf("---> curv=%0.4f, exi_i=%0.5f, ratio=%0.2f\n", 
    //    data_source->ref_trj_curvature, feed_value_i * ext_i_ratio, ext_i_ratio);
  } else if ((data_source->ref_trj_curvature < -0.0001F) && (feed_value_i < 0.0F)) {
    feed_value_i -= feed_value_i * ext_i_ratio;
    //printf("---> curv=%0.4f, exi_i=%0.5f, ratio=%0.2f\n", 
    //    data_source->ref_trj_curvature, -feed_value_i * ext_i_ratio, ext_i_ratio);
  } else {
    // nothing to do
  }
#endif

  // 蛇行抑制
#if (HUNTING_SUPPRESS_MODE == HUNTING_SUPPRESS_MODE_II)
  // PD 部分
  hunting_gain_2 = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByStrAng(
        &(ins->perf_ana.analyser), feed_value_pd, data_source->cur_pos.v);
  hunting_gain_pd = (hunting_gain_1 < hunting_gain_2) ? hunting_gain_1 : hunting_gain_2;
  // printf(">>>(lat_feed_pd) hunting_gain_1=%0.2f, hunting_gain_2=%0.2f, hunting_gain=%0.2f\n",
  //     hunting_gain_1, hunting_gain_2, hunting_gain_pd);
  feed_value_pd *= hunting_gain_pd;
#endif
  // 积分部分
  feed_value_i *= hunting_gain_1;

  // 限制补偿的增量
#if (LAT_FEED_BACK_CHG_LIMIT_MODE == LAT_FEED_BACK_CHG_LIMIT_MODE_II)
  // 平滑返回的补偿值
  saltation_suppress = 
      Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_err_feed)) ||
      Phoenix_Com_Timer_IsActive(&(ins->timers.smt_lat_spd_feed)) ||
      Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_err_feed)) ||
      Phoenix_Com_Timer_IsActive(&(ins->timers.smt_yaw_rate_err_feed));
  Float32_t max_step_gain = 0.4F * 0.017453293F;
  if (saltation_suppress) {
    max_step_gain = 0.2F * 0.017453293F;
  }
  // PD
  Float32_t pd_value_diff = feed_value_pd - ins->lat_feedback.pd_value;
  if (pd_value_diff > max_step_gain) {
    ins->lat_feedback.pd_value = ins->lat_feedback.pd_value + max_step_gain;
  } else if (pd_value_diff < -max_step_gain) {
    ins->lat_feedback.pd_value = ins->lat_feedback.pd_value - max_step_gain;
  } else {
    ins->lat_feedback.pd_value = feed_value_pd;
  }
#else
  ins->lat_feedback.pd_value = feed_value_pd;
#endif

  // 积分累加
  if (cur_pos->v < 5.0F/3.6F  /* 车速低， 清除积分 */) {
    // 当清除积分值时, 每次减小的积分值
    static const Float32_t kStepOfReducingIValue = 0.01F*0.017453293F;
    if (ins->lat_feedback.i_value > kStepOfReducingIValue) {
      ins->lat_feedback.i_value -= kStepOfReducingIValue;
    } else if (ins->lat_feedback.i_value < -kStepOfReducingIValue) {
      ins->lat_feedback.i_value += kStepOfReducingIValue;
    } else {
      ins->lat_feedback.i_value = 0.0F;
    }
  } else {
    ins->lat_feedback.i_value += feed_value_i;
  }

#if (ENTER_PLAYBACK_MODE)
  // 回放bag时，不计算积分值
  Float32_t lat_err = ins->status.synthetic_lat_err;
  Float32_t lat_spd = ins->status.synthetic_lat_spd;
  Float32_t abs_lat_err = phoenix_com_abs_f(lat_err);
  Float32_t abs_lat_spd = phoenix_com_abs_f(lat_spd);
  if ((abs_lat_err < 0.1F) && (abs_lat_spd < 0.1F)) {
    ins->lat_feedback.i_value = 0.0F;
  }
#endif

  // 整个的补偿值
  Float32_t total_feed = ins->lat_feedback.pd_value + ins->lat_feedback.i_value;
  Float32_t feed_inc = total_feed - ins->lat_feedback.feed_value;

  // 计算目标横摆角速度变化率
  Float32_t raw_tar_yaw_rate_spd = 0.0F;
  Float32_t tar_yaw_rate_spd = 0.0F;
  if (ins->lat_feedback.filter.valid) {
    raw_tar_yaw_rate_spd = Phoenix_VehModel_CalcYawRateFromSteeringAngle(feed_inc, cur_pos->v) / time_elapsed;
  } else {
    raw_tar_yaw_rate_spd = 0.0F;
  }
  if (Phoenix_Com_RingBuffer_IsFull(&(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.ring_buf))) {
    tar_yaw_rate_spd = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, 
        ins->lat_feedback.filter.tar_yaw_rate_spd, raw_tar_yaw_rate_spd, 
        *(Float32_t*)Phoenix_Com_RingBuffer_GetFront(&(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.ring_buf)));
  } else {
    tar_yaw_rate_spd = Phoenix_Com_Filter_MovingAverage_f(
        LAT_CTL_D1_YAW_RATE_FILTER_WND_SIZE, 
        Phoenix_Com_RingBuffer_GetSize(&(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.ring_buf)), 
        ins->lat_feedback.filter.tar_yaw_rate_spd, raw_tar_yaw_rate_spd, 0.0F);
  }
  Phoenix_Com_RingBuffer_PushBackOverride(
        &(ins->lat_feedback.filter.tar_yaw_rate_spd_queue.ring_buf), &(raw_tar_yaw_rate_spd));

  // 限制补偿的增量
static const Float32_t s_key_tab_feed_value_inc_limit[LAT_CTL_PID_LERP_TABLE_SIZE] = {
   0.00F*0.017453293F,   1.00F*0.017453293F,   2.00F*0.017453293F,   3.00F*0.017453293F,   4.00F*0.017453293F,
   5.00F*0.017453293F,   6.00F*0.017453293F,   7.00F*0.017453293F,   8.00F*0.017453293F,   9.00F*0.017453293F,
  10.00F*0.017453293F,  11.00F*0.017453293F,  12.00F*0.017453293F,  13.00F*0.017453293F,  14.00F*0.017453293F,
  15.00F*0.017453293F,  16.00F*0.017453293F,  17.00F*0.017453293F,  18.00F*0.017453293F,  19.00F*0.017453293F,
  20.00F*0.017453293F,  21.00F*0.017453293F,  22.00F*0.017453293F,  23.00F*0.017453293F,  24.00F*0.017453293F,
};

static const Float32_t s_val_tab_feed_value_inc_limit[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  3.00F*0.017453293F,  2.50F*0.017453293F,  2.00F*0.017453293F,  1.50F*0.017453293F,  1.00F*0.017453293F,
  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,
  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,
  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,
  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,  0.80F*0.017453293F,
};

static const Float32_t s_key_tab_feed_value_inc_limit_yaw_rate[LAT_CTL_PID_LERP_TABLE_SIZE] = {
   0.00F*0.017453293F,   0.10F*0.017453293F,   0.20F*0.017453293F,   0.30F*0.017453293F,   0.40F*0.017453293F,
   0.50F*0.017453293F,   0.60F*0.017453293F,   0.70F*0.017453293F,   0.80F*0.017453293F,   0.90F*0.017453293F,
   1.00F*0.017453293F,   1.10F*0.017453293F,   1.20F*0.017453293F,   1.30F*0.017453293F,   1.40F*0.017453293F,
   1.50F*0.017453293F,   1.60F*0.017453293F,   1.70F*0.017453293F,   1.80F*0.017453293F,   1.90F*0.017453293F,
   2.00F*0.017453293F,   2.10F*0.017453293F,   2.20F*0.017453293F,   2.30F*0.017453293F,   2.40F*0.017453293F,
};

static const Float32_t s_val_tab_feed_value_inc_limit_yaw_rate[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  3.00F*0.017453293F,  2.50F*0.017453293F,  2.00F*0.017453293F,  0.80F*0.017453293F,  0.50F*0.017453293F,
  0.40F*0.017453293F,  0.30F*0.017453293F,  0.20F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,
  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,
  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,
  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,  0.10F*0.017453293F,
};

static const Float32_t s_key_tab_feed_value_inc_limit_lat_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
   0.00F,   0.10F,   0.20F,   0.30F,   0.40F,
   0.50F,   0.60F,   0.70F,   0.80F,   0.90F,
   1.00F,   1.10F,   1.20F,   1.30F,   1.40F,
   1.50F,   1.60F,   1.70F,   1.80F,   1.90F,
   2.00F,   2.10F,   2.20F,   2.30F,   2.40F,
};

static const Float32_t s_val_tab_feed_value_inc_limit_lat_err[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F*0.017453293F,  0.00F*0.017453293F,  0.10F*0.017453293F,  0.20F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,  0.30F*0.017453293F,
};

static const Float32_t s_val_tab_feed_value_inc_limit_lat_spd[LAT_CTL_PID_LERP_TABLE_SIZE] = {
  0.00F*0.017453293F,  0.10F*0.017453293F,  0.20F*0.017453293F,  0.40F*0.017453293F,  0.60F*0.017453293F,
  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,
  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,
  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,
  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,  0.60F*0.017453293F,
};

#if 0
#if 1
  total_feed = ins->lat_feedback.pd_value + ins->lat_feedback.i_value;
  feed_inc = total_feed - ins->lat_feedback.feed_value;
  Float32_t key_ratio_feed_lmt = 0.0F;
  Int32_t key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(feed_value_pd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_1 = 0.5F * 0.017453293F;
  max_step_feed_1 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_yaw_rate, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(yaw_rate_spd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_2 = 0.5F * 0.017453293F;
  max_step_feed_2 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_err = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);
  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err_spd), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_spd = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  Bool_t lmt_cond_1 = (feed_value_pd > 5.0F * 0.017453293F) && (feed_inc > max_step_feed_1);
  Bool_t lmt_cond_2 = (feed_value_pd < -5.0F * 0.017453293F) && (feed_inc < -max_step_feed_1);
  Bool_t lmt_cond_3 = (feed_value_pd > 3.0F * 0.017453293F) && 
                      (yaw_rate_spd > 0.2 * 0.017453293F) && (feed_inc > max_step_feed_2);
  Bool_t lmt_cond_4 = (feed_value_pd < -3.0F * 0.017453293F) && 
                      (yaw_rate_spd < -0.2 * 0.017453293F) && (feed_inc < -max_step_feed_2);

  printf("增量限制 [%d,%d] feed_value_pd=%0.2f, max_step_1=%0.2f\n"
         "         [%d,%d]  yaw_rate_spd=%0.2f, max_step_2=%0.2f, feed_inc=%0.2f\n",
         lmt_cond_1, lmt_cond_2, 
         feed_value_pd*57.3F, max_step_feed_1*57.3F, 
         lmt_cond_3, lmt_cond_4,
         yaw_rate_spd*57.3F, max_step_feed_2*57.3F, feed_inc*57.3F);

  if (lmt_cond_1 || lmt_cond_3) {
    // 正向增量抑制
    Float32_t max_step_feed = max_step_feed_1;
    if (lmt_cond_1 && lmt_cond_3) {
      max_step_feed = max_step_feed_1 < max_step_feed_2 ? max_step_feed_1 : max_step_feed_2;
    } else if (lmt_cond_1 && !lmt_cond_3) {
      max_step_feed = max_step_feed_1;
    } else if (!lmt_cond_1 && lmt_cond_3) {
      max_step_feed = max_step_feed_2;
    } else {
      // nothing to do
    }

    // 若车辆在向右偏离，适当放开限制
    if ((lat_err_spd < 0.0F) && (yaw_rate_spd  < 0.3F*0.017453293F)) {
      printf("放开增量抑制1: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err < 0.0F) {
        printf("放开增量抑制2: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc - max_step_feed;
    if (feed_value_i > extra_feed) {
      printf("正向增量抑制1: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
            max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("正向增量抑制2: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else if (lmt_cond_2 || lmt_cond_4) {
    // 负向增量抑制
    Float32_t max_step_feed = max_step_feed_1;
    if (lmt_cond_2 && lmt_cond_4) {
      max_step_feed = max_step_feed_1 < max_step_feed_2 ? max_step_feed_1 : max_step_feed_2;
    } else if (lmt_cond_2 && !lmt_cond_4) {
      max_step_feed = max_step_feed_1;
    } else if (!lmt_cond_2 && lmt_cond_4) {
      max_step_feed = max_step_feed_2;
    } else {
      // nothing to do
    }

    // 若车辆在向左偏离，适当放开限制
    if (lat_err_spd > 0.0F && (yaw_rate_spd  > -0.3F*0.017453293F)) {
      printf("放开增量抑制3: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err > 0.0F) {
        printf("放开增量抑制4: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc + max_step_feed;
    if (feed_value_i < extra_feed) {
      printf("负向增量抑制3: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("负向增量抑制4: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else {
    // nothing to do
  }
#else
  total_feed = ins->lat_feedback.pd_value + ins->lat_feedback.i_value;
  feed_inc = total_feed - ins->lat_feedback.feed_value;
  Float32_t key_ratio_feed_lmt = 0.0F;
  Int32_t key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(feed_value_pd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_1 = 0.5F * 0.017453293F;
  max_step_feed_1 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_yaw_rate, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(yaw_rate_spd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_2 = 0.5F * 0.017453293F;
  max_step_feed_2 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_err = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);
  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err_spd), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_spd = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  Bool_t lmt_cond_1 = (feed_value_pd > 5.0F * 0.017453293F) && (feed_inc > max_step_feed_1);
  Bool_t lmt_cond_2 = (feed_value_pd < -5.0F * 0.017453293F) && (feed_inc < -max_step_feed_1);
  Bool_t lmt_cond_3 = (feed_value_pd > 3.0F * 0.017453293F) && 
                      (yaw_rate_spd > 0.2 * 0.017453293F) && (feed_inc > max_step_feed_2);
  Bool_t lmt_cond_4 = (feed_value_pd < -3.0F * 0.017453293F) && 
                      (yaw_rate_spd < -0.2 * 0.017453293F) && (feed_inc < -max_step_feed_2);

  printf("增量限制 [%d,%d] feed_value_pd=%0.2f, max_step_1=%0.2f\n"
         "         [%d,%d]  yaw_rate_spd=%0.2f, max_step_2=%0.2f, feed_inc=%0.2f\n",
         lmt_cond_1, lmt_cond_2, 
         feed_value_pd*57.3F, max_step_feed_1*57.3F, 
         lmt_cond_3, lmt_cond_4,
         yaw_rate_spd*57.3F, max_step_feed_2*57.3F, feed_inc*57.3F);

  if (lmt_cond_3) {
    // 正向增量抑制
    Float32_t max_step_feed = max_step_feed_2;

    // 若车辆在向右偏离，适当放开限制
    if ((lat_err_spd < 0.0F) && (yaw_rate_spd  < 0.3F*0.017453293F)) {
      printf("放开增量抑制1: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err < 0.0F) {
        printf("放开增量抑制2: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc - max_step_feed;
    if (feed_value_i > extra_feed) {
      printf("正向增量抑制1: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
            max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("正向增量抑制2: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else if (lmt_cond_4) {
    // 负向增量抑制
    Float32_t max_step_feed = max_step_feed_2;

    // 若车辆在向左偏离，适当放开限制
    if ((lat_err_spd > 0.0F) && (yaw_rate_spd > -0.3F*0.017453293F)) {
      printf("放开增量抑制3: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err > 0.0F) {
        printf("放开增量抑制4: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc + max_step_feed;
    if (feed_value_i < extra_feed) {
      printf("负向增量抑制3: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("负向增量抑制4: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else {
    // nothing to do
  }
#endif
#endif

  total_feed = ins->lat_feedback.pd_value + ins->lat_feedback.i_value;
  feed_inc = total_feed - ins->lat_feedback.feed_value;
  Float32_t key_ratio_feed_lmt = 0.0F;
  Int32_t key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(feed_value_pd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_1 = 0.5F * 0.017453293F;
  max_step_feed_1 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_yaw_rate, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(yaw_rate_spd), &key_ratio_feed_lmt);
  Float32_t max_step_feed_2 = 0.5F * 0.017453293F;
  max_step_feed_2 = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_yaw_rate[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_err = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_err[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);
  key_idx_feed_lmt = Phoenix_Common_LerpInOrderedTable_f(
      s_key_tab_feed_value_inc_limit_lat_err, LAT_CTL_PID_LERP_TABLE_SIZE,
      phoenix_com_abs_f(lat_err_spd), &key_ratio_feed_lmt);
  Float32_t step_lmt_lat_spd = Phoenix_Common_Lerp_f(
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt],
      s_val_tab_feed_value_inc_limit_lat_spd[key_idx_feed_lmt+1],
      key_ratio_feed_lmt);

  Bool_t lmt_cond_1 = (feed_value_pd > 5.0F * 0.017453293F) && (feed_inc > max_step_feed_1);
  Bool_t lmt_cond_2 = (feed_value_pd < -5.0F * 0.017453293F) && (feed_inc < -max_step_feed_1);
  Bool_t lmt_cond_3 = (feed_value_pd > 3.0F * 0.017453293F) && 
                      (yaw_rate_spd > 0.2 * 0.017453293F) && (feed_inc > max_step_feed_2);
  Bool_t lmt_cond_4 = (feed_value_pd < -3.0F * 0.017453293F) && 
                      (yaw_rate_spd < -0.2 * 0.017453293F) && (feed_inc < -max_step_feed_2);

  printf("增量限制 [%d,%d] feed_value_pd=%0.2f, max_step_1=%0.2f\n"
         "         [%d,%d]  yaw_rate_spd=%0.2f, max_step_2=%0.2f, feed_inc=%0.2f\n",
         lmt_cond_1, lmt_cond_2, 
         feed_value_pd*57.3F, max_step_feed_1*57.3F, 
         lmt_cond_3, lmt_cond_4,
         yaw_rate_spd*57.3F, max_step_feed_2*57.3F, feed_inc*57.3F);

  if (lmt_cond_1) {
    // 正向增量抑制
    Float32_t max_step_feed = max_step_feed_1;

    // 若车辆在向右偏离，适当放开限制
    if ((lat_err_spd < 0.0F) && (yaw_rate_spd  < 0.3F*0.017453293F)) {
      printf("放开增量抑制1: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err < 0.0F) {
        printf("放开增量抑制2: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc - max_step_feed;
    if (feed_value_i > extra_feed) {
      printf("正向增量抑制1: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
            max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("正向增量抑制2: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else if (lmt_cond_2) {
    // 负向增量抑制
    Float32_t max_step_feed = max_step_feed_1;

    // 若车辆在向左偏离，适当放开限制
    if (lat_err_spd > 0.0F && (yaw_rate_spd  > -0.3F*0.017453293F)) {
      printf("放开增量抑制3: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_spd)*57.3F);
      max_step_feed += step_lmt_lat_spd;
      if (lat_err > 0.0F) {
        printf("放开增量抑制4: from %0.2f to %0.2f\n", max_step_feed*57.3F, (max_step_feed+step_lmt_lat_err)*57.3F);
        max_step_feed += step_lmt_lat_err;
      }
    }

    Float32_t extra_feed = feed_inc + max_step_feed;
    if (feed_value_i < extra_feed) {
      printf("负向增量抑制3: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, extra_feed*57.3F);

      feed_value_i -= extra_feed;
      ins->lat_feedback.i_value -= extra_feed;
    } else {
      printf("负向增量抑制4: max=%0.2f, feed_inc=%0.2f, i_value -= %0.2f, pd_value -= %0.2f\n", 
             max_step_feed*57.3F, feed_inc*57.3F, feed_value_i*57.3F, (extra_feed - feed_value_i)*57.3F);

      feed_value_i = 0.0F;
      ins->lat_feedback.i_value -= feed_value_i;
      ins->lat_feedback.pd_value -= extra_feed - feed_value_i;
    }
  } else {
    // nothing to do
  }
  
  // 限制PD的最大值
  static const Float32_t kMaxFeedValuePD = 15.0F * 0.017453293F;
  if(ins->lat_feedback.pd_value > kMaxFeedValuePD) {
    ins->lat_feedback.pd_value = kMaxFeedValuePD;
  } else if(ins->lat_feedback.pd_value < -kMaxFeedValuePD) {
    ins->lat_feedback.pd_value = -kMaxFeedValuePD;
  } else {
    // nothing to do
  }
  // 限制I的最大值
  static const Float32_t kMaxFeedValueI = 25.0F * 0.017453293F;
  if (ins->lat_feedback.i_value > kMaxFeedValueI) {
    ins->lat_feedback.i_value = kMaxFeedValueI;
  } else if (ins->lat_feedback.i_value < -kMaxFeedValueI) {
    ins->lat_feedback.i_value = -kMaxFeedValueI;
  } else {
    // nothing to do
  }

  // 合计的反馈值
  ins->lat_feedback.feed_value = 
      ins->lat_feedback.pd_value + ins->lat_feedback.i_value;
  // 限制合计的反馈值
  static const Float32_t kMaxLatFeedValue = 25.0F * 0.017453293F;
  if (ins->lat_feedback.feed_value > kMaxLatFeedValue) {
    ins->lat_feedback.feed_value = kMaxLatFeedValue;
  } else if (ins->lat_feedback.feed_value < -kMaxLatFeedValue) {
    ins->lat_feedback.feed_value = -kMaxLatFeedValue;
  } else {
    // nothing to do
  }

  // 保存滤波相关的量
  ins->lat_feedback.filter.valid = 1;
  ins->lat_feedback.filter.tar_yaw_rate_spd = tar_yaw_rate_spd;

#if (ENABLE_LAT_CTL_PID_TRACE)
  printf("===== Feed back: saltation_suppress=%d, hunting[#1=%0.2f, #2=%0.2f, pd=%0.2f]\n"
         "    feed_value_pd=%0.2f, feed_value_i=%0.2f\n"
         "    pd_value=%0.2f, i_value=%0.2f, feed_value=%0.2f\n",
         saltation_suppress, hunting_gain_1, hunting_gain_2, hunting_gain_pd,
         feed_value_pd*57.29578F, feed_value_i*57.29578F,
         ins->lat_feedback.pd_value*57.29578F, ins->lat_feedback.i_value*57.29578F, ins->lat_feedback.feed_value*57.29578F);
#endif

  // 保存调试信息 (!!! 借用了横向误差的调试信息)
  status_info->lat_err_feed.p_feed.feed = ins->lat_err_feed.p_value + ins->lat_err_feed.d_value;
  status_info->lat_err_feed.i_feed.feed = ins->lat_feedback.i_value;
  status_info->lat_err_feed.d_feed.feed = ins->lat_spd_feed.p_value + ins->lat_spd_feed.d_value;
  status_info->lat_err_feed.feed_value = 
      status_info->lat_err_feed.p_feed.feed + 
      status_info->lat_err_feed.i_feed.feed + 
      status_info->lat_err_feed.d_feed.feed;

  return (ins->lat_feedback.feed_value);
}


/*
 * @brief 重置动态特性补偿控制器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void ResetDynamicFeedController(LatCtlPidInstance_t* const instance) {
  Int32_t ret = 0;

  phoenix_com_memset(&(instance->dynamic_feedforward), 0,
                     sizeof(instance->dynamic_feedforward));

  /// (借用横向误差的补偿表)
  ret = Phoenix_Com_FuzzyPID_Init(
        &(instance->dynamic_feedforward.pid_controller),
        &(instance->param.tab_lat_err_level),
        &(instance->param.tab_lat_err_spd_level));
  if (ret < 0) {
    LOG_ERR_C("Failed to initialize dynamic pid controller.");
    COM_CHECK_C(0 == ret);
  }
  /// (借用横向误差的补偿表)
  ret = Phoenix_Com_FuzzyPID_SetGainTable(
        &(instance->dynamic_feedforward.pid_controller), 1,
        &(instance->param.i_gain_tab_lat_err_feed));
  if (ret < 0) {
    LOG_ERR_C("Failed to set I gain table of dynamic pid controller.");
    COM_CHECK_C(0 == ret);
  }
}

/*
 * @brief 计算车辆动态特性补偿值
 * @param[in] instance 成员变量
 * @param[in] data_source 控制器所需要的数据
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[in] tar_curvature_from_trj 轨迹前馈值
 * @return 车辆动态特性补偿值
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcFeedValueFromVehDynamic(
    LatCtlPidInstance_t* const instance,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    Float32_t tar_curvature_from_trj,
    LateralControlPidInfo_t* const status_info) {
  // 当清除积分值时, 每次减小的积分值
  const static Float32_t kStepOfReducingIValue = 0.01F*0.017453293F;
  // 是否清除积分值
  Int32_t clear_i_value = 0;
  // 车辆动态特性补偿
  // 时间戳
  Int64_t timestamp = data_source->timestamp;
  Int64_t time_elapsed = 0;
  // 误差及其变化率
  Float32_t lat_err = 0.0F;
  Float32_t lat_err_v = 0.0F;
  Float32_t abs_lat_err = 0.0F;
  Float32_t abs_lat_err_v = 0.0F;
  // PID 控制器
  FuzzyPID_t* pid_controller = &(instance->dynamic_feedforward.pid_controller);
  // 误差及其变化率的等级索引
  Int32_t err_lv_idx = 0;
  Int32_t err_spd_lv_idx = 0;
  // 补偿值
  Float32_t ki_lat_err = 0.0F;
  Float32_t i_value_lat_err = 0.0F;
  Float32_t max_value_i = 0.0F;
  Float32_t min_value_i = 0.0F;
  // 动态特性补偿用的轨迹曲率
  Float32_t curvature = 0.0F;
  Float32_t key_ratio_for_curv = 0.0F;
  Int32_t key_idx_for_curv = Phoenix_Common_LerpInOrderedTable_f(
        instance->param.key_tab_dynamic_feed_by_spd,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        cur_pos->v,
        &key_ratio_for_curv);
  Float32_t feed_ratio_for_curv = Phoenix_Common_Lerp_f(
        instance->param.gain_tab_dynamic_feed_by_spd[key_idx_for_curv],
        instance->param.gain_tab_dynamic_feed_by_spd[key_idx_for_curv+1],
        key_ratio_for_curv);
  // 根据重量修调补偿量
  // Float32_t weight = 10000.0F; // 空载(D17-B2)
  // Float32_t weight = 50000.0F; // 满载(D17-B2)
  Float32_t weight = data_source->chassis.gross_weight;
  Float32_t key_ratio_for_wgt = 0.0F;
  Int32_t key_idx_for_wgt = Phoenix_Common_LerpInOrderedTable_f(
        instance->param.key_tab_dynamic_feed_by_weight,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        weight,
        &key_ratio_for_wgt);
  Float32_t feed_ratio_for_wgt = Phoenix_Common_Lerp_f(
        instance->param.gain_tab_dynamic_feed_by_weight[key_idx_for_wgt],
        instance->param.gain_tab_dynamic_feed_by_weight[key_idx_for_wgt+1],
        key_ratio_for_wgt);
  // 车辆动态特性补偿值
  Float32_t dynamic_feed = 0.0F;

  // 计算车辆动态特性补偿值
#if 0
  if (phoenix_com_abs_f(data_source->ref_trj_curvature) <
      phoenix_com_abs_f(tar_curvature_from_trj)) {
    curvature = data_source->ref_trj_curvature;
  } else {
    curvature = tar_curvature_from_trj;
  }
#else
  curvature = data_source->ref_trj_curvature;
#endif

#if (ENABLE_LAT_CTL_PID_TRACE)
  printf("### trj_curvature=%0.4f, tar_curvature=%0.4f, curvature_dynamic=%0.4f\n",
         data_source->ref_trj_curvature, tar_curvature_from_trj, curvature);
#endif

  // 获取误差及其变化率
  lat_err = data_source->lat_err.samples[0].lat_err;
  lat_err_v = data_source->lat_err.samples[0].lat_err_chg_rate;
  abs_lat_err = phoenix_com_abs_f(lat_err);
  abs_lat_err_v = phoenix_com_abs_f(lat_err_v);

  // 超时检测
  time_elapsed = Phoenix_Common_CalcElapsedClockMs(
        instance->timestamp, timestamp);
  if ((time_elapsed > 300) || (time_elapsed < 0)) {
    ResetDynamicFeedController(instance);
  }

  // 更新当前误差等级
  Phoenix_Com_FuzzyPID_UpdateErrLevel_f(pid_controller, lat_err, lat_err_v);
  err_lv_idx = pid_controller->err_level_idx_;
  err_spd_lv_idx = pid_controller->err_spd_level_idx_;

  // 计算当前PID增益
  ki_lat_err = Phoenix_Com_FuzzyPID_GetGain_f(pid_controller, 1);
  i_value_lat_err = ki_lat_err * lat_err;

#if (ENTER_PLAYBACK_MODE)
  i_value_lat_err = 0.0F;
#endif

  dynamic_feed =
      feed_ratio_for_curv * feed_ratio_for_wgt * cur_pos->v*cur_pos->v * curvature;
#if 0
  if (dynamic_feed > 0.0F) {
    max_value_i = 0.0F;
    min_value_i = -1.5F*dynamic_feed;
  } else {
    max_value_i = -1.5F*dynamic_feed;
    min_value_i = 0.0F;
  }
#else
  if (dynamic_feed > 0.0F) {
    max_value_i = 0.5F*dynamic_feed;
    min_value_i = -2.0F*dynamic_feed;
  } else {
    max_value_i = -2.0F*dynamic_feed;
    min_value_i = 0.5F*dynamic_feed;
  }
#endif

  /// 根据横向误差修正动态特性补偿(借用横向误差的补偿表)
  if ((abs_lat_err > 1.5F) ||
      ((abs_lat_err > 1.0F)  && (0 != data_source->lat_err.moving_flag) &&
       ((TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_LEFT_STAGE_II != data_source->planning_trj_status) &&
        (TRJ_PLAN_TRJ_STATUS_CHANGING_LANE_RIGHT_STAGE_II != data_source->planning_trj_status) &&
        (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_RIGHT_II != data_source->planning_trj_status) &&
        (TRJ_PLAN_TRJ_STATUS_ABORT_CHANGING_LANE_TO_LEFT_II != data_source->planning_trj_status)))) {
    instance->dynamic_feedforward.p_value = 0.0F;
    instance->dynamic_feedforward.d_value = 0.0F;

    // clear_i_value = 1;

    // printf("@@@ Don't feed, lat_err=%0.2f, moving=%d\n",
    //        lat_err, data_source->lat_err.moving_flag);
  } else {
    // P
    instance->dynamic_feedforward.p_value = 0.0F;

    // I
    if (abs_lat_err < 1.0F) {
      instance->dynamic_feedforward.i_value +=
          0.5F * i_value_lat_err;
    } else {
      // clear_i_value = 1;
    }

    // D
    instance->dynamic_feedforward.d_value = 0.0F;
  }

  if (clear_i_value) {
    if (instance->dynamic_feedforward.i_value > kStepOfReducingIValue) {
      instance->dynamic_feedforward.i_value -= kStepOfReducingIValue;
    } else if (instance->dynamic_feedforward.i_value < -kStepOfReducingIValue) {
      instance->dynamic_feedforward.i_value += kStepOfReducingIValue;
    } else {
      instance->dynamic_feedforward.i_value = 0.0F;
    }
  }

  // 限制I的最大值
  if (instance->dynamic_feedforward.i_value > max_value_i) {
    instance->dynamic_feedforward.i_value = max_value_i;
  } else if (instance->dynamic_feedforward.i_value < min_value_i) {
    instance->dynamic_feedforward.i_value = min_value_i;
  } else {
    // nothing to do
  }

  instance->dynamic_feedforward.feed_value =
      dynamic_feed +
      instance->dynamic_feedforward.i_value;

  // 限制最大补偿值
  if (instance->dynamic_feedforward.feed_value >
      instance->param.max_dynamic_feed_value) {
    instance->dynamic_feedforward.feed_value =
        instance->param.max_dynamic_feed_value;
  } else if (instance->dynamic_feedforward.feed_value <
      -instance->param.max_dynamic_feed_value) {
    instance->dynamic_feedforward.feed_value =
        -instance->param.max_dynamic_feed_value;
  } else {
    // nothing to do
  }

#if (ENABLE_LAT_CTL_PID_TRACE)
  printf("@@@ Dynamic_Feed: v=%0.1f, key_index=%d, key_ratio=%0.3f, "
         "feed_ratio=%0.3f, curvature=%0.3f, dynamic=%0.1f, i_value=%0.1f, feed_value=%0.1f\n",
         cur_pos->v*3.6f, key_idx_for_curv, key_ratio_for_curv,
         feed_ratio_for_curv, curvature,
         phoenix_com_rad2deg_f(dynamic_feed),
         phoenix_com_rad2deg_f(instance->dynamic_feedforward.i_value),
         phoenix_com_rad2deg_f(instance->dynamic_feedforward.feed_value));
#endif

  status_info->veh_dynamic_feed.trj_curvature = curvature;
  status_info->veh_dynamic_feed.p_feed.v_ratio = feed_ratio_for_curv;
  status_info->veh_dynamic_feed.p_feed.w_ratio = feed_ratio_for_wgt;
  status_info->veh_dynamic_feed.p_feed.k_ratio = cur_pos->v*cur_pos->v;
  status_info->veh_dynamic_feed.p_feed.k_value = dynamic_feed;
  status_info->veh_dynamic_feed.p_feed.feed = dynamic_feed;
  status_info->veh_dynamic_feed.i_feed.v_ratio = 0.5F;
  status_info->veh_dynamic_feed.i_feed.w_ratio = 1.0F;
  status_info->veh_dynamic_feed.i_feed.k_ratio = ki_lat_err;
  status_info->veh_dynamic_feed.i_feed.k_value = i_value_lat_err;
  status_info->veh_dynamic_feed.i_feed.feed = instance->dynamic_feedforward.i_value;
  status_info->veh_dynamic_feed.d_feed.v_ratio = 1.0F;
  status_info->veh_dynamic_feed.d_feed.w_ratio = 1.0F;
  status_info->veh_dynamic_feed.d_feed.k_ratio = 1.0F;
  status_info->veh_dynamic_feed.d_feed.k_value = 0.0F;
  status_info->veh_dynamic_feed.d_feed.feed = 0.0F;
  status_info->veh_dynamic_feed.feed_value = instance->dynamic_feedforward.feed_value;

  return (instance->dynamic_feedforward.feed_value);
}

/*
 * @brief 重置车辆蛇行检测器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/08/31  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void ResetLatHuntingDetector(LatCtlPidInstance_t* const instance) {
  instance->hunting_detector.yaw_rate.is_hunting = 0;
  instance->hunting_detector.yaw_rate.hunting_energy = 0.0F;
  instance->hunting_detector.yaw_rate.hunting_gain = 1.0F;
  InitializeLatCtlFFT(&(instance->hunting_detector.yaw_rate.fft_tar_yaw_rate));
  InitializeLatCtlFFT(&(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate));
}

/*
 * @brief 更新车辆蛇行检测器
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2023/08/31  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void UpdateLatHuntingDetector(
    LatCtlPidInstance_t* const instance,
    const LatCtlDataSource_t* data_source,
    Float32_t tar_yaw_rate,
    LateralControlPidInfo_t* const status_info) {
  Int32_t idx = 0;

  // 角速度采样周期 50ms， 采样频率 20Hz
  /*
    # CalcFFTPeriod(sample_period=0.050000s, sample_number=128)
    idx=0, frequency=0.000000, peirod=0.000000
    idx=1, frequency=0.156250, peirod=6.400000
    idx=2, frequency=0.312500, peirod=3.200000
    idx=3, frequency=0.468750, peirod=2.133333
    idx=4, frequency=0.625000, peirod=1.600000
    idx=5, frequency=0.781250, peirod=1.280000
    idx=6, frequency=0.937500, peirod=1.066667
    idx=7, frequency=1.093750, peirod=0.914286
    idx=8, frequency=1.250000, peirod=0.800000
    idx=9, frequency=1.406250, peirod=0.711111

    # CalcFFTPeriod(sample_period=0.050000s, sample_number=256)
    idx=0, frequency=0.000000, peirod=0.000000
    idx=1, frequency=0.078125, peirod=12.800000
    idx=2, frequency=0.156250, peirod=6.400000
    idx=3, frequency=0.234375, peirod=4.266667
    idx=4, frequency=0.312500, peirod=3.200000
    idx=5, frequency=0.390625, peirod=2.560000
    idx=6, frequency=0.468750, peirod=2.133333
    idx=7, frequency=0.546875, peirod=1.828571
    idx=8, frequency=0.625000, peirod=1.600000
    idx=9, frequency=0.703125, peirod=1.422222
  */
  // 对目标角速度做FFT变换
  FftForLatCtl(
      &(instance->hunting_detector.yaw_rate.fft_tar_yaw_rate), 
      tar_yaw_rate);
  // 对当前角速度做FFT变换
  FftForLatCtl(
      &(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate), 
      data_source->cur_pos.yaw_rate);

  instance->hunting_detector.yaw_rate.fd_low_mag_tar_yaw_rate = 
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[1] + 
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[2] +
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[3];
  instance->hunting_detector.yaw_rate.fd_high_mag_tar_yaw_rate = 
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[4] +
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[5] + 
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[6] +
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[7] +
      instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[8];
  instance->hunting_detector.yaw_rate.fd_low_mag_cur_yaw_rate = 
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[1] + 
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[2] +
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[3];
  instance->hunting_detector.yaw_rate.fd_high_mag_cur_yaw_rate = 
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[4] +
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[5] + 
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[6] +
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[7] +
      instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[8];

#if 0
  // 判断是否出现蛇形
  instance->hunting_detector.yaw_rate.hunting_energy = 
      0.15F*(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[2]-
             instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[2]) +
      0.40F*(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[3]-
             instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[3]) +
      0.30F*(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[4]-
             instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[4]) +
      0.15F*(instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[5]-
             instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[5]);

  if (instance->hunting_detector.yaw_rate.hunting_energy > phoenix_com_deg2rad_f(0.10F)) {
    instance->hunting_detector.yaw_rate.is_hunting = 1;
  } else {
    instance->hunting_detector.yaw_rate.is_hunting = 0;
  }

  // 出现蛇形时，减小控制增益
  instance->hunting_detector.yaw_rate.hunting_gain = 1.0F;
  if (instance->hunting_detector.yaw_rate.hunting_energy >= 0.0F) {
    static const Float32_t kMaxHuntingEnergy = 0.5F*0.017453293F;
    // 实际角速度能量大于目标角速度能量，控制系统趋于不稳定，降低控制增益
    instance->hunting_detector.yaw_rate.hunting_gain = 
        (kMaxHuntingEnergy - instance->hunting_detector.yaw_rate.hunting_energy) /
        kMaxHuntingEnergy;
    if (instance->hunting_detector.yaw_rate.hunting_gain > 1.0F) {
      instance->hunting_detector.yaw_rate.hunting_gain = 1.0F;
    } else if (instance->hunting_detector.yaw_rate.hunting_gain < 0.0F) {
      instance->hunting_detector.yaw_rate.hunting_gain = 0.0F;
    } else {
      // nothing to do
    }
  }
#endif
  
#if 0
  printf("#### is_hunting=%d, hunting_energy=%0.3f, hunting_gain=%0.3f, phase_diff=%0.2f\n", 
      instance->hunting_detector.yaw_rate.is_hunting,
      phoenix_com_rad2deg_f(instance->hunting_detector.yaw_rate.hunting_energy),
      instance->hunting_detector.yaw_rate.hunting_gain,
      phoenix_com_rad2deg_f(Phoenix_Common_AngleDiff_f(
          instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.pha[3], 
          instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.pha[3])));
#endif

  // 此处可取消对横向蛇形共振的抑制
  // instance->hunting_detector.yaw_rate.hunting_gain = 1.0F;

  // 保存调试信息
  status_info->frequency_spectrum.yaw_rate.is_hunting = 
      instance->hunting_detector.yaw_rate.is_hunting;
  status_info->frequency_spectrum.yaw_rate.hunting_energy = 
      instance->hunting_detector.yaw_rate.hunting_energy;
  status_info->frequency_spectrum.yaw_rate.fd_low_mag_tar_yaw_rate = 
      instance->hunting_detector.yaw_rate.fd_low_mag_tar_yaw_rate;
  status_info->frequency_spectrum.yaw_rate.fd_high_mag_tar_yaw_rate = 
      instance->hunting_detector.yaw_rate.fd_high_mag_tar_yaw_rate;
  status_info->frequency_spectrum.yaw_rate.fd_low_mag_cur_yaw_rate =
      instance->hunting_detector.yaw_rate.fd_low_mag_cur_yaw_rate;
  status_info->frequency_spectrum.yaw_rate.fd_high_mag_cur_yaw_rate =
      instance->hunting_detector.yaw_rate.fd_high_mag_cur_yaw_rate;
  for (idx = 0; idx < LAT_CTL_FFT_SIZE/2; ++idx) {
    if (idx >= LAT_CTL_FREQUENCY_SPECTRUM_SIZE) {
      break;
    }

    if ((2 <= idx) && (idx <= 5) && instance->hunting_detector.yaw_rate.is_hunting) {
      status_info->frequency_spectrum.yaw_rate.hunting_fre_idxs[idx] = 1;
    } else {
      status_info->frequency_spectrum.yaw_rate.hunting_fre_idxs[idx] = 0;
    }

    status_info->frequency_spectrum.yaw_rate.tar_yaw_rate_mag[idx] =
        instance->hunting_detector.yaw_rate.fft_tar_yaw_rate.mag[idx];
    status_info->frequency_spectrum.yaw_rate.cur_yaw_rate_mag[idx] =
        instance->hunting_detector.yaw_rate.fft_cur_yaw_rate.mag[idx];
  }
}

/*
 * @brief 性能分析
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/02/31  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void AnalyseLatCtlPerformance(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    Float32_t tar_yaw_rate,
    Float32_t understeer_feed,
    LateralControlPidInfo_t* const status_info) {
  // 构建分析用的数据
  LatCtlAnalyseDataSource_t ana_data;

  // 时间戳
  ana_data.timestamp = data_source->timestamp;
  // 底盘信息
  // 转向机是否处于自动状态
  ana_data.chassis.eps_auto = data_source->chassis.eps_auto;
  // 方向盘角度 (rad)
  ana_data.chassis.steering_wheel_angle = data_source->chassis.steering_wheel_angle;
  // 角速度 (rad/s) [底盘反馈的]
  ana_data.chassis.yaw_rate_cha = data_source->cur_pos.yaw_rate;
  ana_data.chassis.yaw_rate_chg_rate = data_source->cur_pos.yaw_rate_chg_rate;
  // 车速(m/s)
  ana_data.chassis.veh_speed = data_source->cur_pos.v;
  // 总质量 (kg)
  ana_data.chassis.gross_weight = data_source->chassis.gross_weight;
  // 横向误差
  // 目标轨迹是否处于避障或变道状态
  ana_data.lat_err.moving_flag = data_source->lat_err.moving_flag;
  // 横向误差
  ana_data.lat_err.samples[0].lat_err = data_source->lat_err.samples[0].lat_err;
  // 横向误差变化速率
  ana_data.lat_err.samples[0].lat_err_chg_rate = data_source->lat_err.samples[0].lat_err_chg_rate;
  // 角度误差, Range: (-pi, pi rad)
  ana_data.lat_err.samples[0].yaw_err = data_source->lat_err.samples[0].yaw_err;
  // 角度误差变化速率(rad/s^2)
  ana_data.lat_err.samples[0].yaw_err_chg_rate = data_source->lat_err.samples[0].yaw_err_chg_rate;
  // 横向误差
  ana_data.lat_err.samples[1].lat_err = data_source->lat_err.samples[1].lat_err;
  // 横向误差变化速率
  ana_data.lat_err.samples[1].lat_err_chg_rate = data_source->lat_err.samples[1].lat_err_chg_rate;
  // 角度误差, Range: (-pi, pi rad)
  ana_data.lat_err.samples[1].yaw_err = data_source->lat_err.samples[1].yaw_err;
  // 角度误差变化速率(rad/s^2)
  ana_data.lat_err.samples[1].yaw_err_chg_rate = data_source->lat_err.samples[1].yaw_err_chg_rate;
  // 轨迹信息
  // 轨迹规划生成的轨迹类型
  ana_data.trj_info.planning_trj_status = data_source->planning_trj_status;
  // 车道中心线的曲率
  ana_data.trj_info.ref_trj_curvature = data_source->ref_trj_curvature;
  // 曲率类型
  ana_data.trj_info.ref_trj.curvature_type = ins->ref_trj_info.curvature_type;
  // 当前曲率
  ana_data.trj_info.ref_trj.curr_curvature = ins->ref_trj_info.curr_curvature;
  // 当前曲率变化率
  ana_data.trj_info.ref_trj.curr_d1_curvature = ins->ref_trj_info.curr_d1_curvature;
  // 之前的曲率
  ana_data.trj_info.ref_trj.prev_curvature = ins->ref_trj_info.prev_curvature;
  // 之前曲率到当前曲率的时间差
  ana_data.trj_info.ref_trj.prev_curvature_time_elapsed = ins->ref_trj_info.prev_curvature_time_elapsed;
  // 横向控制信息
  // 横向控制的目标角速度 (rad/s)
  ana_data.ctl_info.yaw_rate_tar = tar_yaw_rate;
  // 转向不足补偿值 (rad)
  ana_data.ctl_info.understeer_feed = understeer_feed;

  // 横向控制分析
  Phoenix_LatCtlAnalyse_Update(&(ins->perf_ana.analyser), &ana_data);
  // 获取横向控制分析的结果
  Phoenix_LatCtlAnalyse_GetAnaRet(&(ins->perf_ana.analyser), &(ins->perf_ana.ana_ret));

  ins->hunting_detector.yaw_rate.hunting_gain = 
      Phoenix_LatCtlAnalyse_GetStrLowFeqResFeedRatioByYawRate(&(ins->perf_ana.analyser), tar_yaw_rate, data_source->cur_pos.v);
  // ins->hunting_detector.yaw_rate.hunting_gain = 1.0F;

  // 保存到状态信息中
  phoenix_com_memcpy(&(status_info->perf_ana.ana_ret), &(ins->perf_ana.ana_ret), sizeof(status_info->perf_ana.ana_ret));
  status_info->perf_ana.ctl_gain = ins->hunting_detector.yaw_rate.hunting_gain;
}

/*
 * @brief 分析轨迹曲率信息
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2024/04/08  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void AnalyseRefTrjInfo(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    LateralControlPidInfo_t* const status_info) {
  // 时间戳
  Int64_t time_elapsed_ms = Phoenix_Common_CalcElapsedClockMs(
        ins->timestamp, data_source->timestamp);
  Float32_t time_elapsed = 0.001F * time_elapsed_ms;

  // 轨迹曲率
#if 0
  ins->ref_trj_info.curr_curvature = data_source->ref_trj_curvature;
#else
  static const Int32_t kCurvatureFilterWndSize = 4;
  Int32_t curv_data_num = Phoenix_Com_RingBuffer_GetSize(&(ins->ref_trj_info.curvature_queue.ring_buf));
  Float32_t* old_curvature = 
      Phoenix_Com_RingBuffer_GetDataByIdx(
          &(ins->ref_trj_info.curvature_queue.ring_buf), curv_data_num-kCurvatureFilterWndSize);
  if (Null_t == old_curvature) {
   ins->ref_trj_info.curr_curvature =  Phoenix_Com_Filter_MovingAverage_f(
        kCurvatureFilterWndSize, curv_data_num, 
        ins->ref_trj_info.curr_curvature, data_source->ref_trj_curvature, 0.0F);
  } else {
    ins->ref_trj_info.curr_curvature = Phoenix_Com_Filter_MovingAverage_f(
        kCurvatureFilterWndSize, kCurvatureFilterWndSize, 
        ins->ref_trj_info.curr_curvature, data_source->ref_trj_curvature, *old_curvature);
  }
#endif
  ins->ref_trj_info.curr_d1_curvature = 
      UpdateTrjCurvatureInfo(&(ins->ref_trj_info.trj_curv_info), 
          data_source->ref_trj_curvature, data_source->timestamp);
  
  // 保存曲率到队列中
  Phoenix_Com_RingBuffer_PushBackOverride(
        &(ins->ref_trj_info.curvature_queue.ring_buf), &(ins->ref_trj_info.curr_curvature));

  // 查找之前与当前曲率偏差最大的曲率值
  Int32_t idx = 0;
  Int32_t max_offset_curvatrue_idx = 
      Phoenix_Com_RingBuffer_GetSize(&(ins->ref_trj_info.curvature_queue.ring_buf))-1;
  Float32_t max_offset_curvatrue = ins->ref_trj_info.curr_curvature;
  RingBufferIterator_t ring_buff_it_begin;
  RingBufferIterator_t ring_buff_it_end;
  Phoenix_Com_RingBuffer_SetItToBegin(
        &(ins->ref_trj_info.curvature_queue.ring_buf), &ring_buff_it_begin);
  Phoenix_Com_RingBuffer_SetItToEnd(
        &(ins->ref_trj_info.curvature_queue.ring_buf), &ring_buff_it_end);
  while (Phoenix_Com_RingBufferIterator_IsNotEqual(
           &ring_buff_it_begin, &ring_buff_it_end)) {
    Float32_t curvature =
        *(Float32_t*)Phoenix_Com_RingBufferIterator_GetCurrent(
          &ring_buff_it_begin);
    if (phoenix_com_abs_f(ins->ref_trj_info.curr_curvature - curvature) > 
        phoenix_com_abs_f(ins->ref_trj_info.curr_curvature - max_offset_curvatrue)) {
      max_offset_curvatrue = curvature;
      max_offset_curvatrue_idx = idx;
    }
    
    ++idx;
    Phoenix_Com_RingBufferIterator_Increase(&ring_buff_it_begin);
  }
  ins->ref_trj_info.prev_curvature = max_offset_curvatrue;
  ins->ref_trj_info.prev_curvature_time_elapsed = 
      (Phoenix_Com_RingBuffer_GetSize(&(ins->ref_trj_info.curvature_queue.ring_buf)) -
       max_offset_curvatrue_idx - 1) * ins->param.ctl_period;

  // 判顿曲率类型
  static const Float128_t kCurvatureThreshold = 0.0001F;
  Float32_t abs_curr_curvature = phoenix_com_abs_f(ins->ref_trj_info.curr_curvature);
  Float32_t abs_prev_curvature = phoenix_com_abs_f(ins->ref_trj_info.prev_curvature);
  Float32_t abs_curvature_diff = abs_curr_curvature - abs_prev_curvature;
  Float32_t curvature_offset = ins->ref_trj_info.curr_curvature - ins->ref_trj_info.prev_curvature;
  Float32_t curve_threshold = 0.1F * (abs_curr_curvature > abs_prev_curvature ? abs_curr_curvature : abs_prev_curvature);
  curve_threshold = curve_threshold > kCurvatureThreshold ? curve_threshold : kCurvatureThreshold;
  if (curvature_offset > curve_threshold) {
    // 出右弯 or 入左弯
    if (abs_curvature_diff > curve_threshold) {
      // 入左弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_INTO_LEFT;
    } else if (abs_curvature_diff < -curve_threshold) {
      // 出右弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_OUT_RIGHT;
    } else {
      // 入左弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_INTO_LEFT;
    }
  } else if (curvature_offset < -curve_threshold) {
    // 出左弯 or 入右弯
    if (abs_curvature_diff > curve_threshold) {
      // 入右弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_INTO_RIGHT;
    } else if (abs_curvature_diff < -curve_threshold) {
      // 出左弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_OUT_LEFT;
    } else {
      // 入右弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_INTO_RIGHT;
    }
  } else {
    // 轨迹曲率不变 (直线 or 弯道)
    if (ins->ref_trj_info.curr_curvature > kCurvatureThreshold) {
      // 左弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_LEFT;
    } else if (ins->ref_trj_info.curr_curvature < -kCurvatureThreshold) {
      // 右弯
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_RIGHT;
    } else {
      // 直线
      ins->ref_trj_info.curvature_type = LAT_CTL_CURVATURE_TYPE_STRAIGHT;
    }
  }

#if (ENABLE_LAT_CTL_PID_TRACE)
  // 打印调试信息
  const char* curvature_type_description[LAT_CTL_CURVATURE_TYPE_MAX] = {
    "直线", "左弯", "右弯", "入左弯", "入右弯", "出左弯", "出右弯"
  };
  printf("@@@曲率信息 curr_c=%0.6f(chg=%0.6f), prev_c=%0.6f, c_diff=%0.6f, elapsed=%0.2f, type=%s\n",
      ins->ref_trj_info.curr_curvature, ins->ref_trj_info.curr_d1_curvature,
      ins->ref_trj_info.prev_curvature, curvature_offset, ins->ref_trj_info.prev_curvature_time_elapsed,
      curvature_type_description[ins->ref_trj_info.curvature_type]);
#endif

  // 保存调试信息
  status_info->ref_trj_info.curvature_type = ins->ref_trj_info.curvature_type;
  status_info->ref_trj_info.curr_curvature = ins->ref_trj_info.curr_curvature;
  status_info->ref_trj_info.curr_d1_curvature = ins->ref_trj_info.curr_d1_curvature;
  status_info->ref_trj_info.prev_curvature = ins->ref_trj_info.prev_curvature;
  status_info->ref_trj_info.prev_curvature_time_elapsed = ins->ref_trj_info.prev_curvature_time_elapsed;
}


/*
 * @brief 计算横向控制量
 * @param[in] ins 成员变量
 * @param[in] data_source 控制器所需要的数据
 * @param[in] cur_pos 当前车辆在目标轨迹中的位置
 * @param[in] feedforward_from_trj 轨迹前馈值
 * @param[out] ctl_yaw_rate 目标角速度
 * @param[out] status_info 内部状态信息
 * @return 横向控制量(目标方向盘角度)
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
static Float32_t CalcControlValue(
    LatCtlPidInstance_t* const ins,
    const LatCtlDataSource_t* data_source,
    const LatCtlPos_t* cur_pos,
    const LatCtlPathPoint_t* cur_proj_on_trj,
    Float32_t* ctl_yaw_rate,
    LateralControlPidInfo_t* const status_info) {
  // 用于平滑补偿量
  Int32_t index = 0;
  Float32_t sum = 0.0F;
  // 计算目标角速度, curvature = yaw_rate / v
  const Float32_t cur_v = cur_pos->v;
  Float32_t tar_curvature = 0.0F;
  Float32_t tar_yaw_rate = 0.0F;
  // 方向盘角度增益
  Float32_t key_ratio_steering_gain = 0.0F;
  Int32_t key_idx_steering_gain = 0;
  Float32_t steering_gain = 1.0F;
  // 轨迹前馈量平滑
  Int32_t smooth_num_trj_feedforward = 8;
  // 轨迹前馈的补偿值
  Float32_t feed_value_from_trj = 0.0F;
  Float32_t feed_value_from_trj_smooth = 0.0F;
  // 反馈补偿值
  Float32_t feed_back_value = 0.0F;
  // 车辆动态特性补偿值
  Float32_t feed_value_from_veh_dynamic = 0.0F;
  // 最终的控制量
  Float32_t ctl_value = 0.0F;

  // 轨迹前馈
  // Feedforward from trajectory
  // (return target curvature, curvature = yaw_rate / v)
  tar_curvature = CalcFeedforwardValueFromTrajectory(
        ins, cur_pos, cur_proj_on_trj,
        data_source->ref_trj_curvature, &data_source->tar_trj,
        status_info);
  // 计算轨迹前馈的补偿值
  feed_value_from_trj =
      Phoenix_VehModel_CalcSteeringAngleFromCurvature(tar_curvature);
  tar_yaw_rate = tar_curvature * cur_v;
  // 保存目标角速度
  *ctl_yaw_rate = tar_yaw_rate;

  // 平滑轨迹前馈的值
#if 1
  // Enable smoothing trajectory feedforward value
  for (index = (MAX_TRJ_FEEDFORWARD_VALUE_LIST_SIZE-1); index > 0; --index) {
    ins->trj_feed.filter.feed_value[index] =
        ins->trj_feed.filter.feed_value[index-1];
  }
  ins->trj_feed.filter.feed_value[0] = feed_value_from_trj;

  if (cur_pos->v < 10.0F/3.6F) {
    smooth_num_trj_feedforward = 8;
  } else if (cur_pos->v < 15.0F/3.6F) {
    smooth_num_trj_feedforward = 7;
  } else if (cur_pos->v < 20.0F/3.6F) {
    smooth_num_trj_feedforward = 6;
  } else if (cur_pos->v < 25.0F/3.6F) {
    smooth_num_trj_feedforward = 6;
  } else if (cur_pos->v < 30.0F/3.6F) {
    smooth_num_trj_feedforward = 6;
  } else if (cur_pos->v < 40.0F/3.6F) {
    smooth_num_trj_feedforward = 6;
  } else if (cur_pos->v < 50.0F/3.6F) {
    smooth_num_trj_feedforward = 3;
  } else {
    smooth_num_trj_feedforward = 2;
  }
  // printf("smooth_num_trj_feedforward=%d\n", smooth_num_trj_feedforward);
  sum = 0.0F;
  for (index = 0; index < smooth_num_trj_feedforward; ++index) {
    sum += ins->trj_feed.filter.feed_value[index];
  }
  feed_value_from_trj_smooth = sum / (smooth_num_trj_feedforward);
#else
  // Disable smoothing trajectory feedforward value
  feed_value_from_trj_smooth = feed_value_from_trj;
#endif
  ctl_value = feed_value_from_trj_smooth;


  // 计算反馈补偿值
  feed_back_value = CalcFeedBackValue(
        ins, data_source, cur_pos, tar_yaw_rate, status_info);
  ctl_value += feed_back_value;

  // 计算车辆动态特性补偿值
  feed_value_from_veh_dynamic = CalcFeedValueFromVehDynamic(
        ins, data_source, cur_pos, tar_curvature, status_info);
  ctl_value += feed_value_from_veh_dynamic;

  // 计算方向盘角度增益
  key_idx_steering_gain = Phoenix_Common_LerpInOrderedTable_f(
        ins->param.key_tab_steering_feed_by_angle,
        LAT_CTL_PID_LERP_TABLE_SIZE,
        phoenix_com_abs_f(ctl_value),
        &key_ratio_steering_gain);
  steering_gain = Phoenix_Common_Lerp_f(
        ins->param.gain_tab_steering_feed_by_angle[key_idx_steering_gain],
        ins->param.gain_tab_steering_feed_by_angle[key_idx_steering_gain+1],
        key_ratio_steering_gain);

#if (ENABLE_LAT_CTL_PID_TRACE)
  // printf("@@@ Steering Gain: tar_angle=%0.1f, key_index=%d, key_ratio=%0.3f, "
  //        "gain=%0.3f, after angle=%0.1f\n",
  //        phoenix_com_rad2deg_f(ctl_value),
  //        steering_gain_key_index, steering_gain_key_ratio,
  //        steering_gain, phoenix_com_rad2deg_f(ctl_value*steering_gain));
  printf("@@@ tar_angle=%0.1f, 轨迹前馈=%0.1f, 反馈补偿=%0.1f, 动力学补偿=%0.1f"
         ", str_gain=%0.3f, after angle=%0.1f\n",
         phoenix_com_rad2deg_f(ctl_value),
         phoenix_com_rad2deg_f(feed_value_from_trj_smooth),
         phoenix_com_rad2deg_f(feed_back_value),
         phoenix_com_rad2deg_f(feed_value_from_veh_dynamic),
         steering_gain, phoenix_com_rad2deg_f(ctl_value*steering_gain));
#endif

  ctl_value *= steering_gain;

  // 根据车速，限制方向盘最大转角
  ctl_value =
      Phoenix_VehModel_ClampMaxSteeringAngleByVelocity(ctl_value, cur_pos->v);

  // 保存调试信息
  status_info->trj_feed.feed_value_smooth = feed_value_from_trj_smooth;
  status_info->steering_gain = steering_gain;

  return (ctl_value);
}


/******************************************************************************/
/* 外部函数                                                                    */
/******************************************************************************/

/*
 * @brief 初始化横向控制器(PID)
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void Phoenix_LatCtlPid_Initialize(
    LatCtlPidInstance_t* const instance) {
  // 控制器运行周期(s)
  instance->param.ctl_period = 0.05F;

  /// 轨迹前馈 (begin)
  // 最小预瞄距离(current, near, far)
  instance->param.min_leading_len = 4.0F;
  instance->param.min_near_leading_len = 3.0F;
  instance->param.min_far_leading_len = 5.0F;
  // 通过速度修正预瞄距离(Key table & t-gap table[current, near, far])
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lead_by_spd,
        s_key_tab_crt_lead_by_spd,
        sizeof(instance->param.key_tab_crt_lead_by_spd));
  // T-Gap
  phoenix_com_memcpy(
        instance->param.tgap_tab_crt_lead_by_spd,
        s_tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.tgap_tab_crt_lead_by_spd));
  // Near T-Gap
  phoenix_com_memcpy(
        instance->param.near_tgap_tab_crt_lead_by_spd,
        s_near_tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.near_tgap_tab_crt_lead_by_spd));
  // Far T-Gap
  phoenix_com_memcpy(
        instance->param.far_tgap_tab_crt_lead_by_spd,
        s_far_tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.far_tgap_tab_crt_lead_by_spd));
  // 通过曲率修正预瞄距离(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lead_by_curvature,
        s_key_tab_crt_lead_by_curvature,
        sizeof(instance->param.key_tab_crt_lead_by_curvature));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_crt_lead_by_curvature,
        s_gain_tab_crt_lead_by_curvature,
        sizeof(instance->param.gain_tab_crt_lead_by_curvature));
  /// 轨迹前馈 (end)

  /// 横向误差补偿 (begin)
  // 最大横向误差补偿值 P值
  instance->param.max_lat_err_feed_value_p = phoenix_com_deg2rad_f(10.0F);
  // 最大横向误差补偿值 I值
  instance->param.max_lat_err_feed_value_i = phoenix_com_deg2rad_f(25.0F);
  // 最大横向误差补偿值 D值
  instance->param.max_lat_err_feed_value_d = phoenix_com_deg2rad_f(14.0F);
  // 最大横向误差补偿值
  instance->param.max_lat_err_feed_value = phoenix_com_deg2rad_f(25.0F);
  // 最大航向角误差补偿值 P值
  instance->param.max_yaw_err_feed_value_p = phoenix_com_deg2rad_f(10.0F);
  // 最大航向角误差补偿值 I值
  instance->param.max_yaw_err_feed_value_i = phoenix_com_deg2rad_f(20.0F);
  // 最大航向角误差补偿值 D值
  instance->param.max_yaw_err_feed_value_d = phoenix_com_deg2rad_f(10.0F);
  // 最大航向角误差补偿值
  instance->param.max_yaw_err_feed_value = phoenix_com_deg2rad_f(10.0F);
  // 全局增益 
  instance->param.p_global_gain_lat_err_feed = 1.0F;
  instance->param.i_global_gain_lat_err_feed = 1.0F;
  instance->param.d_global_gain_lat_err_feed = 1.0F;
  // 通过速度修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lat_err_feed_by_spd,
        s_key_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.key_tab_crt_lat_err_feed_by_spd));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_lat_err_feed_by_spd,
        s_p_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.p_tab_crt_lat_err_feed_by_spd));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_lat_err_feed_by_spd,
        s_i_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.i_tab_crt_lat_err_feed_by_spd));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_lat_err_feed_by_spd,
        s_d_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.d_tab_crt_lat_err_feed_by_spd));
  // 通过重量修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lat_err_feed_by_weight,
        s_key_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.key_tab_crt_lat_err_feed_by_weight));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_lat_err_feed_by_weight,
        s_p_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.p_tab_crt_lat_err_feed_by_weight));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_lat_err_feed_by_weight,
        s_i_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.i_tab_crt_lat_err_feed_by_weight));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_lat_err_feed_by_weight,
        s_d_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.d_tab_crt_lat_err_feed_by_weight));
  /* k001 pengc 2023-11-07 (begin) */
  /// 不同横向距离上，横向误差变化率的目标值
  // Key
  phoenix_com_memcpy(
        instance->param.key_tab_tar_lat_spd,
        s_key_tab_tar_lat_spd,
        sizeof(instance->param.key_tab_tar_lat_spd));
  // expection
  phoenix_com_memcpy(
        instance->param.exp_tab_tar_lat_spd,
        s_exp_tab_tar_lat_spd,
        sizeof(instance->param.exp_tab_tar_lat_spd));
  // standard deviation
  phoenix_com_memcpy(
        instance->param.dev_tab_tar_lat_spd,
        s_dev_tab_tar_lat_spd,
        sizeof(instance->param.dev_tab_tar_lat_spd));
  /* k001 pengc 2023-11-07 (end) */
  /* k001 pengc 2023-12-01 (begin) */
  /// 通过速度修正角度误差的目标值
  // Key
  phoenix_com_memcpy(
        instance->param.key_tab_crt_yaw_err_exp_by_spd,
        s_key_tab_crt_yaw_err_exp_by_spd,
        sizeof(instance->param.key_tab_crt_yaw_err_exp_by_spd));
  // Ratio
  phoenix_com_memcpy(
        instance->param.ratio_tab_crt_yaw_err_exp_by_spd,
        s_ratio_tab_crt_yaw_err_exp_by_spd,
        sizeof(instance->param.ratio_tab_crt_yaw_err_exp_by_spd));
  /// 不同横向距离上，角度误差的目标值
  // Key
  phoenix_com_memcpy(
        instance->param.key_tab_tar_yaw_err,
        s_key_tab_tar_yaw_err,
        sizeof(instance->param.key_tab_tar_yaw_err));
  // expection
  phoenix_com_memcpy(
        instance->param.exp_tab_tar_yaw_err,
        s_exp_tab_tar_yaw_err,
        sizeof(instance->param.exp_tab_tar_yaw_err));
  // standard deviation
  phoenix_com_memcpy(
        instance->param.dev_tab_tar_yaw_err,
        s_dev_tab_tar_yaw_err,
        sizeof(instance->param.dev_tab_tar_yaw_err));
  /* k001 pengc 2023-12-01 (end) */
  // 横向误差补偿Fuzzy Table
  // 误差等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_lat_err_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_lat_err_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_err_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1,
        s_tab_lat_err_level);
  // 误差变化率等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_lat_err_spd_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_lat_err_spd_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_err_spd_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1,
        s_tab_lat_err_spd_level);
  // 横向误差补偿系数表
  // P
  Phoenix_Com_Matrix_Init(
        &(instance->param.p_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        instance->param.p_gain_tab_buf_lat_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        s_p_gain_tab_lat_err_feed);
  // I
  Phoenix_Com_Matrix_Init(
        &(instance->param.i_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        instance->param.i_gain_tab_buf_lat_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        s_i_gain_tab_lat_err_feed);
  // D
  Phoenix_Com_Matrix_Init(
        &(instance->param.d_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        instance->param.d_gain_tab_buf_lat_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        s_d_gain_tab_lat_err_feed);
  /* k001 pengc 2023-11-07 (begin) */
  // 横向误差变化率补偿Fuzzy Table
  // 误差速率等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_lat_spd_err_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_lat_spd_err_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_spd_err_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1,
        s_tab_lat_spd_err_level);
  // 误差速率变化率等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_lat_acc_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_lat_acc_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_acc_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1,
        s_tab_lat_acc_level);
  // 横向误差速率补偿系数表
  // P
  Phoenix_Com_Matrix_Init(
        &(instance->param.p_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        instance->param.p_gain_tab_buf_lat_spd_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        s_p_gain_tab_lat_spd_feed);
  // I
  Phoenix_Com_Matrix_Init(
        &(instance->param.i_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        instance->param.i_gain_tab_buf_lat_spd_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        s_i_gain_tab_lat_spd_feed);
  // D
  Phoenix_Com_Matrix_Init(
        &(instance->param.d_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE, LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        instance->param.d_gain_tab_buf_lat_spd_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        s_d_gain_tab_lat_spd_feed);
  /* k001 pengc 2023-11-07 (end) */
  // 航向角误差补偿Fuzzy Table
  // 误差等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_yaw_err_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_yaw_err_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_err_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1,
        s_tab_yaw_err_level);
  // 误差变化率等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_yaw_err_spd_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_yaw_err_spd_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_err_spd_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1,
        s_tab_yaw_err_spd_level);
  // 航向角误差补偿系数表
  // P
  Phoenix_Com_Matrix_Init(
        &(instance->param.p_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        instance->param.p_gain_tab_buf_yaw_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        s_p_gain_tab_yaw_err_feed);
  // I
  Phoenix_Com_Matrix_Init(
        &(instance->param.i_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        instance->param.i_gain_tab_buf_yaw_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        s_i_gain_tab_yaw_err_feed);
  // D
  Phoenix_Com_Matrix_Init(
        &(instance->param.d_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        instance->param.d_gain_tab_buf_yaw_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        s_d_gain_tab_yaw_err_feed);
  /// 不同横向距离上，横向误差变化率的限制值
  phoenix_com_memcpy(
        instance->param.key_tab_lmt_lat_err_spd,
        s_key_tab_lmt_lat_err_spd,
        sizeof(instance->param.key_tab_lmt_lat_err_spd));
  // 增益
  phoenix_com_memcpy(
        instance->param.gain_tab_lmt_lat_err_spd,
        s_gain_tab_lmt_lat_err_spd,
        sizeof(instance->param.gain_tab_lmt_lat_err_spd));
  // 接近的速度
  phoenix_com_memcpy(
        instance->param.base_val_tab_lmt_lat_err_spd_close,
        s_base_val_tab_lmt_lat_err_spd_close,
        sizeof(instance->param.base_val_tab_lmt_lat_err_spd_close));
  // 远离的速度
  phoenix_com_memcpy(
        instance->param.base_val_tab_lmt_lat_err_spd_far_away,
        s_base_val_tab_lmt_lat_err_spd_far_away,
        sizeof(instance->param.base_val_tab_lmt_lat_err_spd_far_away));
  /// 横向误差补偿 (end)

  /// 角速度误差补偿 (begin)
  // 最大角速度误差补偿值 P值
  instance->param.max_yaw_rate_err_feed_value_p = phoenix_com_deg2rad_f(10.0F);
  // 最大角速度误差补偿值 I值
  instance->param.max_yaw_rate_err_feed_value_i = phoenix_com_deg2rad_f(10.0F);
  // 最大角速度误差补偿值 D值
  instance->param.max_yaw_rate_err_feed_value_d = phoenix_com_deg2rad_f(10.0F);
  // 最大角速度误差补偿值
  instance->param.max_yaw_rate_err_feed_value = phoenix_com_deg2rad_f(10.0F);
  // 全局增益
  // { 34#(2023-11-10): 1.4, 1.0, 1.4 }， { 34#(2023-11-30): 1.0, 1.0, 1.0 }
  // { 50#(2023-12-01): 1.4, 1.0, 1.4 }
  // { 63#(2023-11-17): 1.8, 1.0, 1.8 }
  // { 65#(2023-11-16): 1.0, 1.0, 1.0 }
  instance->param.p_global_gain_yaw_rate_err_feed = 1.0F;
  instance->param.i_global_gain_yaw_rate_err_feed = 1.0F;
  instance->param.d_global_gain_yaw_rate_err_feed = 1.0F;
  // 通过速度修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_yaw_rate_err_feed_by_spd,
        s_key_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.key_tab_crt_yaw_rate_err_feed_by_spd));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_yaw_rate_err_feed_by_spd,
        s_p_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.p_tab_crt_yaw_rate_err_feed_by_spd));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_yaw_rate_err_feed_by_spd,
        s_i_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.i_tab_crt_yaw_rate_err_feed_by_spd));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_yaw_rate_err_feed_by_spd,
        s_d_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.d_tab_crt_yaw_rate_err_feed_by_spd));
  // 通过重量修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_yaw_rate_err_feed_by_weight,
        s_key_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.key_tab_crt_yaw_rate_err_feed_by_weight));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_yaw_rate_err_feed_by_weight,
        s_p_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.p_tab_crt_yaw_rate_err_feed_by_weight));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_yaw_rate_err_feed_by_weight,
        s_i_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.i_tab_crt_yaw_rate_err_feed_by_weight));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_yaw_rate_err_feed_by_weight,
        s_d_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.d_tab_crt_yaw_rate_err_feed_by_weight));
  /* k001 pengc 2023-12-01 (begin) */
  /// 不同横向距离上，角速度误差的目标值
  phoenix_com_memcpy(
        instance->param.key_tab_tar_yaw_rate_err,
        s_key_tab_tar_yaw_rate_err,
        sizeof(instance->param.key_tab_tar_yaw_rate_err));
  // 横向误差变化率的目标值的 standard deviation
  phoenix_com_memcpy(
        instance->param.dev_tab_tar_yaw_rate_err,
        s_dev_tab_tar_yaw_rate_err,
        sizeof(instance->param.dev_tab_tar_yaw_rate_err));
  /* k001 pengc 2023-12-01 (end) */
  // 角速度误差补偿Fuzzy Table
  // 角速度误差等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_yaw_rate_err_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_yaw_rate_err_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_rate_err_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1,
        s_tab_yaw_rate_err_level);
  // 角速度变化率等级表
  Phoenix_Com_Matrix_Init(
        &(instance->param.tab_yaw_rate_spd_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1, 1,
        instance->param.tab_buf_yaw_rate_spd_level);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_rate_spd_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1,
        s_tab_yaw_rate_spd_level);
  // 角速度误差补偿系数表
  // P
  Phoenix_Com_Matrix_Init(
        &(instance->param.p_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        instance->param.p_gain_tab_buf_yaw_rate_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        s_p_gain_tab_yaw_rate_err_feed);
  // I
  Phoenix_Com_Matrix_Init(
        &(instance->param.i_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        instance->param.i_gain_tab_buf_yaw_rate_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        s_i_gain_tab_yaw_rate_err_feed);
  // D
  Phoenix_Com_Matrix_Init(
        &(instance->param.d_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE, LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        instance->param.d_gain_tab_buf_yaw_rate_err_feed);
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        s_d_gain_tab_yaw_rate_err_feed);
  /// 角速度误差补偿 (end)

  /// 车辆动态特性补偿 (begin)
  // 最大动力学补值
  instance->param.max_dynamic_feed_value = phoenix_com_deg2rad_f(10.0F);
  // 通过速度修正动态特性补偿(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_dynamic_feed_by_spd,
        s_key_tab_dynamic_feed_by_spd,
        sizeof(instance->param.key_tab_dynamic_feed_by_spd));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_dynamic_feed_by_spd,
        s_gain_tab_dynamic_feed_by_spd,
        sizeof(instance->param.gain_tab_dynamic_feed_by_spd));
  // 通过重量修正动态特性补偿(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_dynamic_feed_by_weight,
        s_key_tab_dynamic_feed_by_weight,
        sizeof(instance->param.key_tab_dynamic_feed_by_weight));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_dynamic_feed_by_weight,
        s_gain_tab_dynamic_feed_by_weight,
        sizeof(instance->param.gain_tab_dynamic_feed_by_weight));
  /// 车辆动态特性补偿 (end)

  /// 方向盘角度增益 (begin)
  // 通过方向盘角度修正角度增益(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_steering_feed_by_angle,
        s_key_tab_steering_feed_by_angle,
        sizeof(instance->param.key_tab_steering_feed_by_angle));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_steering_feed_by_angle,
        s_gain_tab_steering_feed_by_angle,
        sizeof(instance->param.gain_tab_steering_feed_by_angle));
  /// 方向盘角度增益 (end)


  // 初始化性能分析模块
  Phoenix_LatCtlAnalyse_Initialize(&(instance->perf_ana.analyser));

  // 时间戳
  instance->timestamp = 0;
    // 初始化定时器
  InitializeTimers(instance);
  // 重置横向控制器(PID)的内部状态
  Phoenix_LatCtlPid_ResetLatCtlValue(instance, 0.0F);
}

/*
 * @brief 重置横向控制器(PID)的内部状态
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void Phoenix_LatCtlPid_ResetLatCtlValue(
    LatCtlPidInstance_t* const ins,
    Float32_t tar_steering_angle) {
  // 重置轨迹信息
  phoenix_com_memset(&(ins->ref_trj_info), 0, sizeof(ins->ref_trj_info));
  InitializeTrjCurvatureInfo(&(ins->ref_trj_info.trj_curv_info), ins->timestamp);
  phoenix_com_memset(
      ins->ref_trj_info.curvature_queue.data_buf, 0, 
      sizeof(ins->ref_trj_info.curvature_queue.data_buf));
  Phoenix_Com_RingBuffer_Init(
      &(ins->ref_trj_info.curvature_queue.ring_buf), LAT_CTL_REF_TRJ_CURVATURE_QUEUE_SIZE,
      sizeof(Float32_t), ins->ref_trj_info.curvature_queue.data_buf);

  // 重置轨迹前馈值滤波器
  phoenix_com_memset(&(ins->trj_feed), 0, sizeof(ins->trj_feed));
  ins->trj_feed.filter.expectation = tar_steering_angle;
  for (Int32_t i = 0; i < MAX_TRJ_FEEDFORWARD_VALUE_LIST_SIZE; ++i) {
    ins->trj_feed.filter.feed_value[i] = tar_steering_angle;
  }

  // 重置反馈补偿控制器
  ResetFeedBackController(ins);

  // 重置动态特性补偿器
  ResetDynamicFeedController(ins);

  // 重置目标方向盘角度值滤波器
  phoenix_com_memset(&(ins->steering_wheel_filter), 0,
                     sizeof(ins->steering_wheel_filter));
  ins->steering_wheel_filter.expectation = tar_steering_angle;
  for (Int32_t i = 0; i < MAX_STEERING_WHEEL_ANGLE_LIST_SIZE; ++i) {
    ins->steering_wheel_filter.angle_list[i] = tar_steering_angle;
  }

  // 重置车辆蛇行检测器
  ResetLatHuntingDetector(ins);
 
  // 重置性能分析模块
  Phoenix_LatCtlAnalyse_Reset(&(ins->perf_ana.analyser));
}

/*
 * @brief 配置横向控制器(PID)的参数
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2022/12/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
void Phoenix_LatCtlPid_Configurate(
    LatCtlPidInstance_t* const instance, const LatCtlPidConf_t* conf) {
  Int32_t valid = 0;

  // 控制器运行周期(s)
  instance->param.ctl_period = conf->ctl_period;

  /// 轨迹前馈 (begin)
  // 最小预瞄距离(current, near, far)
  instance->param.min_leading_len = conf->min_leading_len;
  instance->param.min_near_leading_len = conf->min_near_leading_len;
  instance->param.min_far_leading_len = conf->min_far_leading_len;
  // 通过速度修正预瞄距离(Key table & t-gap table[current, near, far])
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lead_by_spd,
        conf->key_tab_crt_lead_by_spd,
        sizeof(instance->param.key_tab_crt_lead_by_spd));
  // T-Gap
  phoenix_com_memcpy(
        instance->param.tgap_tab_crt_lead_by_spd,
        conf->tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.tgap_tab_crt_lead_by_spd));
  // Near T-Gap
  phoenix_com_memcpy(
        instance->param.near_tgap_tab_crt_lead_by_spd,
        conf->near_tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.near_tgap_tab_crt_lead_by_spd));
  // Far T-Gap
  phoenix_com_memcpy(
        instance->param.far_tgap_tab_crt_lead_by_spd,
        conf->far_tgap_tab_crt_lead_by_spd,
        sizeof(instance->param.far_tgap_tab_crt_lead_by_spd));
  // 通过曲率修正预瞄距离(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lead_by_curvature,
        conf->key_tab_crt_lead_by_curvature,
        sizeof(instance->param.key_tab_crt_lead_by_curvature));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_crt_lead_by_curvature,
        conf->gain_tab_crt_lead_by_curvature,
        sizeof(instance->param.gain_tab_crt_lead_by_curvature));
  /// 轨迹前馈 (end)

  /// 横向误差补偿 (begin)
  // 最大横向误差补偿值 P值
  instance->param.max_lat_err_feed_value_p = conf->max_lat_err_feed_value_p;
  // 最大横向误差补偿值 I值
  instance->param.max_lat_err_feed_value_i = conf->max_lat_err_feed_value_i;
  // 最大横向误差补偿值 D值
  instance->param.max_lat_err_feed_value_d = conf->max_lat_err_feed_value_d;
  // 最大横向误差补偿值
  instance->param.max_lat_err_feed_value = conf->max_lat_err_feed_value;
  // 最大航向角误差补偿值 P值
  instance->param.max_yaw_err_feed_value_p = conf->max_yaw_err_feed_value_p;
  // 最大航向角误差补偿值 I值
  instance->param.max_yaw_err_feed_value_i = conf->max_yaw_err_feed_value_i;
  // 最大航向角误差补偿值 D值
  instance->param.max_yaw_err_feed_value_d = conf->max_yaw_err_feed_value_d;
  // 最大航向角误差补偿值
  instance->param.max_yaw_err_feed_value = conf->max_yaw_err_feed_value;
  // 全局增益
  instance->param.p_global_gain_lat_err_feed = conf->p_global_gain_lat_err_feed;
  instance->param.i_global_gain_lat_err_feed = conf->i_global_gain_lat_err_feed;
  instance->param.d_global_gain_lat_err_feed = conf->d_global_gain_lat_err_feed;
  // 通过速度修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lat_err_feed_by_spd,
        conf->key_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.key_tab_crt_lat_err_feed_by_spd));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_lat_err_feed_by_spd,
        conf->p_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.p_tab_crt_lat_err_feed_by_spd));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_lat_err_feed_by_spd,
        conf->i_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.i_tab_crt_lat_err_feed_by_spd));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_lat_err_feed_by_spd,
        conf->d_tab_crt_lat_err_feed_by_spd,
        sizeof(instance->param.d_tab_crt_lat_err_feed_by_spd));
  // 通过重量修正横向误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_lat_err_feed_by_weight,
        conf->key_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.key_tab_crt_lat_err_feed_by_weight));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_lat_err_feed_by_weight,
        conf->p_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.p_tab_crt_lat_err_feed_by_weight));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_lat_err_feed_by_weight,
        conf->i_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.i_tab_crt_lat_err_feed_by_weight));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_lat_err_feed_by_weight,
        conf->d_tab_crt_lat_err_feed_by_weight,
        sizeof(instance->param.d_tab_crt_lat_err_feed_by_weight));
  // 横向误差补偿Fuzzy Table
  // 误差等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_err_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1,
        conf->tab_lat_err_level);
  // 误差变化率等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_err_spd_level),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE-1,
        conf->tab_lat_err_spd_level);
  // 横向误差补偿系数表
  // P
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        conf->p_gain_tab_lat_err_feed);
  // I
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        conf->i_gain_tab_lat_err_feed);
  // D
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_lat_err_feed),
        LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_ERR_FEED_TABLE_SIZE,
        conf->d_gain_tab_lat_err_feed);
  // Check Fuzzy PID is consistent
  valid = Phoenix_Com_FuzzyPID_CheckConsistent(
        &(instance->lat_err_feed.pid_controller));
  if (valid < 0) {
    LOG_ERR_C("The PID instance is not valid.\n");
  }
  COM_CHECK_C(0 == valid);
  /* k001 pengc 2023-11-07 (begin) */
  // 横向误差速率补偿Fuzzy Table
  // 误差速率等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_spd_err_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1,
        conf->tab_lat_spd_err_level);
  // 误差速率变化率等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_lat_acc_level),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE-1,
        conf->tab_lat_acc_level);
  // 横向误差速率补偿系数表
  // P
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        conf->p_gain_tab_lat_spd_feed);
  // I
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        conf->i_gain_tab_lat_spd_feed);
  // D
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_lat_spd_feed),
        LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE*LAT_CTL_PID_LAT_SPD_FEED_TABLE_SIZE,
        conf->d_gain_tab_lat_spd_feed);
  // Check Fuzzy PID is consistent
  valid = Phoenix_Com_FuzzyPID_CheckConsistent(
        &(instance->lat_spd_feed.pid_controller));
  if (valid < 0) {
    LOG_ERR_C("The PID instance is not valid.\n");
  }
  COM_CHECK_C(0 == valid);
  /* k001 pengc 2023-11-07 (end) */
  // 航向角误差补偿Fuzzy Table
  // 误差等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_err_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1,
        conf->tab_yaw_err_level);
  // 误差变化率等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_err_spd_level),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE-1,
        conf->tab_yaw_err_spd_level);
  // 航向角误差补偿系数表
  // P
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        conf->p_gain_tab_yaw_err_feed);
  // I
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        conf->i_gain_tab_yaw_err_feed);
  // D
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_yaw_err_feed),
        LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_ERR_FEED_TABLE_SIZE,
        conf->d_gain_tab_yaw_err_feed);
  // Check Fuzzy PID is consistent
  valid = Phoenix_Com_FuzzyPID_CheckConsistent(
        &(instance->yaw_err_feed.pid_controller));
  if (valid < 0) {
    LOG_ERR_C("The PID instance is not valid.\n");
  }
  COM_CHECK_C(0 == valid);
  /// 不同横向距离上，横向误差变化率的限制值
  phoenix_com_memcpy(
        instance->param.key_tab_lmt_lat_err_spd,
        conf->key_tab_lmt_lat_err_spd,
        sizeof(instance->param.key_tab_lmt_lat_err_spd));
  // 增益
  phoenix_com_memcpy(
        instance->param.gain_tab_lmt_lat_err_spd,
        conf->gain_tab_lmt_lat_err_spd,
        sizeof(instance->param.gain_tab_lmt_lat_err_spd));
  // 接近的速度
  phoenix_com_memcpy(
        instance->param.base_val_tab_lmt_lat_err_spd_close,
        conf->base_val_tab_lmt_lat_err_spd_close,
        sizeof(instance->param.base_val_tab_lmt_lat_err_spd_close));
  // 远离的速度
  phoenix_com_memcpy(
        instance->param.base_val_tab_lmt_lat_err_spd_far_away,
        conf->base_val_tab_lmt_lat_err_spd_far_away,
        sizeof(instance->param.base_val_tab_lmt_lat_err_spd_far_away));
  /// 横向误差补偿 (end)

  /// 角速度误差补偿 (begin)
  // 最大角速度误差补偿值 P值
  instance->param.max_yaw_rate_err_feed_value_p = conf->max_yaw_rate_err_feed_value_p;
  // 最大角速度误差补偿值 I值
  instance->param.max_yaw_rate_err_feed_value_i = conf->max_yaw_rate_err_feed_value_i;
  // 最大角速度误差补偿值 D值
  instance->param.max_yaw_rate_err_feed_value_d = conf->max_yaw_rate_err_feed_value_d;
  // 最大角速度误差补偿值
  instance->param.max_yaw_rate_err_feed_value = conf->max_yaw_rate_err_feed_value;
  // 全局增益
  instance->param.p_global_gain_yaw_rate_err_feed = conf->p_global_gain_yaw_rate_err_feed;
  instance->param.i_global_gain_yaw_rate_err_feed = conf->i_global_gain_yaw_rate_err_feed;
  instance->param.d_global_gain_yaw_rate_err_feed = conf->d_global_gain_yaw_rate_err_feed;
  // 通过速度修正角速度误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_yaw_rate_err_feed_by_spd,
        conf->key_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.key_tab_crt_yaw_rate_err_feed_by_spd));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_yaw_rate_err_feed_by_spd,
        conf->p_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.p_tab_crt_yaw_rate_err_feed_by_spd));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_yaw_rate_err_feed_by_spd,
        conf->i_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.i_tab_crt_yaw_rate_err_feed_by_spd));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_yaw_rate_err_feed_by_spd,
        conf->d_tab_crt_yaw_rate_err_feed_by_spd,
        sizeof(instance->param.d_tab_crt_yaw_rate_err_feed_by_spd));
  // 通过重量修正角速度误差补偿值(Key table & p-gain table & i-gain table & d-gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_crt_yaw_rate_err_feed_by_weight,
        conf->key_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.key_tab_crt_yaw_rate_err_feed_by_weight));
  // P
  phoenix_com_memcpy(
        instance->param.p_tab_crt_yaw_rate_err_feed_by_weight,
        conf->p_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.p_tab_crt_yaw_rate_err_feed_by_weight));
  // I
  phoenix_com_memcpy(
        instance->param.i_tab_crt_yaw_rate_err_feed_by_weight,
        conf->i_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.i_tab_crt_yaw_rate_err_feed_by_weight));
  // D
  phoenix_com_memcpy(
        instance->param.d_tab_crt_yaw_rate_err_feed_by_weight,
        conf->d_tab_crt_yaw_rate_err_feed_by_weight,
        sizeof(instance->param.d_tab_crt_yaw_rate_err_feed_by_weight));
  // 角速度误差补偿Fuzzy Table
  // 角速度误差等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_rate_err_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1,
        conf->tab_yaw_rate_err_level);
  // 角速度变化率等级表
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.tab_yaw_rate_spd_level),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE-1,
        conf->tab_yaw_rate_spd_level);
  // 角速度误差补偿系数表
  // P
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.p_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        conf->p_gain_tab_yaw_rate_err_feed);
  // I
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.i_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        conf->i_gain_tab_yaw_rate_err_feed);
  // D
  Phoenix_Com_Matrix_InputFromArray_f(
        &(instance->param.d_gain_tab_yaw_rate_err_feed),
        LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE*LAT_CTL_PID_YAW_RATE_ERR_FEED_TABLE_SIZE,
        conf->d_gain_tab_yaw_rate_err_feed);
  // Check Fuzzy PID is consistent
  valid = Phoenix_Com_FuzzyPID_CheckConsistent(
        &(instance->yaw_rate_err_feed.pid_controller));
  if (valid < 0) {
    LOG_ERR_C("The PID instance is not valid.\n");
  }
  COM_CHECK_C(0 == valid);
  /// 角速度误差补偿 (end)

  /// 车辆动态特性补偿 (begin)
  // 最大动力学补值
  instance->param.max_dynamic_feed_value = conf->max_dynamic_feed_value;
  // 通过速度修正动态特性补偿(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_dynamic_feed_by_spd,
        conf->key_tab_dynamic_feed_by_spd,
        sizeof(instance->param.key_tab_dynamic_feed_by_spd));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_dynamic_feed_by_spd,
        conf->gain_tab_dynamic_feed_by_spd,
        sizeof(instance->param.gain_tab_dynamic_feed_by_spd));
  /// 车辆动态特性补偿 (end)

  /// 方向盘角度增益 (begin)
  // 通过方向盘角度修正角度增益(Key table & gain table)
  phoenix_com_memcpy(
        instance->param.key_tab_steering_feed_by_angle,
        conf->key_tab_steering_feed_by_angle,
        sizeof(instance->param.key_tab_steering_feed_by_angle));
  // Gain
  phoenix_com_memcpy(
        instance->param.gain_tab_steering_feed_by_angle,
        conf->gain_tab_steering_feed_by_angle,
        sizeof(instance->param.gain_tab_steering_feed_by_angle));
  /// 方向盘角度增益 (end)
}

/*
 * @brief 计算横向控制量(目标方向盘转角)
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/07/28  <td>1.0      <td>pengc     <td>First edition
 * </table>
 */
Int32_t Phoenix_LatCtlPid_CalcLatCtlValue(
    LatCtlPidInstance_t* const instance,
    const LatCtlDataSource_t* data_source,
    Float32_t* tar_yaw_rate, Float32_t* ctl_value,
    LateralControlPidInfo_t* const status_info) {
  Int32_t index = 0;
  Float32_t sum = 0.0F;
  Float32_t covariance = 0.0F;
  Float32_t gain = 0.0F;
  Float32_t tar_steering_angle_v = 0.0F;

  LatCtlPos_t cur_pos;
  LatCtlPoint2d_t cur_point;
  LatCtlPathPoint_t cur_proj_on_trj;
  Float32_t tar_steering_angle = 0.0F;
  Float32_t tar_steering_angle_smooth = 0.0F;

  if (data_source->param.valid) {
    instance->param.p_global_gain_lat_err_feed =
        data_source->param.p_global_gain_lat_err_feed;
    instance->param.i_global_gain_lat_err_feed =
        data_source->param.i_global_gain_lat_err_feed;
    instance->param.d_global_gain_lat_err_feed =
        data_source->param.d_global_gain_lat_err_feed;

    instance->param.p_global_gain_yaw_rate_err_feed =
        data_source->param.p_global_gain_yaw_rate_err_feed;
    instance->param.i_global_gain_yaw_rate_err_feed =
        data_source->param.i_global_gain_yaw_rate_err_feed;
    instance->param.d_global_gain_yaw_rate_err_feed =
        data_source->param.d_global_gain_yaw_rate_err_feed;
  }

  Int64_t time_elapsed = Phoenix_Common_CalcElapsedClockMs(
        instance->timestamp, data_source->timestamp);
  if (time_elapsed > 200 || time_elapsed < 0) {
    Phoenix_LatCtlPid_ResetLatCtlValue(
          instance, data_source->chassis.steering_wheel_angle);
    LOG_ERR_C("[CTL][LatCtlPid] Time out.");
  }

  // 更新当前的状态
  UpdateCurrentStatus(instance, data_source);
  // 更新定时器
  UpdateTimers(instance);

  // Determine the current location of the vehicle.
  cur_pos.x = data_source->cur_pos.x;
  cur_pos.y = data_source->cur_pos.y;
  cur_pos.heading = data_source->cur_pos.heading;
  cur_pos.v = data_source->cur_pos.v;
  cur_pos.a = data_source->cur_pos.a;
  cur_pos.yaw_rate = data_source->cur_pos.yaw_rate;
  cur_pos.yaw_rate_chg_rate = data_source->cur_pos.yaw_rate_chg_rate;

  if (data_source->tar_trj.points_num < 2) {
    Phoenix_LatCtlPid_ResetLatCtlValue(
          instance, data_source->chassis.steering_wheel_angle);
    // Invalid trajectory
    LOG_ERR_C("[CTL][LatCtlPid] Invalid trajectory (number of points is too small).");
    return (-1);
  }

  // Find the path point closest to the vehicle
  cur_point.x = cur_pos.x;
  cur_point.y = cur_pos.y;
  if (FindProjection(&cur_point, &data_source->tar_trj, &cur_proj_on_trj) < 0) {
    Phoenix_LatCtlPid_ResetLatCtlValue(
          instance, data_source->chassis.steering_wheel_angle);
    LOG_ERR_C("[CTL][LatCtlPid] Invalid trajectory (failed to find projection).");
    return (-2);
  }

  // 分析轨迹信息
  AnalyseRefTrjInfo(instance, data_source, status_info);

  // Calculate target steering wheel angle
  tar_steering_angle = CalcControlValue(
        instance,
        data_source,
        &cur_pos,
        &cur_proj_on_trj,
        tar_yaw_rate,
        status_info);

  if (LAT_CTL_TRJ_DIRECTION_BACKWARD == data_source->tar_trj.direction) {
    tar_steering_angle = -tar_steering_angle;
  }

  // 平滑
#if 0
  Float32_t max_step_angle = 0.9F * 0.017453293F;
  Float32_t angle_diff = tar_steering_angle - status_info->tar_steering_angle_smooth;
  if (angle_diff > max_step_angle) {
    angle_diff = max_step_angle;
  } else if (angle_diff < -max_step_angle) {
    angle_diff = -max_step_angle;
  } else {
    // nothing to do
  }
  tar_steering_angle = status_info->tar_steering_angle_smooth + angle_diff;
#endif

#if 1
  /// Enable smoothing target steering wheel angle
  sum = 0.0F;
  for (index = (MAX_STEERING_WHEEL_ANGLE_LIST_SIZE-1); index > 0; --index) {
    sum +=
        instance->steering_wheel_filter.angle_list[index-1] -
        instance->steering_wheel_filter.angle_list[index];
    instance->steering_wheel_filter.angle_list[index] =
        instance->steering_wheel_filter.angle_list[index-1];
  }
  sum +=
      tar_steering_angle -
      instance->steering_wheel_filter.angle_list[0];
  instance->steering_wheel_filter.angle_list[0] =
      tar_steering_angle;

  tar_steering_angle_v =
      sum / (instance->param.ctl_period * MAX_STEERING_WHEEL_ANGLE_LIST_SIZE);
  //tar_steering_angle_v =
  //    (tar_steering_angle -
  //     instance->steering_wheel_filter.steering_wheel_angle_list[
  //     MAX_STEERING_TRACK_LIST_SIZE-1]) /
  //    (instance->param.ctl_period * MAX_STEERING_TRACK_LIST_SIZE);
  instance->steering_wheel_filter.expectation +=
      tar_steering_angle_v * instance->param.ctl_period;
  covariance = instance->steering_wheel_filter.covariance + 0.1F;
  gain = covariance / (covariance + 0.8F);
  tar_steering_angle_smooth =
      instance->steering_wheel_filter.expectation +
      gain * (tar_steering_angle -
              instance->steering_wheel_filter.expectation);
  covariance = (1.0F - gain) * covariance;
  if (covariance < 1e-6F) {
    covariance = 1e-6F;
  }
  instance->steering_wheel_filter.expectation =
      tar_steering_angle_smooth;
  instance->steering_wheel_filter.covariance = covariance;
#else
  /// Disable smoothing target steering wheel angle
  tar_steering_angle_smooth = tar_steering_angle;
#endif

  *ctl_value = tar_steering_angle_smooth;

  // 更新车辆蛇行检测器
  // UpdateLatHuntingDetector(
  //     instance, data_source, *tar_yaw_rate, status_info);

  // 性能分析
  AnalyseLatCtlPerformance(
    instance, data_source, 
    *tar_yaw_rate, 
    status_info->veh_dynamic_feed.p_feed.feed, 
    status_info);

  // 更新时间戳
  instance->timestamp = data_source->timestamp;
  // 更新之前的状态
  UpdatePreviousStatus(instance, data_source);

  // 更新调试信息
  status_info->tar_steering_angle = tar_steering_angle;
  status_info->tar_steering_angle_smooth = tar_steering_angle_smooth;

  return (0);
}

