// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MpuState.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MpuState_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MpuState_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MpuState_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MpuState_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace MpuState {
class MonitorMpuState;
class MonitorMpuStateDefaultTypeInternal;
extern MonitorMpuStateDefaultTypeInternal _MonitorMpuState_default_instance_;
class MonitorSignal;
class MonitorSignalDefaultTypeInternal;
extern MonitorSignalDefaultTypeInternal _MonitorSignal_default_instance_;
class MonitorState;
class MonitorStateDefaultTypeInternal;
extern MonitorStateDefaultTypeInternal _MonitorState_default_instance_;
class MonitorTraj;
class MonitorTrajDefaultTypeInternal;
extern MonitorTrajDefaultTypeInternal _MonitorTraj_default_instance_;
}  // namespace MpuState
PROTOBUF_NAMESPACE_OPEN
template<> ::MpuState::MonitorMpuState* Arena::CreateMaybeMessage<::MpuState::MonitorMpuState>(Arena*);
template<> ::MpuState::MonitorSignal* Arena::CreateMaybeMessage<::MpuState::MonitorSignal>(Arena*);
template<> ::MpuState::MonitorState* Arena::CreateMaybeMessage<::MpuState::MonitorState>(Arena*);
template<> ::MpuState::MonitorTraj* Arena::CreateMaybeMessage<::MpuState::MonitorTraj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace MpuState {

enum EMPUState : int {
  MPUERR = 0,
  MPUOK = 1,
  EMPUState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EMPUState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EMPUState_IsValid(int value);
constexpr EMPUState EMPUState_MIN = MPUERR;
constexpr EMPUState EMPUState_MAX = MPUOK;
constexpr int EMPUState_ARRAYSIZE = EMPUState_MAX + 1;

const std::string& EMPUState_Name(EMPUState value);
template<typename T>
inline const std::string& EMPUState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EMPUState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EMPUState_Name.");
  return EMPUState_Name(static_cast<EMPUState>(enum_t_value));
}
bool EMPUState_Parse(
    const std::string& name, EMPUState* value);
enum PlanningType : int {
  PlanningTypeOut = 0,
  PlanningTypeIn = 1,
  PlanningType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlanningType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlanningType_IsValid(int value);
constexpr PlanningType PlanningType_MIN = PlanningTypeOut;
constexpr PlanningType PlanningType_MAX = PlanningTypeIn;
constexpr int PlanningType_ARRAYSIZE = PlanningType_MAX + 1;

const std::string& PlanningType_Name(PlanningType value);
template<typename T>
inline const std::string& PlanningType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlanningType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlanningType_Name.");
  return PlanningType_Name(static_cast<PlanningType>(enum_t_value));
}
bool PlanningType_Parse(
    const std::string& name, PlanningType* value);
enum HighWayType : int {
  HighWayTypeOut = 0,
  HighWayTypeIn = 1,
  HighWayTypeDefault = 2,
  HighWayType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HighWayType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HighWayType_IsValid(int value);
constexpr HighWayType HighWayType_MIN = HighWayTypeOut;
constexpr HighWayType HighWayType_MAX = HighWayTypeDefault;
constexpr int HighWayType_ARRAYSIZE = HighWayType_MAX + 1;

const std::string& HighWayType_Name(HighWayType value);
template<typename T>
inline const std::string& HighWayType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HighWayType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HighWayType_Name.");
  return HighWayType_Name(static_cast<HighWayType>(enum_t_value));
}
bool HighWayType_Parse(
    const std::string& name, HighWayType* value);
enum GeofenceType : int {
  GeofenceTypeRamp150 = 0,
  GeofenceTypeInRamp = 1,
  GeofenceTypeTunnel200 = 2,
  GeofenceTypeInTunnel = 3,
  GeofenceTypeOutTunnel = 4,
  GeofenceTypeExceCurvature = 5,
  GeofenceTypeDefault = 15,
  GeofenceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GeofenceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GeofenceType_IsValid(int value);
constexpr GeofenceType GeofenceType_MIN = GeofenceTypeRamp150;
constexpr GeofenceType GeofenceType_MAX = GeofenceTypeDefault;
constexpr int GeofenceType_ARRAYSIZE = GeofenceType_MAX + 1;

const std::string& GeofenceType_Name(GeofenceType value);
template<typename T>
inline const std::string& GeofenceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GeofenceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GeofenceType_Name.");
  return GeofenceType_Name(static_cast<GeofenceType>(enum_t_value));
}
bool GeofenceType_Parse(
    const std::string& name, GeofenceType* value);
// ===================================================================

class MonitorState :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MpuState.MonitorState) */ {
 public:
  MonitorState();
  virtual ~MonitorState();

  MonitorState(const MonitorState& from);
  MonitorState(MonitorState&& from) noexcept
    : MonitorState() {
    *this = ::std::move(from);
  }

  inline MonitorState& operator=(const MonitorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorState& operator=(MonitorState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MonitorState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorState* internal_default_instance() {
    return reinterpret_cast<const MonitorState*>(
               &_MonitorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MonitorState& a, MonitorState& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonitorState* New() const final {
    return CreateMaybeMessage<MonitorState>(nullptr);
  }

  MonitorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonitorState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MonitorState& from);
  void MergeFrom(const MonitorState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MonitorState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MpuState.MonitorState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAntennaConnectStatusFieldNumber = 1,
    kMpuMCURunStatusFieldNumber = 2,
    kMpuSOCRunStatusFieldNumber = 3,
    kF9KDemarcateStatusFieldNumber = 4,
    kMpuEngineRunStatusFieldNumber = 5,
    kIsHasMapDataFieldNumber = 6,
    kVehicleCANDataFieldNumber = 7,
    kFrontCameraLineStatusFieldNumber = 8,
  };
  // bool AntennaConnectStatus = 1;
  void clear_antennaconnectstatus();
  bool antennaconnectstatus() const;
  void set_antennaconnectstatus(bool value);

  // bool MpuMCURunStatus = 2;
  void clear_mpumcurunstatus();
  bool mpumcurunstatus() const;
  void set_mpumcurunstatus(bool value);

  // bool MpuSOCRunStatus = 3;
  void clear_mpusocrunstatus();
  bool mpusocrunstatus() const;
  void set_mpusocrunstatus(bool value);

  // bool F9KDemarcateStatus = 4;
  void clear_f9kdemarcatestatus();
  bool f9kdemarcatestatus() const;
  void set_f9kdemarcatestatus(bool value);

  // bool MpuEngineRunStatus = 5;
  void clear_mpuenginerunstatus();
  bool mpuenginerunstatus() const;
  void set_mpuenginerunstatus(bool value);

  // bool IsHasMapData = 6;
  void clear_ishasmapdata();
  bool ishasmapdata() const;
  void set_ishasmapdata(bool value);

  // bool VehicleCANData = 7;
  void clear_vehiclecandata();
  bool vehiclecandata() const;
  void set_vehiclecandata(bool value);

  // bool FrontCameraLineStatus = 8;
  void clear_frontcameralinestatus();
  bool frontcameralinestatus() const;
  void set_frontcameralinestatus(bool value);

  // @@protoc_insertion_point(class_scope:MpuState.MonitorState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool antennaconnectstatus_;
  bool mpumcurunstatus_;
  bool mpusocrunstatus_;
  bool f9kdemarcatestatus_;
  bool mpuenginerunstatus_;
  bool ishasmapdata_;
  bool vehiclecandata_;
  bool frontcameralinestatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MpuState_2eproto;
};
// -------------------------------------------------------------------

class MonitorSignal :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MpuState.MonitorSignal) */ {
 public:
  MonitorSignal();
  virtual ~MonitorSignal();

  MonitorSignal(const MonitorSignal& from);
  MonitorSignal(MonitorSignal&& from) noexcept
    : MonitorSignal() {
    *this = ::std::move(from);
  }

  inline MonitorSignal& operator=(const MonitorSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorSignal& operator=(MonitorSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MonitorSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorSignal* internal_default_instance() {
    return reinterpret_cast<const MonitorSignal*>(
               &_MonitorSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MonitorSignal& a, MonitorSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorSignal* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonitorSignal* New() const final {
    return CreateMaybeMessage<MonitorSignal>(nullptr);
  }

  MonitorSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonitorSignal>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MonitorSignal& from);
  void MergeFrom(const MonitorSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MonitorSignal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MpuState.MonitorSignal";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF9KGnssWeakenStatusFieldNumber = 1,
    kF9KRTKStatusFieldNumber = 2,
    kF9KImuInitStatusFieldNumber = 3,
    kFrontCameraConfidenceFieldNumber = 4,
    kFusiionConfidenceStatusFieldNumber = 5,
  };
  // bool F9KGnssWeakenStatus = 1;
  void clear_f9kgnssweakenstatus();
  bool f9kgnssweakenstatus() const;
  void set_f9kgnssweakenstatus(bool value);

  // bool F9kRTKStatus = 2;
  void clear_f9krtkstatus();
  bool f9krtkstatus() const;
  void set_f9krtkstatus(bool value);

  // bool F9kImuInitStatus = 3;
  void clear_f9kimuinitstatus();
  bool f9kimuinitstatus() const;
  void set_f9kimuinitstatus(bool value);

  // bool FrontCameraConfidence = 4;
  void clear_frontcameraconfidence();
  bool frontcameraconfidence() const;
  void set_frontcameraconfidence(bool value);

  // bool FusiionConfidenceStatus = 5;
  void clear_fusiionconfidencestatus();
  bool fusiionconfidencestatus() const;
  void set_fusiionconfidencestatus(bool value);

  // @@protoc_insertion_point(class_scope:MpuState.MonitorSignal)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool f9kgnssweakenstatus_;
  bool f9krtkstatus_;
  bool f9kimuinitstatus_;
  bool frontcameraconfidence_;
  bool fusiionconfidencestatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MpuState_2eproto;
};
// -------------------------------------------------------------------

class MonitorTraj :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MpuState.MonitorTraj) */ {
 public:
  MonitorTraj();
  virtual ~MonitorTraj();

  MonitorTraj(const MonitorTraj& from);
  MonitorTraj(MonitorTraj&& from) noexcept
    : MonitorTraj() {
    *this = ::std::move(from);
  }

  inline MonitorTraj& operator=(const MonitorTraj& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorTraj& operator=(MonitorTraj&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MonitorTraj& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorTraj* internal_default_instance() {
    return reinterpret_cast<const MonitorTraj*>(
               &_MonitorTraj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MonitorTraj& a, MonitorTraj& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorTraj* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonitorTraj* New() const final {
    return CreateMaybeMessage<MonitorTraj>(nullptr);
  }

  MonitorTraj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonitorTraj>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MonitorTraj& from);
  void MergeFrom(const MonitorTraj& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MonitorTraj* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MpuState.MonitorTraj";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanningStateFieldNumber = 1,
    kGeofenceStateFieldNumber = 2,
  };
  // .MpuState.PlanningType planningState = 1;
  void clear_planningstate();
  ::MpuState::PlanningType planningstate() const;
  void set_planningstate(::MpuState::PlanningType value);

  // .MpuState.GeofenceType geofenceState = 2;
  void clear_geofencestate();
  ::MpuState::GeofenceType geofencestate() const;
  void set_geofencestate(::MpuState::GeofenceType value);

  // @@protoc_insertion_point(class_scope:MpuState.MonitorTraj)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int planningstate_;
  int geofencestate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MpuState_2eproto;
};
// -------------------------------------------------------------------

class MonitorMpuState :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:MpuState.MonitorMpuState) */ {
 public:
  MonitorMpuState();
  virtual ~MonitorMpuState();

  MonitorMpuState(const MonitorMpuState& from);
  MonitorMpuState(MonitorMpuState&& from) noexcept
    : MonitorMpuState() {
    *this = ::std::move(from);
  }

  inline MonitorMpuState& operator=(const MonitorMpuState& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorMpuState& operator=(MonitorMpuState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MonitorMpuState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MonitorMpuState* internal_default_instance() {
    return reinterpret_cast<const MonitorMpuState*>(
               &_MonitorMpuState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MonitorMpuState& a, MonitorMpuState& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorMpuState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MonitorMpuState* New() const final {
    return CreateMaybeMessage<MonitorMpuState>(nullptr);
  }

  MonitorMpuState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MonitorMpuState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const MonitorMpuState& from);
  void MergeFrom(const MonitorMpuState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MonitorMpuState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MpuState.MonitorMpuState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrajValueFieldNumber = 6,
    kStateValueFieldNumber = 7,
    kSinglValueFieldNumber = 8,
    kTimeStampFieldNumber = 1,
    kStateFieldNumber = 2,
    kSingleFieldNumber = 3,
    kTrajFieldNumber = 4,
    kFussValueFieldNumber = 5,
    kHighWayFieldNumber = 9,
    kLimitSpeedMaxFieldNumber = 10,
    kLimitSpeedMinFieldNumber = 11,
  };
  // .MpuState.MonitorTraj TrajValue = 6;
  bool has_trajvalue() const;
  void clear_trajvalue();
  const ::MpuState::MonitorTraj& trajvalue() const;
  ::MpuState::MonitorTraj* release_trajvalue();
  ::MpuState::MonitorTraj* mutable_trajvalue();
  void set_allocated_trajvalue(::MpuState::MonitorTraj* trajvalue);

  // .MpuState.MonitorState StateValue = 7;
  bool has_statevalue() const;
  void clear_statevalue();
  const ::MpuState::MonitorState& statevalue() const;
  ::MpuState::MonitorState* release_statevalue();
  ::MpuState::MonitorState* mutable_statevalue();
  void set_allocated_statevalue(::MpuState::MonitorState* statevalue);

  // .MpuState.MonitorSignal SinglValue = 8;
  bool has_singlvalue() const;
  void clear_singlvalue();
  const ::MpuState::MonitorSignal& singlvalue() const;
  ::MpuState::MonitorSignal* release_singlvalue();
  ::MpuState::MonitorSignal* mutable_singlvalue();
  void set_allocated_singlvalue(::MpuState::MonitorSignal* singlvalue);

  // uint64 TimeStamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .MpuState.EMPUState State = 2;
  void clear_state();
  ::MpuState::EMPUState state() const;
  void set_state(::MpuState::EMPUState value);

  // .MpuState.EMPUState Single = 3;
  void clear_single();
  ::MpuState::EMPUState single() const;
  void set_single(::MpuState::EMPUState value);

  // .MpuState.EMPUState Traj = 4;
  void clear_traj();
  ::MpuState::EMPUState traj() const;
  void set_traj(::MpuState::EMPUState value);

  // uint32 FussValue = 5;
  void clear_fussvalue();
  ::PROTOBUF_NAMESPACE_ID::uint32 fussvalue() const;
  void set_fussvalue(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .MpuState.HighWayType HighWay = 9;
  void clear_highway();
  ::MpuState::HighWayType highway() const;
  void set_highway(::MpuState::HighWayType value);

  // uint32 LimitSpeedMax = 10;
  void clear_limitspeedmax();
  ::PROTOBUF_NAMESPACE_ID::uint32 limitspeedmax() const;
  void set_limitspeedmax(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 LimitSpeedMin = 11;
  void clear_limitspeedmin();
  ::PROTOBUF_NAMESPACE_ID::uint32 limitspeedmin() const;
  void set_limitspeedmin(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:MpuState.MonitorMpuState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::MpuState::MonitorTraj* trajvalue_;
  ::MpuState::MonitorState* statevalue_;
  ::MpuState::MonitorSignal* singlvalue_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  int state_;
  int single_;
  int traj_;
  ::PROTOBUF_NAMESPACE_ID::uint32 fussvalue_;
  int highway_;
  ::PROTOBUF_NAMESPACE_ID::uint32 limitspeedmax_;
  ::PROTOBUF_NAMESPACE_ID::uint32 limitspeedmin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_MpuState_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MonitorState

// bool AntennaConnectStatus = 1;
inline void MonitorState::clear_antennaconnectstatus() {
  antennaconnectstatus_ = false;
}
inline bool MonitorState::antennaconnectstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.AntennaConnectStatus)
  return antennaconnectstatus_;
}
inline void MonitorState::set_antennaconnectstatus(bool value) {
  
  antennaconnectstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.AntennaConnectStatus)
}

// bool MpuMCURunStatus = 2;
inline void MonitorState::clear_mpumcurunstatus() {
  mpumcurunstatus_ = false;
}
inline bool MonitorState::mpumcurunstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.MpuMCURunStatus)
  return mpumcurunstatus_;
}
inline void MonitorState::set_mpumcurunstatus(bool value) {
  
  mpumcurunstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.MpuMCURunStatus)
}

// bool MpuSOCRunStatus = 3;
inline void MonitorState::clear_mpusocrunstatus() {
  mpusocrunstatus_ = false;
}
inline bool MonitorState::mpusocrunstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.MpuSOCRunStatus)
  return mpusocrunstatus_;
}
inline void MonitorState::set_mpusocrunstatus(bool value) {
  
  mpusocrunstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.MpuSOCRunStatus)
}

// bool F9KDemarcateStatus = 4;
inline void MonitorState::clear_f9kdemarcatestatus() {
  f9kdemarcatestatus_ = false;
}
inline bool MonitorState::f9kdemarcatestatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.F9KDemarcateStatus)
  return f9kdemarcatestatus_;
}
inline void MonitorState::set_f9kdemarcatestatus(bool value) {
  
  f9kdemarcatestatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.F9KDemarcateStatus)
}

// bool MpuEngineRunStatus = 5;
inline void MonitorState::clear_mpuenginerunstatus() {
  mpuenginerunstatus_ = false;
}
inline bool MonitorState::mpuenginerunstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.MpuEngineRunStatus)
  return mpuenginerunstatus_;
}
inline void MonitorState::set_mpuenginerunstatus(bool value) {
  
  mpuenginerunstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.MpuEngineRunStatus)
}

// bool IsHasMapData = 6;
inline void MonitorState::clear_ishasmapdata() {
  ishasmapdata_ = false;
}
inline bool MonitorState::ishasmapdata() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.IsHasMapData)
  return ishasmapdata_;
}
inline void MonitorState::set_ishasmapdata(bool value) {
  
  ishasmapdata_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.IsHasMapData)
}

// bool VehicleCANData = 7;
inline void MonitorState::clear_vehiclecandata() {
  vehiclecandata_ = false;
}
inline bool MonitorState::vehiclecandata() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.VehicleCANData)
  return vehiclecandata_;
}
inline void MonitorState::set_vehiclecandata(bool value) {
  
  vehiclecandata_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.VehicleCANData)
}

// bool FrontCameraLineStatus = 8;
inline void MonitorState::clear_frontcameralinestatus() {
  frontcameralinestatus_ = false;
}
inline bool MonitorState::frontcameralinestatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorState.FrontCameraLineStatus)
  return frontcameralinestatus_;
}
inline void MonitorState::set_frontcameralinestatus(bool value) {
  
  frontcameralinestatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorState.FrontCameraLineStatus)
}

// -------------------------------------------------------------------

// MonitorSignal

// bool F9KGnssWeakenStatus = 1;
inline void MonitorSignal::clear_f9kgnssweakenstatus() {
  f9kgnssweakenstatus_ = false;
}
inline bool MonitorSignal::f9kgnssweakenstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorSignal.F9KGnssWeakenStatus)
  return f9kgnssweakenstatus_;
}
inline void MonitorSignal::set_f9kgnssweakenstatus(bool value) {
  
  f9kgnssweakenstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorSignal.F9KGnssWeakenStatus)
}

// bool F9kRTKStatus = 2;
inline void MonitorSignal::clear_f9krtkstatus() {
  f9krtkstatus_ = false;
}
inline bool MonitorSignal::f9krtkstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorSignal.F9kRTKStatus)
  return f9krtkstatus_;
}
inline void MonitorSignal::set_f9krtkstatus(bool value) {
  
  f9krtkstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorSignal.F9kRTKStatus)
}

// bool F9kImuInitStatus = 3;
inline void MonitorSignal::clear_f9kimuinitstatus() {
  f9kimuinitstatus_ = false;
}
inline bool MonitorSignal::f9kimuinitstatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorSignal.F9kImuInitStatus)
  return f9kimuinitstatus_;
}
inline void MonitorSignal::set_f9kimuinitstatus(bool value) {
  
  f9kimuinitstatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorSignal.F9kImuInitStatus)
}

// bool FrontCameraConfidence = 4;
inline void MonitorSignal::clear_frontcameraconfidence() {
  frontcameraconfidence_ = false;
}
inline bool MonitorSignal::frontcameraconfidence() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorSignal.FrontCameraConfidence)
  return frontcameraconfidence_;
}
inline void MonitorSignal::set_frontcameraconfidence(bool value) {
  
  frontcameraconfidence_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorSignal.FrontCameraConfidence)
}

// bool FusiionConfidenceStatus = 5;
inline void MonitorSignal::clear_fusiionconfidencestatus() {
  fusiionconfidencestatus_ = false;
}
inline bool MonitorSignal::fusiionconfidencestatus() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorSignal.FusiionConfidenceStatus)
  return fusiionconfidencestatus_;
}
inline void MonitorSignal::set_fusiionconfidencestatus(bool value) {
  
  fusiionconfidencestatus_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorSignal.FusiionConfidenceStatus)
}

// -------------------------------------------------------------------

// MonitorTraj

// .MpuState.PlanningType planningState = 1;
inline void MonitorTraj::clear_planningstate() {
  planningstate_ = 0;
}
inline ::MpuState::PlanningType MonitorTraj::planningstate() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorTraj.planningState)
  return static_cast< ::MpuState::PlanningType >(planningstate_);
}
inline void MonitorTraj::set_planningstate(::MpuState::PlanningType value) {
  
  planningstate_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorTraj.planningState)
}

// .MpuState.GeofenceType geofenceState = 2;
inline void MonitorTraj::clear_geofencestate() {
  geofencestate_ = 0;
}
inline ::MpuState::GeofenceType MonitorTraj::geofencestate() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorTraj.geofenceState)
  return static_cast< ::MpuState::GeofenceType >(geofencestate_);
}
inline void MonitorTraj::set_geofencestate(::MpuState::GeofenceType value) {
  
  geofencestate_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorTraj.geofenceState)
}

// -------------------------------------------------------------------

// MonitorMpuState

// uint64 TimeStamp = 1;
inline void MonitorMpuState::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MonitorMpuState::timestamp() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.TimeStamp)
  return timestamp_;
}
inline void MonitorMpuState::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.TimeStamp)
}

// .MpuState.EMPUState State = 2;
inline void MonitorMpuState::clear_state() {
  state_ = 0;
}
inline ::MpuState::EMPUState MonitorMpuState::state() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.State)
  return static_cast< ::MpuState::EMPUState >(state_);
}
inline void MonitorMpuState::set_state(::MpuState::EMPUState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.State)
}

// .MpuState.EMPUState Single = 3;
inline void MonitorMpuState::clear_single() {
  single_ = 0;
}
inline ::MpuState::EMPUState MonitorMpuState::single() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.Single)
  return static_cast< ::MpuState::EMPUState >(single_);
}
inline void MonitorMpuState::set_single(::MpuState::EMPUState value) {
  
  single_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.Single)
}

// .MpuState.EMPUState Traj = 4;
inline void MonitorMpuState::clear_traj() {
  traj_ = 0;
}
inline ::MpuState::EMPUState MonitorMpuState::traj() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.Traj)
  return static_cast< ::MpuState::EMPUState >(traj_);
}
inline void MonitorMpuState::set_traj(::MpuState::EMPUState value) {
  
  traj_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.Traj)
}

// uint32 FussValue = 5;
inline void MonitorMpuState::clear_fussvalue() {
  fussvalue_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MonitorMpuState::fussvalue() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.FussValue)
  return fussvalue_;
}
inline void MonitorMpuState::set_fussvalue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  fussvalue_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.FussValue)
}

// .MpuState.MonitorTraj TrajValue = 6;
inline bool MonitorMpuState::has_trajvalue() const {
  return this != internal_default_instance() && trajvalue_ != nullptr;
}
inline void MonitorMpuState::clear_trajvalue() {
  if (GetArenaNoVirtual() == nullptr && trajvalue_ != nullptr) {
    delete trajvalue_;
  }
  trajvalue_ = nullptr;
}
inline const ::MpuState::MonitorTraj& MonitorMpuState::trajvalue() const {
  const ::MpuState::MonitorTraj* p = trajvalue_;
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.TrajValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::MpuState::MonitorTraj*>(
      &::MpuState::_MonitorTraj_default_instance_);
}
inline ::MpuState::MonitorTraj* MonitorMpuState::release_trajvalue() {
  // @@protoc_insertion_point(field_release:MpuState.MonitorMpuState.TrajValue)
  
  ::MpuState::MonitorTraj* temp = trajvalue_;
  trajvalue_ = nullptr;
  return temp;
}
inline ::MpuState::MonitorTraj* MonitorMpuState::mutable_trajvalue() {
  
  if (trajvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::MpuState::MonitorTraj>(GetArenaNoVirtual());
    trajvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MpuState.MonitorMpuState.TrajValue)
  return trajvalue_;
}
inline void MonitorMpuState::set_allocated_trajvalue(::MpuState::MonitorTraj* trajvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trajvalue_;
  }
  if (trajvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trajvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trajvalue, submessage_arena);
    }
    
  } else {
    
  }
  trajvalue_ = trajvalue;
  // @@protoc_insertion_point(field_set_allocated:MpuState.MonitorMpuState.TrajValue)
}

// .MpuState.MonitorState StateValue = 7;
inline bool MonitorMpuState::has_statevalue() const {
  return this != internal_default_instance() && statevalue_ != nullptr;
}
inline void MonitorMpuState::clear_statevalue() {
  if (GetArenaNoVirtual() == nullptr && statevalue_ != nullptr) {
    delete statevalue_;
  }
  statevalue_ = nullptr;
}
inline const ::MpuState::MonitorState& MonitorMpuState::statevalue() const {
  const ::MpuState::MonitorState* p = statevalue_;
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.StateValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::MpuState::MonitorState*>(
      &::MpuState::_MonitorState_default_instance_);
}
inline ::MpuState::MonitorState* MonitorMpuState::release_statevalue() {
  // @@protoc_insertion_point(field_release:MpuState.MonitorMpuState.StateValue)
  
  ::MpuState::MonitorState* temp = statevalue_;
  statevalue_ = nullptr;
  return temp;
}
inline ::MpuState::MonitorState* MonitorMpuState::mutable_statevalue() {
  
  if (statevalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::MpuState::MonitorState>(GetArenaNoVirtual());
    statevalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MpuState.MonitorMpuState.StateValue)
  return statevalue_;
}
inline void MonitorMpuState::set_allocated_statevalue(::MpuState::MonitorState* statevalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete statevalue_;
  }
  if (statevalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      statevalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statevalue, submessage_arena);
    }
    
  } else {
    
  }
  statevalue_ = statevalue;
  // @@protoc_insertion_point(field_set_allocated:MpuState.MonitorMpuState.StateValue)
}

// .MpuState.MonitorSignal SinglValue = 8;
inline bool MonitorMpuState::has_singlvalue() const {
  return this != internal_default_instance() && singlvalue_ != nullptr;
}
inline void MonitorMpuState::clear_singlvalue() {
  if (GetArenaNoVirtual() == nullptr && singlvalue_ != nullptr) {
    delete singlvalue_;
  }
  singlvalue_ = nullptr;
}
inline const ::MpuState::MonitorSignal& MonitorMpuState::singlvalue() const {
  const ::MpuState::MonitorSignal* p = singlvalue_;
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.SinglValue)
  return p != nullptr ? *p : *reinterpret_cast<const ::MpuState::MonitorSignal*>(
      &::MpuState::_MonitorSignal_default_instance_);
}
inline ::MpuState::MonitorSignal* MonitorMpuState::release_singlvalue() {
  // @@protoc_insertion_point(field_release:MpuState.MonitorMpuState.SinglValue)
  
  ::MpuState::MonitorSignal* temp = singlvalue_;
  singlvalue_ = nullptr;
  return temp;
}
inline ::MpuState::MonitorSignal* MonitorMpuState::mutable_singlvalue() {
  
  if (singlvalue_ == nullptr) {
    auto* p = CreateMaybeMessage<::MpuState::MonitorSignal>(GetArenaNoVirtual());
    singlvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MpuState.MonitorMpuState.SinglValue)
  return singlvalue_;
}
inline void MonitorMpuState::set_allocated_singlvalue(::MpuState::MonitorSignal* singlvalue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete singlvalue_;
  }
  if (singlvalue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      singlvalue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, singlvalue, submessage_arena);
    }
    
  } else {
    
  }
  singlvalue_ = singlvalue;
  // @@protoc_insertion_point(field_set_allocated:MpuState.MonitorMpuState.SinglValue)
}

// .MpuState.HighWayType HighWay = 9;
inline void MonitorMpuState::clear_highway() {
  highway_ = 0;
}
inline ::MpuState::HighWayType MonitorMpuState::highway() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.HighWay)
  return static_cast< ::MpuState::HighWayType >(highway_);
}
inline void MonitorMpuState::set_highway(::MpuState::HighWayType value) {
  
  highway_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.HighWay)
}

// uint32 LimitSpeedMax = 10;
inline void MonitorMpuState::clear_limitspeedmax() {
  limitspeedmax_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MonitorMpuState::limitspeedmax() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.LimitSpeedMax)
  return limitspeedmax_;
}
inline void MonitorMpuState::set_limitspeedmax(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  limitspeedmax_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.LimitSpeedMax)
}

// uint32 LimitSpeedMin = 11;
inline void MonitorMpuState::clear_limitspeedmin() {
  limitspeedmin_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MonitorMpuState::limitspeedmin() const {
  // @@protoc_insertion_point(field_get:MpuState.MonitorMpuState.LimitSpeedMin)
  return limitspeedmin_;
}
inline void MonitorMpuState::set_limitspeedmin(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  limitspeedmin_ = value;
  // @@protoc_insertion_point(field_set:MpuState.MonitorMpuState.LimitSpeedMin)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MpuState

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MpuState::EMPUState> : ::std::true_type {};
template <> struct is_proto_enum< ::MpuState::PlanningType> : ::std::true_type {};
template <> struct is_proto_enum< ::MpuState::HighWayType> : ::std::true_type {};
template <> struct is_proto_enum< ::MpuState::GeofenceType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MpuState_2eproto
