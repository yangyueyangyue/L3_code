/** @copyright Copyright (c) 2018-2020 Kotei Technology Co., Ltd.
 ******************************************************************************
 * @file       data_serialization.h
 * @brief      通讯用的数据序列化
 * @details    实现了基通讯用的数据序列化的操作函数
 *
 * @author     longjiaoy
 * @date       2021.02.06
 * @version    v1.0
 *
 * @par Change Log:
 * <table>
 * <tr><th>Date        <th>Version  <th>Author    <th>Description
 * <tr><td>2021/02/06  <td>1.0      <td>longjiaoy     <td>First edition
 * </table>
 *
 ******************************************************************************/
#ifndef PHOENIX_DATA_SERIAL_SERIAL_MSG_OBSTACLE_H_
#define PHOENIX_DATA_SERIAL_SERIAL_MSG_OBSTACLE_H_


#include "ad_msg.h"
#include "utils/macros.h"
#include "utils/com_utils.h"


namespace phoenix {
namespace data_serial {
/**
 * @brief 序列化 OBBox 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeOBBoxArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::OBBox* p, Int32_t elements);

/**
 * @brief 反序列化 OBBox 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeOBBoxArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::OBBox* p, Int32_t elements);


/**
 * @brief 序列化 ObstacleCamera 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleCameraArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleCamera* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleCamera 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleCameraArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleCamera* p, Int32_t elements);

/**
 * @brief 序列化 ObstacleCameraList 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleCameraListArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleCameraList* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleCameraList 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleCameraListArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleCameraList* p, Int32_t elements);

/**
 * @brief 序列化 ObstacleRadar 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleRadarArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleRadar* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleRadar 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleRadarArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleRadar* p, Int32_t elements);

/**
 * @brief 序列化 ObstacleRadarList 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleRadarListArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleRadarList* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleRadarList 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleRadarListArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleRadarList* p, Int32_t elements);


/**
 * @brief 序列化 Obstacle 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::Obstacle* p, Int32_t elements);

/**
 * @brief 反序列化 Obstacle 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::Obstacle* p, Int32_t elements);

/**
 * @brief 序列化 ObstacleList 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleListArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleList* p, Int32_t elements);

/**
 * @brief 反序列化 Obstacle 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleListArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleList* p, Int32_t elements);

/**
 * @brief 序列化 ObstacleTrackedInfo(调试用) 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleTrackedInfoArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleTrackedInfo* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleTrackedInfo(调试用) 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleTrackedInfoArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleTrackedInfo* p, Int32_t elements);


/**
 * @brief 序列化 ObstacleTrackedInfo(调试用) 数组
 * @param buf[in] 保存序列化后的数据的内存首地址
 * @param offset[in] 保存序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 保存序列化后的数据的内存的最大尺寸
 * @param p[in] 需要序列化的数组的起始地址
 * @param elements[in] 需要序列化的数组元素的个数
 * @return  序列化后的数据的尺寸, -1 表示序列化失败
 */
Int32_t EncodeObstacleTrackedInfoListArray(
    void* buf, Int32_t offset, Int32_t maxlen,
    const ad_msg::ObstacleTrackedInfoList* p, Int32_t elements);

/**
 * @brief 反序列化 ObstacleTrackedInfo(调试用) 数组
 * @param buf[in] 序列化后的数据的内存首地址
 * @param offset[in] 序列化后的数据的内存首地址的偏移量
 * @param maxlen[in] 序列化后的数据的内存的最大尺寸
 * @param p[in] 保存反序列化后的数组的起始地址
 * @param elements[in] 需要反序列化的数组元素的个数
 * @return  反序列化后的数据的尺寸, -1 表示反序列化失败
 */
Int32_t DecodeObstacleTrackedInfoListArray(
    const void* buf, Int32_t offset, Int32_t maxlen,
    ad_msg::ObstacleTrackedInfoList* p, Int32_t elements);


}  // namespace data_serial
}  // namespace phoenix


#endif // PHOENIX_DATA_SERIAL_SERIAL_MSG_OBSTACLE_H_
